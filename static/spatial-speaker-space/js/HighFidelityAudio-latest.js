var HighFidelityAudio;HighFidelityAudio =
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/pako/index.js":
/*!************************************!*\
  !*** ./node_modules/pako/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Top level file is just a mixin of submodules & constants


const { Deflate, deflate, deflateRaw, gzip } = __webpack_require__(/*! ./lib/deflate */ "./node_modules/pako/lib/deflate.js");

const { Inflate, inflate, inflateRaw, ungzip } = __webpack_require__(/*! ./lib/inflate */ "./node_modules/pako/lib/inflate.js");

const constants = __webpack_require__(/*! ./lib/zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");

module.exports.Deflate = Deflate;
module.exports.deflate = deflate;
module.exports.deflateRaw = deflateRaw;
module.exports.gzip = gzip;
module.exports.Inflate = Inflate;
module.exports.inflate = inflate;
module.exports.inflateRaw = inflateRaw;
module.exports.ungzip = ungzip;
module.exports.constants = constants;


/***/ }),

/***/ "./node_modules/pako/lib/deflate.js":
/*!******************************************!*\
  !*** ./node_modules/pako/lib/deflate.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";



const zlib_deflate = __webpack_require__(/*! ./zlib/deflate */ "./node_modules/pako/lib/zlib/deflate.js");
const utils        = __webpack_require__(/*! ./utils/common */ "./node_modules/pako/lib/utils/common.js");
const strings      = __webpack_require__(/*! ./utils/strings */ "./node_modules/pako/lib/utils/strings.js");
const msg          = __webpack_require__(/*! ./zlib/messages */ "./node_modules/pako/lib/zlib/messages.js");
const ZStream      = __webpack_require__(/*! ./zlib/zstream */ "./node_modules/pako/lib/zlib/zstream.js");

const toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH,
  Z_OK, Z_STREAM_END,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED
} = __webpack_require__(/*! ./zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});

  let opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  let status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    let dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must
 * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending
 * buffers and call [[Deflate#onEnd]].
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;

  if (this.ended) { return false; }

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    // Make sure avail_out > 6 to avoid repeating markers
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    status = zlib_deflate.deflate(strm, _flush_mode);

    // Ended => flush and finish
    if (status === Z_STREAM_END) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = zlib_deflate.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK;
    }

    // Flush if out buffer full
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }

    // Flush if requested and has data
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array): output data.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    this.result = utils.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array
 * - data (Uint8Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  const deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array
 * - data (Uint8Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array
 * - data (Uint8Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}


module.exports.Deflate = Deflate;
module.exports.deflate = deflate;
module.exports.deflateRaw = deflateRaw;
module.exports.gzip = gzip;
module.exports.constants = __webpack_require__(/*! ./zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");


/***/ }),

/***/ "./node_modules/pako/lib/inflate.js":
/*!******************************************!*\
  !*** ./node_modules/pako/lib/inflate.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";



const zlib_inflate = __webpack_require__(/*! ./zlib/inflate */ "./node_modules/pako/lib/zlib/inflate.js");
const utils        = __webpack_require__(/*! ./utils/common */ "./node_modules/pako/lib/utils/common.js");
const strings      = __webpack_require__(/*! ./utils/strings */ "./node_modules/pako/lib/utils/strings.js");
const msg          = __webpack_require__(/*! ./zlib/messages */ "./node_modules/pako/lib/zlib/messages.js");
const ZStream      = __webpack_require__(/*! ./zlib/zstream */ "./node_modules/pako/lib/zlib/zstream.js");
const GZheader     = __webpack_require__(/*! ./zlib/gzheader */ "./node_modules/pako/lib/zlib/gzheader.js");

const toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_FINISH,
  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR
} = __webpack_require__(/*! ./zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");

/* ===========================================================================*/


/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  this.options = utils.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ''
  }, options || {});

  const opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  let status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer): input data
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
 *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,
 *   `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. If end of stream detected,
 * [[Inflate#onEnd]] will be called.
 *
 * `flush_mode` is not needed for normal operation, because end of stream
 * detected automatically. You may try to use it for advanced things, but
 * this functionality was not tested.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;

  if (this.ended) return false;

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, _flush_mode);

    if (status === Z_NEED_DICT && dictionary) {
      status = zlib_inflate.inflateSetDictionary(strm, dictionary);

      if (status === Z_OK) {
        status = zlib_inflate.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        // Replace code with more verbose
        status = Z_NEED_DICT;
      }
    }

    // Skip snyc markers if more data follows and not raw mode
    while (strm.avail_in > 0 &&
           status === Z_STREAM_END &&
           strm.state.wrap > 0 &&
           data[strm.next_in] !== 0)
    {
      zlib_inflate.inflateReset(strm);
      status = zlib_inflate.inflate(strm, _flush_mode);
    }

    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }

    // Remember real `avail_out` value, because we may patch out buffer content
    // to align utf8 strings boundaries.
    last_avail_out = strm.avail_out;

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {

        if (this.options.to === 'string') {

          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail & realign counters
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);

          this.onData(utf8str);

        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }

    // Must repeat iteration if out buffer is full
    if (status === Z_OK && last_avail_out === 0) continue;

    // Finalize if end of stream reached.
    if (status === Z_STREAM_END) {
      status = zlib_inflate.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|String): output data. When string output requested,
 *   each chunk will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako');
 * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));
 * let output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  const inflator = new Inflate(options);

  inflator.push(input);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) throw inflator.msg || msg[inflator.err];

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


module.exports.Inflate = Inflate;
module.exports.inflate = inflate;
module.exports.inflateRaw = inflateRaw;
module.exports.ungzip = inflate;
module.exports.constants = __webpack_require__(/*! ./zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");


/***/ }),

/***/ "./node_modules/pako/lib/utils/common.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/utils/common.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";



const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};

module.exports.assign = function (obj /*from1, from2, from3, ...*/) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// Join array of chunks to single array.
module.exports.flattenChunks = (chunks) => {
  // calculate data length
  let len = 0;

  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }

  // join chunks
  const result = new Uint8Array(len);

  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }

  return result;
};


/***/ }),

/***/ "./node_modules/pako/lib/utils/strings.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/utils/strings.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
// String encode/decode helpers



// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
let STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
module.exports.string2buf = (str) => {
  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new Uint8Array(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper
const buf2binstring = (buf, len) => {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }

  let result = '';
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};


// convert array to string
module.exports.buf2string = (buf, max) => {
  let i, out;
  const len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  const utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    let c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    let c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
module.exports.utf8border = (buf, max) => {

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/adler32.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/adler32.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";


// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const adler32 = (adler, buf, len, pos) => {
  let s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
};


module.exports = adler32;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/pako/lib/zlib/constants.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  Z_MEM_ERROR:       -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/crc32.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/crc32.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
const makeTable = () => {
  let c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
};

// Create table on load. Just 255 signed longs. Not a problem.
const crcTable = new Uint32Array(makeTable());


const crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;

  crc ^= -1;

  for (let i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
};


module.exports = crc32;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/deflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/deflate.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = __webpack_require__(/*! ./trees */ "./node_modules/pako/lib/zlib/trees.js");
const adler32 = __webpack_require__(/*! ./adler32 */ "./node_modules/pako/lib/zlib/adler32.js");
const crc32   = __webpack_require__(/*! ./crc32 */ "./node_modules/pako/lib/zlib/crc32.js");
const msg     = __webpack_require__(/*! ./messages */ "./node_modules/pako/lib/zlib/messages.js");

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_PARTIAL_FLUSH, Z_FULL_FLUSH, Z_FINISH, Z_BLOCK,
  Z_OK, Z_STREAM_END, Z_STREAM_ERROR, Z_DATA_ERROR, Z_BUF_ERROR,
  Z_DEFAULT_COMPRESSION,
  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY,
  Z_UNKNOWN,
  Z_DEFLATED
} = __webpack_require__(/*! ./constants */ "./node_modules/pako/lib/zlib/constants.js");

/*============================================================================*/


const MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
const MAX_WBITS = 15;
/* 32K LZ77 window */
const DEF_MEM_LEVEL = 8;


const LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
const LITERALS      = 256;
/* number of literal bytes 0..255 */
const L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
const D_CODES       = 30;
/* number of distance codes */
const BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
const HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
const MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

const PRESET_DICT = 0x20;

const INIT_STATE = 42;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;

const BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
const BS_BLOCK_DONE     = 2; /* block flush performed */
const BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
const BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

const OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

const err = (strm, errorCode) => {
  strm.msg = msg[errorCode];
  return errorCode;
};

const rank = (f) => {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
};

const zero = (buf) => {
  let len = buf.length; while (--len >= 0) { buf[len] = 0; }
};


/* eslint-disable new-cap */
let HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;
// This hash causes less collisions, https://github.com/nodeca/pako/issues/135
// But breaks binary compatibility
//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;
let HASH = HASH_ZLIB;

/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
const flush_pending = (strm) => {
  const s = strm.state;

  //_tr_flush_bits(s);
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};


const flush_block_only = (s, last) => {
  _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};


const put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
const putShortMSB = (s, b) => {

  //  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
};


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
const read_buf = (strm, buf, start, size) => {

  let len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
};


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
const longest_match = (s, cur_match) => {

  let chain_length = s.max_chain_length;      /* max hash chain length */
  let scan = s.strstart; /* current string */
  let match;                       /* matched string */
  let len;                           /* length of current match */
  let best_len = s.prev_length;              /* best match length so far */
  let nice_match = s.nice_match;             /* stop if match long enough */
  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  const _win = s.window; // shortcut

  const wmask = s.w_mask;
  const prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  const strend = s.strstart + MAX_MATCH;
  let scan_end1  = _win[scan + best_len - 1];
  let scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
const fill_window = (s) => {

  const _w_size = s.w_size;
  let p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;

      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;

      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    const curr = s.strstart + s.lookahead;
//    let init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
};

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
const deflate_stored = (s, flush) => {

  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  let max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    const max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
};

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
const deflate_fast = (s, flush) => {

  let hash_head;        /* head of the hash chain */
  let bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
const deflate_slow = (s, flush) => {

  let hash_head;          /* head of hash chain */
  let bflush;              /* set if current block must be flushed */

  let max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
};


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
const deflate_rle = (s, flush) => {

  let bflush;            /* set if current block must be flushed */
  let prev;              /* byte at distance one to match */
  let scan, strend;      /* scan goes up to strend for length of run */

  const _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
const deflate_huff = (s, flush) => {

  let bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {

  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
const lm_init = (s) => {

  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


const deflateResetKeep = (strm) => {

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  _tr_init(s);
  return Z_OK;
};


const deflateReset = (strm) => {

  const ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
};


const deflateSetHeader = (strm, head) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
};


const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {

  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  let wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  const s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new Uint8Array(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
};

const deflateInit = (strm, level) => {

  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
};


const deflate = (strm, flush) => {

  let beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  const s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  const old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      let header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      let level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    let bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        _tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
};


const deflateEnd = (strm) => {

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  const status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
};


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
const deflateSetDictionary = (strm, dictionary) => {

  let dictLength = dictionary.length;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  const s = strm.state;
  const wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
};


module.exports.deflateInit = deflateInit;
module.exports.deflateInit2 = deflateInit2;
module.exports.deflateReset = deflateReset;
module.exports.deflateResetKeep = deflateResetKeep;
module.exports.deflateSetHeader = deflateSetHeader;
module.exports.deflate = deflate;
module.exports.deflateEnd = deflateEnd;
module.exports.deflateSetDictionary = deflateSetDictionary;
module.exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
module.exports.deflateBound = deflateBound;
module.exports.deflateCopy = deflateCopy;
module.exports.deflateParams = deflateParams;
module.exports.deflatePending = deflatePending;
module.exports.deflatePrime = deflatePrime;
module.exports.deflateTune = deflateTune;
*/


/***/ }),

/***/ "./node_modules/pako/lib/zlib/gzheader.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/gzheader.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/inffast.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inffast.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
const BAD = 30;       /* got a data error -- remain here until reset */
const TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  let _in;                    /* local strm.input */
  let last;                   /* have enough input while in < last */
  let _out;                   /* local strm.output */
  let beg;                    /* inflate()'s initial strm.output */
  let end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  let dmax;                   /* maximum distance from zlib header */
//#endif
  let wsize;                  /* window size or zero if not using window */
  let whave;                  /* valid bytes in the window */
  let wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  let s_window;               /* allocated sliding window, if wsize != 0 */
  let hold;                   /* local strm.hold */
  let bits;                   /* local strm.bits */
  let lcode;                  /* local strm.lencode */
  let dcode;                  /* local strm.distcode */
  let lmask;                  /* mask for first level of length codes */
  let dmask;                  /* mask for first level of distance codes */
  let here;                   /* retrieved table entry */
  let op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  let len;                    /* match length, unused bytes */
  let dist;                   /* match distance */
  let from;                   /* where to copy match from */
  let from_source;


  let input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  const state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/inflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inflate.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const adler32       = __webpack_require__(/*! ./adler32 */ "./node_modules/pako/lib/zlib/adler32.js");
const crc32         = __webpack_require__(/*! ./crc32 */ "./node_modules/pako/lib/zlib/crc32.js");
const inflate_fast  = __webpack_require__(/*! ./inffast */ "./node_modules/pako/lib/zlib/inffast.js");
const inflate_table = __webpack_require__(/*! ./inftrees */ "./node_modules/pako/lib/zlib/inftrees.js");

const CODES = 0;
const LENS = 1;
const DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_FINISH, Z_BLOCK, Z_TREES,
  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR, Z_BUF_ERROR,
  Z_DEFLATED
} = __webpack_require__(/*! ./constants */ "./node_modules/pako/lib/zlib/constants.js");


/* STATES ====================================================================*/
/* ===========================================================================*/


const    HEAD = 1;       /* i: waiting for magic header */
const    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
const    TIME = 3;       /* i: waiting for modification time (gzip) */
const    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
const    EXLEN = 5;      /* i: waiting for extra length (gzip) */
const    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
const    NAME = 7;       /* i: waiting for end of file name (gzip) */
const    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
const    HCRC = 9;       /* i: waiting for header crc (gzip) */
const    DICTID = 10;    /* i: waiting for dictionary check value */
const    DICT = 11;      /* waiting for inflateSetDictionary() call */
const        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
const        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
const        STORED = 14;    /* i: waiting for stored size (length and complement) */
const        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
const        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
const        TABLE = 17;     /* i: waiting for dynamic block table lengths */
const        LENLENS = 18;   /* i: waiting for code length code lengths */
const        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
const            LEN_ = 20;      /* i: same as LEN below, but only first time in */
const            LEN = 21;       /* i: waiting for length/lit/eob code */
const            LENEXT = 22;    /* i: waiting for length extra bits */
const            DIST = 23;      /* i: waiting for distance code */
const            DISTEXT = 24;   /* i: waiting for distance extra bits */
const            MATCH = 25;     /* o: waiting for output space to copy string */
const            LIT = 26;       /* o: waiting for output space to write literal */
const    CHECK = 27;     /* i: waiting for 32-bit check value */
const    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
const    DONE = 29;      /* finished check, done -- remain here until reset */
const    BAD = 30;       /* got a data error -- remain here until reset */
const    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
const    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

const MAX_WBITS = 15;
/* 32K LZ77 window */
const DEF_WBITS = MAX_WBITS;


const zswap32 = (q) => {

  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
};


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new Uint16Array(320); /* temporary storage for code lengths */
  this.work = new Uint16Array(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}


const inflateResetKeep = (strm) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
};


const inflateReset = (strm) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

};


const inflateReset2 = (strm, windowBits) => {
  let wrap;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  const state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};


const inflateInit2 = (strm, windowBits) => {

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  const state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
};


const inflateInit = (strm) => {

  return inflateInit2(strm, DEF_WBITS);
};


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
let virgin = true;

let lenfix, distfix; // We have no pointers in JS, so keep tables separate


const fixedtables = (state) => {

  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);

    /* literal/length table */
    let sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
const updatewindow = (strm, src, end, copy) => {

  let dist;
  const state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new Uint8Array(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
};


const inflate = (strm, flush) => {

  let state;
  let input, output;          // input/output buffers
  let next;                   /* next input INDEX */
  let put;                    /* next output INDEX */
  let have, left;             /* available input and output */
  let hold;                   /* bit buffer */
  let bits;                   /* bits in bit buffer */
  let _in, _out;              /* save starting available input and output */
  let copy;                   /* number of stored or match bytes to copy */
  let from;                   /* where to copy match bytes from */
  let from_source;
  let here = 0;               /* current decoding table entry */
  let here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //let last;                   /* parent table entry */
  let last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  let len;                    /* length to copy for repeats, bits to drop */
  let ret;                    /* return code */
  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */
  let opts;

  let n; // temporary variable for NEED_BITS

  const order = /* permutation of code lengths */
    new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0;           /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }

        // !!! pako patch. Force use `options.windowBits` if passed.
        // Required to always use max window size by default.
        state.dmax = 1 << state.wbits;
        //state.dmax = 1 << len;

        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Uint8Array(state.head.extra_len);
              }
              state.head.extra.set(
                input.subarray(
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  next + copy
                ),
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          output.set(input.subarray(next, next + copy), put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inflate_fast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
                /*UPDATE(state.check, put - _out, _out);*/
                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};


const inflateEnd = (strm) => {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
};


const inflateGetHeader = (strm, head) => {

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  const state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
};


const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;

  let state;
  let dictid;
  let ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
};


module.exports.inflateReset = inflateReset;
module.exports.inflateReset2 = inflateReset2;
module.exports.inflateResetKeep = inflateResetKeep;
module.exports.inflateInit = inflateInit;
module.exports.inflateInit2 = inflateInit2;
module.exports.inflate = inflate;
module.exports.inflateEnd = inflateEnd;
module.exports.inflateGetHeader = inflateGetHeader;
module.exports.inflateSetDictionary = inflateSetDictionary;
module.exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
module.exports.inflateCopy = inflateCopy;
module.exports.inflateGetDictionary = inflateGetDictionary;
module.exports.inflateMark = inflateMark;
module.exports.inflatePrime = inflatePrime;
module.exports.inflateSync = inflateSync;
module.exports.inflateSyncPoint = inflateSyncPoint;
module.exports.inflateUndermine = inflateUndermine;
*/


/***/ }),

/***/ "./node_modules/pako/lib/zlib/inftrees.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/inftrees.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const MAXBITS = 15;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

const CODES = 0;
const LENS = 1;
const DISTS = 2;

const lbase = new Uint16Array([ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
]);

const lext = new Uint8Array([ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
]);

const dbase = new Uint16Array([ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
]);

const dext = new Uint8Array([ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
]);

const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>
{
  const bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  let len = 0;               /* a code's length in bits */
  let sym = 0;               /* index of code symbols */
  let min = 0, max = 0;          /* minimum and maximum code lengths */
  let root = 0;              /* number of index bits for root table */
  let curr = 0;              /* number of index bits for current table */
  let drop = 0;              /* code bits to drop for sub-table */
  let left = 0;                   /* number of prefix codes available */
  let used = 0;              /* code entries in table used */
  let huff = 0;              /* Huffman code */
  let incr;              /* for incrementing code, index */
  let fill;              /* index for replicating entries */
  let low;               /* low bits for current root entry */
  let mask;              /* mask for low root bits */
  let next;             /* next available space in table */
  let base = null;     /* base value table to use */
  let base_index = 0;
//  let shoextra;    /* extra bits table to use */
  let end;                    /* use base and extra for symbol > end */
  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  let extra = null;
  let extra_index = 0;

  let here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};


module.exports = inflate_table;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/messages.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/messages.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/trees.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/trees.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

/* Public constants ==========================================================*/
/* ===========================================================================*/


//const Z_FILTERED          = 1;
//const Z_HUFFMAN_ONLY      = 2;
//const Z_RLE               = 3;
const Z_FIXED               = 4;
//const Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
const Z_BINARY              = 0;
const Z_TEXT                = 1;
//const Z_ASCII             = 1; // = Z_TEXT
const Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES    = 2;
/* The three kinds of block type */

const MIN_MATCH    = 3;
const MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

const LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

const LITERALS      = 256;
/* number of literal bytes 0..255 */

const L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

const D_CODES       = 30;
/* number of distance codes */

const BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

const HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

const MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

const Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

const MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

const END_BLOCK   = 256;
/* end of block literal code */

const REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

const REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

const REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
const extra_lbits =   /* extra bits for each length code */
  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);

const extra_dbits =   /* extra bits for each distance code */
  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);

const extra_blbits =  /* extra bits for each bit length code */
  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);

const bl_order =
  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

const DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
const static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

const static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

const _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

const _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

const base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

const base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


let static_l_desc;
let static_d_desc;
let static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



const d_code = (dist) => {

  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
const put_short = (s, w) => {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
};


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
const send_bits = (s, value, length) => {

  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
};


const send_code = (s, c, tree) => {

  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
};


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
const bi_reverse = (code, len) => {

  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
const bi_flush = (s) => {

  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
const gen_bitlen = (s, desc) =>
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  const tree            = desc.dyn_tree;
  const max_code        = desc.max_code;
  const stree           = desc.stat_desc.static_tree;
  const has_stree       = desc.stat_desc.has_stree;
  const extra           = desc.stat_desc.extra_bits;
  const base            = desc.stat_desc.extra_base;
  const max_length      = desc.stat_desc.max_length;
  let h;              /* heap index */
  let n, m;           /* iterate over the tree elements */
  let bits;           /* bit length */
  let xbits;          /* extra bits */
  let f;              /* frequency */
  let overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
};


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
const gen_codes = (tree, max_code, bl_count) =>
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  const next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  let code = 0;              /* running code value */
  let bits;                  /* bit index */
  let n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    let len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
};


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
const tr_static_init = () => {

  let n;        /* iterates over tree elements */
  let bits;     /* bit counter */
  let length;   /* length value */
  let code;     /* code value */
  let dist;     /* distance index */
  const bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
};


/* ===========================================================================
 * Initialize a new block.
 */
const init_block = (s) => {

  let n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
};


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
const bi_windup = (s) =>
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
const copy_block = (s, buf, len, header) =>
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
  s.pending += len;
};

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
const smaller = (tree, n, m, depth) => {

  const _n2 = n * 2;
  const _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
};

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
const pqdownheap = (s, tree, k) =>
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  const v = s.heap[k];
  let j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
};


// inlined manually
// const SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
const compress_block = (s, ltree, dtree) =>
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  let dist;           /* distance of matched string */
  let lc;             /* match length or unmatched char (if dist == 0) */
  let lx = 0;         /* running index in l_buf */
  let code;           /* the code to send */
  let extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
};


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
const build_tree = (s, desc) =>
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  const tree     = desc.dyn_tree;
  const stree    = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems    = desc.stat_desc.elems;
  let n, m;          /* iterate over heap elements */
  let max_code = -1; /* largest code with non zero frequency */
  let node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
};


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
const scan_tree = (s, tree, max_code) =>
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
const send_tree = (s, tree, max_code) =>
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
const build_bl_tree = (s) => {

  let max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
};


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
const send_all_trees = (s, lcodes, dcodes, blcodes) =>
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  let rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
};


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
const detect_data_type = (s) => {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  let black_mask = 0xf3ffc07f;
  let n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
};


let static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
const _tr_init = (s) =>
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
};


/* ===========================================================================
 * Send a stored block
 */
const _tr_stored_block = (s, buf, stored_len, last) =>
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
};


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
const _tr_align = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
const _tr_flush_block = (s, buf, stored_len, last) =>
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  let max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
};

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
const _tr_tally = (s, dist, lc) =>
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //let out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
};

module.exports._tr_init  = _tr_init;
module.exports._tr_stored_block = _tr_stored_block;
module.exports._tr_flush_block  = _tr_flush_block;
module.exports._tr_tally = _tr_tally;
module.exports._tr_align = _tr_align;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/zstream.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/zstream.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;


/***/ }),

/***/ "./src/classes/HiFiAudioAPIData.ts":
/*!*****************************************!*\
  !*** ./src/classes/HiFiAudioAPIData.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReceivedHiFiAudioAPIData = exports.HiFiAudioAPIData = exports.OrientationQuat3D = exports.OrientationEuler3D = exports.Point3D = void 0;
const HiFiUtilities_1 = __webpack_require__(/*! ../utilities/HiFiUtilities */ "./src/utilities/HiFiUtilities.ts");
class Point3D {
    constructor({ x = null, y = null, z = null } = {}) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
}
exports.Point3D = Point3D;
class OrientationEuler3D {
    constructor({ pitchDegrees = 0, yawDegrees = 0, rollDegrees = 0 } = {}) {
        this.pitchDegrees = pitchDegrees;
        this.yawDegrees = yawDegrees;
        this.rollDegrees = rollDegrees;
    }
}
exports.OrientationEuler3D = OrientationEuler3D;
class OrientationQuat3D {
    constructor({ w = 1, x = 0, y = 0, z = 0 } = {}) {
        this.w = w;
        this.x = x;
        this.y = y;
        this.z = z;
    }
}
exports.OrientationQuat3D = OrientationQuat3D;
class HiFiAudioAPIData {
    constructor({ position = null, orientationEuler = null, orientationQuat = null, hiFiGain = null } = {}) {
        this.position = position;
        this.orientationQuat = orientationQuat;
        this.orientationEuler = orientationEuler;
        this.hiFiGain = hiFiGain;
    }
    diff(otherHiFiData) {
        let currentHiFiAudioAPIDataObj = {
            "position": Object.assign({}, this.position),
            "orientationEuler": Object.assign({}, this.orientationEuler),
            "orientationQuat": Object.assign({}, this.orientationQuat),
        };
        if (typeof (this.hiFiGain) === "number") {
            currentHiFiAudioAPIDataObj["hiFiGain"] = this.hiFiGain;
        }
        let otherHiFiDataObj = {
            "position": Object.assign({}, otherHiFiData.position),
            "orientationEuler": Object.assign({}, otherHiFiData.orientationEuler),
            "orientationQuat": Object.assign({}, otherHiFiData.orientationQuat),
        };
        if (typeof (otherHiFiData.hiFiGain) === "number") {
            otherHiFiDataObj["hiFiGain"] = otherHiFiData.hiFiGain;
        }
        let diffObject = HiFiUtilities_1.recursivelyDiffObjects(currentHiFiAudioAPIDataObj, otherHiFiDataObj);
        let returnValue = new HiFiAudioAPIData();
        if (diffObject.position && (typeof (diffObject.position.x) === "number" || typeof (diffObject.position.y) === "number" || typeof (diffObject.position.z) === "number")) {
            returnValue.position = new Point3D(otherHiFiData.position);
        }
        if (diffObject.orientationEuler && (typeof (diffObject.orientationEuler.pitchDegrees) === "number" || typeof (diffObject.orientationEuler.yawDegrees) === "number" || typeof (diffObject.orientationEuler.rollDegrees) === "number")) {
            returnValue.orientationEuler = new OrientationEuler3D(diffObject.orientationEuler);
        }
        if (diffObject.orientationQuat && (typeof (diffObject.orientationQuat.w) === "number" || typeof (diffObject.orientationQuat.x) === "number" || typeof (diffObject.orientationQuat.y) === "number" || typeof (diffObject.orientationQuat.z) === "number")) {
            returnValue.orientationQuat = new OrientationQuat3D(diffObject.orientationQuat);
        }
        if (typeof (diffObject.hiFiGain) === "number") {
            returnValue.hiFiGain = diffObject.hiFiGain;
        }
        return returnValue;
    }
}
exports.HiFiAudioAPIData = HiFiAudioAPIData;
class ReceivedHiFiAudioAPIData extends HiFiAudioAPIData {
    constructor(params = {}) {
        super(params);
        this.providedUserID = params.providedUserID;
        this.hashedVisitID = params.hashedVisitID;
        this.volumeDecibels = params.volumeDecibels;
    }
}
exports.ReceivedHiFiAudioAPIData = ReceivedHiFiAudioAPIData;


/***/ }),

/***/ "./src/classes/HiFiAxisConfiguration.ts":
/*!**********************************************!*\
  !*** ./src/classes/HiFiAxisConfiguration.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HiFiAxisUtilities = exports.ourHiFiAxisConfiguration = exports.HiFiAxisConfiguration = exports.HiFiHandedness = exports.HiFiAxes = void 0;
const HiFiLogger_1 = __webpack_require__(/*! ../utilities/HiFiLogger */ "./src/utilities/HiFiLogger.ts");
const HiFiAudioAPIData_1 = __webpack_require__(/*! ./HiFiAudioAPIData */ "./src/classes/HiFiAudioAPIData.ts");
var HiFiAxes;
(function (HiFiAxes) {
    HiFiAxes["PositiveX"] = "Positive X";
    HiFiAxes["NegativeX"] = "Negative X";
    HiFiAxes["PositiveY"] = "Positive Y";
    HiFiAxes["NegativeY"] = "Negative Y";
    HiFiAxes["PositiveZ"] = "Positive Z";
    HiFiAxes["NegativeZ"] = "Negative Z";
})(HiFiAxes = exports.HiFiAxes || (exports.HiFiAxes = {}));
var HiFiHandedness;
(function (HiFiHandedness) {
    HiFiHandedness["RightHand"] = "Right Hand";
    HiFiHandedness["LeftHand"] = "Left Hand";
})(HiFiHandedness = exports.HiFiHandedness || (exports.HiFiHandedness = {}));
class HiFiAxisConfiguration {
    constructor({ rightAxis, leftAxis, intoScreenAxis, outOfScreenAxis, upAxis, downAxis, handedness }) {
        Object.assign(this, { rightAxis, leftAxis, intoScreenAxis, outOfScreenAxis, upAxis, downAxis, handedness });
    }
}
exports.HiFiAxisConfiguration = HiFiAxisConfiguration;
exports.ourHiFiAxisConfiguration = new HiFiAxisConfiguration({
    rightAxis: HiFiAxes.PositiveX,
    leftAxis: HiFiAxes.NegativeX,
    intoScreenAxis: HiFiAxes.PositiveY,
    outOfScreenAxis: HiFiAxes.NegativeY,
    upAxis: HiFiAxes.PositiveZ,
    downAxis: HiFiAxes.NegativeZ,
    handedness: HiFiHandedness.RightHand,
});
class HiFiAxisUtilities {
    static verify(axisConfiguration) {
        let isValid = true;
        if (axisConfiguration.rightAxis === HiFiAxes.PositiveX && axisConfiguration.leftAxis !== HiFiAxes.NegativeX) {
            HiFiLogger_1.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.rightAxis}, and Left Axis is ${axisConfiguration.leftAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.leftAxis === HiFiAxes.PositiveX && axisConfiguration.rightAxis !== HiFiAxes.NegativeX) {
            HiFiLogger_1.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.rightAxis}, and Left Axis is ${axisConfiguration.leftAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.rightAxis === HiFiAxes.PositiveY && axisConfiguration.leftAxis !== HiFiAxes.NegativeY) {
            HiFiLogger_1.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.rightAxis}, and Left Axis is ${axisConfiguration.leftAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.leftAxis === HiFiAxes.PositiveY && axisConfiguration.rightAxis !== HiFiAxes.NegativeY) {
            HiFiLogger_1.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.rightAxis}, and Left Axis is ${axisConfiguration.leftAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.rightAxis === HiFiAxes.PositiveZ && axisConfiguration.leftAxis !== HiFiAxes.NegativeZ) {
            HiFiLogger_1.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.rightAxis}, and Left Axis is ${axisConfiguration.leftAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.leftAxis === HiFiAxes.PositiveZ && axisConfiguration.rightAxis !== HiFiAxes.NegativeZ) {
            HiFiLogger_1.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.rightAxis}, and Left Axis is ${axisConfiguration.leftAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.intoScreenAxis === HiFiAxes.PositiveX && axisConfiguration.outOfScreenAxis !== HiFiAxes.NegativeX) {
            HiFiLogger_1.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.intoScreenAxis}, and Left Axis is ${axisConfiguration.outOfScreenAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.outOfScreenAxis === HiFiAxes.PositiveX && axisConfiguration.intoScreenAxis !== HiFiAxes.NegativeX) {
            HiFiLogger_1.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.intoScreenAxis}, and Left Axis is ${axisConfiguration.outOfScreenAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.intoScreenAxis === HiFiAxes.PositiveY && axisConfiguration.outOfScreenAxis !== HiFiAxes.NegativeY) {
            HiFiLogger_1.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.intoScreenAxis}, and Left Axis is ${axisConfiguration.outOfScreenAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.outOfScreenAxis === HiFiAxes.PositiveY && axisConfiguration.intoScreenAxis !== HiFiAxes.NegativeY) {
            HiFiLogger_1.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.intoScreenAxis}, and Left Axis is ${axisConfiguration.outOfScreenAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.intoScreenAxis === HiFiAxes.PositiveZ && axisConfiguration.outOfScreenAxis !== HiFiAxes.NegativeZ) {
            HiFiLogger_1.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.intoScreenAxis}, and Left Axis is ${axisConfiguration.outOfScreenAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.outOfScreenAxis === HiFiAxes.PositiveZ && axisConfiguration.intoScreenAxis !== HiFiAxes.NegativeZ) {
            HiFiLogger_1.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.intoScreenAxis}, and Left Axis is ${axisConfiguration.outOfScreenAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.upAxis === HiFiAxes.PositiveX && axisConfiguration.downAxis !== HiFiAxes.NegativeX) {
            HiFiLogger_1.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.upAxis}, and Left Axis is ${axisConfiguration.downAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.downAxis === HiFiAxes.PositiveX && axisConfiguration.upAxis !== HiFiAxes.NegativeX) {
            HiFiLogger_1.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.upAxis}, and Left Axis is ${axisConfiguration.downAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.upAxis === HiFiAxes.PositiveY && axisConfiguration.downAxis !== HiFiAxes.NegativeY) {
            HiFiLogger_1.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.upAxis}, and Left Axis is ${axisConfiguration.downAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.downAxis === HiFiAxes.PositiveY && axisConfiguration.upAxis !== HiFiAxes.NegativeY) {
            HiFiLogger_1.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.upAxis}, and Left Axis is ${axisConfiguration.downAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.upAxis === HiFiAxes.PositiveZ && axisConfiguration.downAxis !== HiFiAxes.NegativeZ) {
            HiFiLogger_1.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.upAxis}, and Left Axis is ${axisConfiguration.downAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.downAxis === HiFiAxes.PositiveZ && axisConfiguration.upAxis !== HiFiAxes.NegativeZ) {
            HiFiLogger_1.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.upAxis}, and Left Axis is ${axisConfiguration.downAxis}!`);
            isValid = false;
        }
        if (!(axisConfiguration.handedness === HiFiHandedness.RightHand || axisConfiguration.handedness === HiFiHandedness.LeftHand)) {
            HiFiLogger_1.HiFiLogger.error(`Invalid axis configuration!\nHandedness is ${axisConfiguration.handedness}!`);
            isValid = false;
        }
        return isValid;
    }
    static translatePoint3DToMixerSpace(axisConfiguration, inputPoint3D) {
        let retval = new HiFiAudioAPIData_1.Point3D();
        let inputXIsNumber = typeof (inputPoint3D.x) === "number";
        let inputYIsNumber = typeof (inputPoint3D.y) === "number";
        let inputZIsNumber = typeof (inputPoint3D.z) === "number";
        if (axisConfiguration.rightAxis === HiFiAxes.PositiveX && inputXIsNumber) {
            retval.x = inputPoint3D.x;
        }
        else if (axisConfiguration.leftAxis === HiFiAxes.PositiveX && inputXIsNumber) {
            retval.x = -inputPoint3D.x;
        }
        else if (axisConfiguration.intoScreenAxis === HiFiAxes.PositiveX && inputYIsNumber) {
            retval.x = inputPoint3D.y;
        }
        else if (axisConfiguration.outOfScreenAxis === HiFiAxes.PositiveX && inputYIsNumber) {
            retval.x = -inputPoint3D.y;
        }
        else if (axisConfiguration.upAxis === HiFiAxes.PositiveX && inputZIsNumber) {
            retval.x = inputPoint3D.z;
        }
        else if (axisConfiguration.downAxis === HiFiAxes.PositiveX && inputZIsNumber) {
            retval.x = -inputPoint3D.z;
        }
        if (axisConfiguration.rightAxis === HiFiAxes.PositiveY && inputXIsNumber) {
            retval.y = inputPoint3D.x;
        }
        else if (axisConfiguration.leftAxis === HiFiAxes.PositiveY && inputXIsNumber) {
            retval.y = -inputPoint3D.x;
        }
        else if (axisConfiguration.intoScreenAxis === HiFiAxes.PositiveY && inputYIsNumber) {
            retval.y = inputPoint3D.y;
        }
        else if (axisConfiguration.outOfScreenAxis === HiFiAxes.PositiveY && inputYIsNumber) {
            retval.y = -inputPoint3D.y;
        }
        else if (axisConfiguration.upAxis === HiFiAxes.PositiveY && inputZIsNumber) {
            retval.y = inputPoint3D.z;
        }
        else if (axisConfiguration.downAxis === HiFiAxes.PositiveY && inputZIsNumber) {
            retval.y = -inputPoint3D.z;
        }
        if (axisConfiguration.rightAxis === HiFiAxes.PositiveZ && inputXIsNumber) {
            retval.z = inputPoint3D.x;
        }
        else if (axisConfiguration.leftAxis === HiFiAxes.PositiveZ && inputXIsNumber) {
            retval.z = -inputPoint3D.x;
        }
        else if (axisConfiguration.intoScreenAxis === HiFiAxes.PositiveZ && inputYIsNumber) {
            retval.z = inputPoint3D.y;
        }
        else if (axisConfiguration.outOfScreenAxis === HiFiAxes.PositiveZ && inputYIsNumber) {
            retval.z = -inputPoint3D.y;
        }
        else if (axisConfiguration.upAxis === HiFiAxes.PositiveZ && inputZIsNumber) {
            retval.z = inputPoint3D.z;
        }
        else if (axisConfiguration.downAxis === HiFiAxes.PositiveZ && inputZIsNumber) {
            retval.z = -inputPoint3D.z;
        }
        return retval;
    }
    static translateOrientationEuler3DToMixerSpace(axisConfiguration, inputOrientationEuler3D) {
        let retval = new HiFiAudioAPIData_1.OrientationEuler3D();
        if (typeof (inputOrientationEuler3D.pitchDegrees) !== "number") {
            inputOrientationEuler3D.pitchDegrees = 0;
        }
        if (typeof (inputOrientationEuler3D.yawDegrees) !== "number") {
            inputOrientationEuler3D.yawDegrees = 0;
        }
        if (typeof (inputOrientationEuler3D.rollDegrees) !== "number") {
            inputOrientationEuler3D.rollDegrees = 0;
        }
        if (axisConfiguration.handedness === HiFiHandedness.RightHand) {
            retval.pitchDegrees = inputOrientationEuler3D.pitchDegrees;
            retval.yawDegrees = inputOrientationEuler3D.yawDegrees;
            retval.rollDegrees = inputOrientationEuler3D.rollDegrees;
        }
        else if (axisConfiguration.handedness === HiFiHandedness.LeftHand) {
            retval.pitchDegrees = inputOrientationEuler3D.pitchDegrees;
            retval.yawDegrees = -inputOrientationEuler3D.yawDegrees;
            retval.rollDegrees = inputOrientationEuler3D.rollDegrees;
        }
        return retval;
    }
}
exports.HiFiAxisUtilities = HiFiAxisUtilities;


/***/ }),

/***/ "./src/classes/HiFiCommunicator.ts":
/*!*****************************************!*\
  !*** ./src/classes/HiFiCommunicator.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HiFiCommunicator = exports.HiFiUserDataStreamingScopes = exports.HiFiConnectionStates = void 0;
const HiFiConstants_1 = __webpack_require__(/*! ../constants/HiFiConstants */ "./src/constants/HiFiConstants.ts");
const HiFiLogger_1 = __webpack_require__(/*! ../utilities/HiFiLogger */ "./src/utilities/HiFiLogger.ts");
const HiFiAudioAPIData_1 = __webpack_require__(/*! ./HiFiAudioAPIData */ "./src/classes/HiFiAudioAPIData.ts");
const HiFiAxisConfiguration_1 = __webpack_require__(/*! ./HiFiAxisConfiguration */ "./src/classes/HiFiAxisConfiguration.ts");
const HiFiMixerSession_1 = __webpack_require__(/*! ./HiFiMixerSession */ "./src/classes/HiFiMixerSession.ts");
const HiFiUserDataSubscription_1 = __webpack_require__(/*! ./HiFiUserDataSubscription */ "./src/classes/HiFiUserDataSubscription.ts");
var HiFiConnectionStates;
(function (HiFiConnectionStates) {
    HiFiConnectionStates["Connected"] = "Connected";
    HiFiConnectionStates["Disconnected"] = "Disconnected";
    HiFiConnectionStates["Failed"] = "Failed";
    HiFiConnectionStates["Unavailable"] = "Unavailable";
})(HiFiConnectionStates = exports.HiFiConnectionStates || (exports.HiFiConnectionStates = {}));
;
var HiFiUserDataStreamingScopes;
(function (HiFiUserDataStreamingScopes) {
    HiFiUserDataStreamingScopes["None"] = "none";
    HiFiUserDataStreamingScopes["Peers"] = "peers";
    HiFiUserDataStreamingScopes["All"] = "all";
})(HiFiUserDataStreamingScopes = exports.HiFiUserDataStreamingScopes || (exports.HiFiUserDataStreamingScopes = {}));
;
class HiFiCommunicator {
    constructor({ initialHiFiAudioAPIData = new HiFiAudioAPIData_1.HiFiAudioAPIData(), onConnectionStateChanged, onUsersDisconnected, transmitRateLimitTimeoutMS = HiFiConstants_1.HiFiConstants.DEFAULT_TRANSMIT_RATE_LIMIT_TIMEOUT_MS, userDataStreamingScope = HiFiUserDataStreamingScopes.All, hiFiAxisConfiguration } = {}) {
        this._timers = {
            transmitRateLimitTimeout: null,
            wantedToTransmitHiFiAudioAPIData: true
        };
        if (transmitRateLimitTimeoutMS < HiFiConstants_1.HiFiConstants.MIN_TRANSMIT_RATE_LIMIT_TIMEOUT_MS) {
            HiFiLogger_1.HiFiLogger.warn(`\`transmitRateLimitTimeoutMS\` must be >= ${HiFiConstants_1.HiFiConstants.MIN_TRANSMIT_RATE_LIMIT_TIMEOUT_MS}ms! Setting to ${HiFiConstants_1.HiFiConstants.MIN_TRANSMIT_RATE_LIMIT_TIMEOUT_MS}ms...`);
            transmitRateLimitTimeoutMS = HiFiConstants_1.HiFiConstants.MIN_TRANSMIT_RATE_LIMIT_TIMEOUT_MS;
        }
        this.transmitRateLimitTimeoutMS = transmitRateLimitTimeoutMS;
        if (onUsersDisconnected) {
            this.onUsersDisconnected = onUsersDisconnected;
        }
        this._mixerSession = new HiFiMixerSession_1.HiFiMixerSession({
            "userDataStreamingScope": userDataStreamingScope,
            "onUserDataUpdated": (data) => { this._handleUserDataUpdates(data); },
            "onUsersDisconnected": (data) => { this._onUsersDisconnected(data); },
            "onConnectionStateChanged": onConnectionStateChanged
        });
        this._inputAudioMediaStream = undefined;
        this._currentHiFiAudioAPIData = initialHiFiAudioAPIData;
        this._lastTransmittedHiFiAudioAPIData = new HiFiAudioAPIData_1.HiFiAudioAPIData();
        this._userDataSubscriptions = [];
        if (hiFiAxisConfiguration) {
            if (HiFiAxisConfiguration_1.HiFiAxisUtilities.verify(hiFiAxisConfiguration)) {
                HiFiAxisConfiguration_1.ourHiFiAxisConfiguration.rightAxis = hiFiAxisConfiguration.rightAxis;
                HiFiAxisConfiguration_1.ourHiFiAxisConfiguration.leftAxis = hiFiAxisConfiguration.leftAxis;
                HiFiAxisConfiguration_1.ourHiFiAxisConfiguration.intoScreenAxis = hiFiAxisConfiguration.intoScreenAxis;
                HiFiAxisConfiguration_1.ourHiFiAxisConfiguration.outOfScreenAxis = hiFiAxisConfiguration.outOfScreenAxis;
                HiFiAxisConfiguration_1.ourHiFiAxisConfiguration.upAxis = hiFiAxisConfiguration.upAxis;
                HiFiAxisConfiguration_1.ourHiFiAxisConfiguration.downAxis = hiFiAxisConfiguration.downAxis;
                HiFiAxisConfiguration_1.ourHiFiAxisConfiguration.handedness = hiFiAxisConfiguration.handedness;
            }
            else {
                HiFiLogger_1.HiFiLogger.error(`There is an error with the passed \`HiFiAxisConfiguration\`, so the new axis configuration was not set. There are more error details in the logs above.`);
            }
        }
    }
    connectToHiFiAudioAPIServer(hifiAuthJWT, stackName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._mixerSession) {
                let errMsg = `\`this._mixerSession\` is falsey!`;
                return Promise.reject({
                    success: false,
                    error: errMsg
                });
            }
            let mixerConnectionResponse;
            try {
                let params = URLSearchParams && (typeof (location) !== 'undefined') && new URLSearchParams(location.search);
                if (params && params.has("token") && (!hifiAuthJWT || hifiAuthJWT.length === 0)) {
                    hifiAuthJWT = params.get("token");
                }
                if (!hifiAuthJWT || hifiAuthJWT.length === 0) {
                    let errMsg = `Can't connect to API Server: No JWT.\nSee this guide for information about obtaining a JWT:\nhttps://www.highfidelity.com/api/guides/misc/getAJWT`;
                    return Promise.reject({
                        success: false,
                        error: errMsg
                    });
                }
                let webRTCSignalingAddress = "wss://loadbalancer-$STACKNAME.highfidelity.io:8001/?token=";
                let isBrowserContext = typeof self !== 'undefined';
                if (params && params.has("stack")) {
                    let url;
                    try {
                        url = new URL(params.get("stack"));
                    }
                    catch (e) { }
                    if (url) {
                        webRTCSignalingAddress = url.href;
                    }
                    else {
                        webRTCSignalingAddress = webRTCSignalingAddress.replace('$STACKNAME', params.get("stack"));
                    }
                }
                else if (isBrowserContext && window.location.hostname.indexOf("highfidelity.io") > -1) {
                    webRTCSignalingAddress = `wss://${window.location.hostname}:8001/?token=`;
                }
                else if (isBrowserContext && "dev" && "dev" === "prod") {
                    webRTCSignalingAddress = `${HiFiConstants_1.HiFiConstants.DEFAULT_PROD_HIGH_FIDELITY_ENDPOINT}/?token=`;
                }
                else if (stackName) {
                    let url;
                    try {
                        url = new URL(stackName);
                    }
                    catch (e) { }
                    if (url) {
                        webRTCSignalingAddress = url.href;
                    }
                    else {
                        webRTCSignalingAddress = webRTCSignalingAddress.replace('$STACKNAME', stackName);
                    }
                }
                else if (!isBrowserContext) {
                    webRTCSignalingAddress = `${HiFiConstants_1.HiFiConstants.DEFAULT_PROD_HIGH_FIDELITY_ENDPOINT}/?token=`;
                }
                else {
                    webRTCSignalingAddress = webRTCSignalingAddress.replace('$STACKNAME', 'api-staging-02');
                }
                this._mixerSession.webRTCAddress = `${webRTCSignalingAddress}${hifiAuthJWT}`;
                HiFiLogger_1.HiFiLogger.log(`Using WebRTC Signaling Address:\n${webRTCSignalingAddress}<token redacted>`);
                mixerConnectionResponse = yield this._mixerSession.connect();
            }
            catch (errorConnectingToMixer) {
                let errMsg = `Error when connecting to mixer! Error:\n${errorConnectingToMixer}`;
                return Promise.reject({
                    success: false,
                    error: errMsg
                });
            }
            this._transmitHiFiAudioAPIDataToServer(true);
            return Promise.resolve({
                success: true,
                audionetInitResponse: mixerConnectionResponse.audionetInitResponse
            });
        });
    }
    disconnectFromHiFiAudioAPIServer() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._mixerSession) {
                return Promise.resolve(`No mixer session from which we can disconnect!`);
            }
            return this._mixerSession.disconnect();
        });
    }
    getOutputAudioMediaStream() {
        if (this._mixerSession) {
            return this._mixerSession.getOutputAudioMediaStream();
        }
        else {
            return null;
        }
    }
    setInputAudioMediaStream(newInputAudioMediaStream, isStereo = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const retval = yield this._mixerSession.setRAVIInputAudio(newInputAudioMediaStream, isStereo);
            if (retval) {
                this._inputAudioMediaStream = newInputAudioMediaStream;
            }
            else {
                HiFiLogger_1.HiFiLogger.warn(`Error trying to setRAVIInputAudio on this._mixerSession`);
            }
            return retval;
        });
    }
    setInputAudioMuted(isMuted) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._mixerSession) {
                HiFiLogger_1.HiFiLogger.debug(`Setting mute state to : ${isMuted}`);
                return yield this._mixerSession.setInputAudioMuted(isMuted);
            }
            else {
                HiFiLogger_1.HiFiLogger.warn(`Couldn't set mute state: No \`_mixerSession\`.`);
                return false;
            }
        });
    }
    getCommunicatorInfo() {
        let retval = {
            "clientInfo": {
                "inputAudioStreamSet": !!this._inputAudioMediaStream,
            }
        };
        let isBrowserContext = typeof self !== 'undefined';
        if (isBrowserContext && "v0.2.8") {
            retval.clientInfo["apiVersion"] = "v0.2.8";
        }
        if (this._mixerSession && this._mixerSession.mixerInfo) {
            retval["serverInfo"] = this._mixerSession.mixerInfo;
        }
        return retval;
    }
    startCollectingWebRTCStats(callback) {
        if (!this._mixerSession) {
            HiFiLogger_1.HiFiLogger.error(`Couldn't start collecting WebRTC Stats: No \`_mixerSession\`!`);
        }
        this._mixerSession.startCollectingWebRTCStats(callback);
    }
    stopCollectingWebRTCStats() {
        if (!this._mixerSession) {
            HiFiLogger_1.HiFiLogger.error(`Couldn't stop collecting WebRTC Stats: No \`_mixerSession\`!`);
        }
        this._mixerSession.stopCollectingWebRTCStats();
    }
    _updateUserData({ position, orientationEuler, orientationQuat, hiFiGain } = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        if (position) {
            if (!this._currentHiFiAudioAPIData.position) {
                this._currentHiFiAudioAPIData.position = new HiFiAudioAPIData_1.Point3D();
            }
            this._currentHiFiAudioAPIData.position.x = (_a = position.x) !== null && _a !== void 0 ? _a : this._currentHiFiAudioAPIData.position.x;
            this._currentHiFiAudioAPIData.position.y = (_b = position.y) !== null && _b !== void 0 ? _b : this._currentHiFiAudioAPIData.position.y;
            this._currentHiFiAudioAPIData.position.z = (_c = position.z) !== null && _c !== void 0 ? _c : this._currentHiFiAudioAPIData.position.z;
        }
        if (orientationEuler) {
            if (!this._currentHiFiAudioAPIData.orientationEuler) {
                this._currentHiFiAudioAPIData.orientationEuler = new HiFiAudioAPIData_1.OrientationEuler3D();
            }
            this._currentHiFiAudioAPIData.orientationEuler.pitchDegrees = (_d = orientationEuler.pitchDegrees) !== null && _d !== void 0 ? _d : this._currentHiFiAudioAPIData.orientationEuler.pitchDegrees;
            this._currentHiFiAudioAPIData.orientationEuler.yawDegrees = (_e = orientationEuler.yawDegrees) !== null && _e !== void 0 ? _e : this._currentHiFiAudioAPIData.orientationEuler.yawDegrees;
            this._currentHiFiAudioAPIData.orientationEuler.rollDegrees = (_f = orientationEuler.rollDegrees) !== null && _f !== void 0 ? _f : this._currentHiFiAudioAPIData.orientationEuler.rollDegrees;
        }
        if (orientationQuat) {
            if (this._currentHiFiAudioAPIData.orientationQuat) {
                this._currentHiFiAudioAPIData.orientationQuat.w = (_g = orientationQuat.w) !== null && _g !== void 0 ? _g : this._currentHiFiAudioAPIData.orientationQuat.w;
                this._currentHiFiAudioAPIData.orientationQuat.x = (_h = orientationQuat.x) !== null && _h !== void 0 ? _h : this._currentHiFiAudioAPIData.orientationQuat.x;
                this._currentHiFiAudioAPIData.orientationQuat.y = (_j = orientationQuat.y) !== null && _j !== void 0 ? _j : this._currentHiFiAudioAPIData.orientationQuat.y;
                this._currentHiFiAudioAPIData.orientationQuat.z = (_k = orientationQuat.z) !== null && _k !== void 0 ? _k : this._currentHiFiAudioAPIData.orientationQuat.z;
            }
            else {
                this._currentHiFiAudioAPIData.orientationQuat = new HiFiAudioAPIData_1.OrientationQuat3D({
                    "w": orientationQuat.w,
                    "x": orientationQuat.x,
                    "y": orientationQuat.y,
                    "z": orientationQuat.z,
                });
            }
        }
        if (typeof (hiFiGain) === "number") {
            this._currentHiFiAudioAPIData.hiFiGain = Math.max(0, hiFiGain);
        }
    }
    _maybeClearRateLimitTimeout() {
        if (this._timers.transmitRateLimitTimeout) {
            clearTimeout(this._timers.transmitRateLimitTimeout);
        }
        this._timers.transmitRateLimitTimeout = null;
    }
    _updateLastTransmittedHiFiAudioAPIData(dataJustTransmitted) {
        var _a, _b, _c, _d, _e, _f;
        if (dataJustTransmitted.position) {
            if (!this._lastTransmittedHiFiAudioAPIData.position) {
                this._lastTransmittedHiFiAudioAPIData.position = new HiFiAudioAPIData_1.Point3D();
            }
            this._lastTransmittedHiFiAudioAPIData.position.x = (_a = dataJustTransmitted.position.x) !== null && _a !== void 0 ? _a : this._lastTransmittedHiFiAudioAPIData.position.x;
            this._lastTransmittedHiFiAudioAPIData.position.y = (_b = dataJustTransmitted.position.y) !== null && _b !== void 0 ? _b : this._lastTransmittedHiFiAudioAPIData.position.y;
            this._lastTransmittedHiFiAudioAPIData.position.z = (_c = dataJustTransmitted.position.z) !== null && _c !== void 0 ? _c : this._lastTransmittedHiFiAudioAPIData.position.z;
        }
        if (dataJustTransmitted.orientationEuler) {
            if (!this._lastTransmittedHiFiAudioAPIData.orientationEuler) {
                this._lastTransmittedHiFiAudioAPIData.orientationEuler = new HiFiAudioAPIData_1.OrientationEuler3D();
            }
            this._lastTransmittedHiFiAudioAPIData.orientationEuler.pitchDegrees = (_d = dataJustTransmitted.orientationEuler.pitchDegrees) !== null && _d !== void 0 ? _d : this._lastTransmittedHiFiAudioAPIData.orientationEuler.pitchDegrees;
            this._lastTransmittedHiFiAudioAPIData.orientationEuler.yawDegrees = (_e = dataJustTransmitted.orientationEuler.yawDegrees) !== null && _e !== void 0 ? _e : this._lastTransmittedHiFiAudioAPIData.orientationEuler.yawDegrees;
            this._lastTransmittedHiFiAudioAPIData.orientationEuler.rollDegrees = (_f = dataJustTransmitted.orientationEuler.rollDegrees) !== null && _f !== void 0 ? _f : this._lastTransmittedHiFiAudioAPIData.orientationEuler.rollDegrees;
        }
        if (dataJustTransmitted.orientationQuat) {
            if (!this._lastTransmittedHiFiAudioAPIData.orientationQuat) {
                this._lastTransmittedHiFiAudioAPIData.orientationQuat = new HiFiAudioAPIData_1.OrientationQuat3D({
                    "w": dataJustTransmitted.orientationQuat.w,
                    "x": dataJustTransmitted.orientationQuat.x,
                    "y": dataJustTransmitted.orientationQuat.y,
                    "z": dataJustTransmitted.orientationQuat.z,
                });
            }
            else {
                this._lastTransmittedHiFiAudioAPIData.orientationQuat.w = dataJustTransmitted.orientationQuat.w;
                this._lastTransmittedHiFiAudioAPIData.orientationQuat.x = dataJustTransmitted.orientationQuat.x;
                this._lastTransmittedHiFiAudioAPIData.orientationQuat.y = dataJustTransmitted.orientationQuat.y;
                this._lastTransmittedHiFiAudioAPIData.orientationQuat.z = dataJustTransmitted.orientationQuat.z;
            }
        }
        if (typeof (dataJustTransmitted.hiFiGain) === "number") {
            this._lastTransmittedHiFiAudioAPIData["hiFiGain"] = dataJustTransmitted.hiFiGain;
        }
    }
    _transmitHiFiAudioAPIDataToServer(forceTransmit) {
        if (this._mixerSession && (!this._timers.transmitRateLimitTimeout || forceTransmit)) {
            this._timers.wantedToTransmitHiFiAudioAPIData = false;
            this._maybeClearRateLimitTimeout();
            if (!forceTransmit) {
                this._timers.transmitRateLimitTimeout = setTimeout(() => {
                    this._maybeClearRateLimitTimeout();
                    if (this._timers.wantedToTransmitHiFiAudioAPIData) {
                        this._transmitHiFiAudioAPIDataToServer(true);
                    }
                }, this.transmitRateLimitTimeoutMS);
            }
            let delta = this._lastTransmittedHiFiAudioAPIData.diff(this._currentHiFiAudioAPIData);
            let transmitRetval = this._mixerSession._transmitHiFiAudioAPIDataToServer(delta);
            if (transmitRetval.success) {
                this._updateLastTransmittedHiFiAudioAPIData(delta);
                return {
                    success: true,
                    rawDataTransmitted: transmitRetval.stringifiedDataForMixer
                };
            }
            else {
                return {
                    success: false,
                    error: transmitRetval.error
                };
            }
        }
        else if (this._mixerSession && this._timers.transmitRateLimitTimeout && !forceTransmit) {
            this._timers.wantedToTransmitHiFiAudioAPIData = true;
            return {
                success: true,
                error: `Transfer is rate limited. Transfer will occur shortly automatically.`
            };
        }
        else if (!this._mixerSession) {
            return {
                success: false,
                error: `No server connection yet; can't transmit user data.`
            };
        }
    }
    updateUserDataAndTransmit(newUserData) {
        this._updateUserData(newUserData);
        return this._transmitHiFiAudioAPIDataToServer();
    }
    _handleUserDataUpdates(newUserDataFromServer) {
        if (this._userDataSubscriptions.length === 0) {
            return;
        }
        for (let subItr = 0; subItr < this._userDataSubscriptions.length; subItr++) {
            let currentSubscription = this._userDataSubscriptions[subItr];
            if (!currentSubscription.callback) {
                continue;
            }
            let currentSubscriptionCallbackData = [];
            for (let dataItr = 0; dataItr < newUserDataFromServer.length; dataItr++) {
                let currentDataFromServer = newUserDataFromServer[dataItr];
                if (currentSubscription.providedUserID && currentDataFromServer.providedUserID !== currentSubscription.providedUserID) {
                    continue;
                }
                let newCallbackData = new HiFiAudioAPIData_1.ReceivedHiFiAudioAPIData();
                if (typeof (currentDataFromServer.providedUserID) === "string") {
                    newCallbackData.providedUserID = currentDataFromServer.providedUserID;
                }
                if (typeof (currentDataFromServer.hashedVisitID) === "string") {
                    newCallbackData.hashedVisitID = currentDataFromServer.hashedVisitID;
                }
                let shouldPushNewCallbackData = false;
                for (let componentItr = 0; componentItr < currentSubscription.components.length; componentItr++) {
                    let currentComponent = currentSubscription.components[componentItr];
                    switch (currentComponent) {
                        case HiFiUserDataSubscription_1.AvailableUserDataSubscriptionComponents.Position:
                            if (currentDataFromServer.position) {
                                newCallbackData.position = currentDataFromServer.position;
                                shouldPushNewCallbackData = true;
                            }
                            break;
                        case HiFiUserDataSubscription_1.AvailableUserDataSubscriptionComponents.OrientationEuler:
                            if (currentDataFromServer.orientationEuler) {
                                newCallbackData.orientationEuler = currentDataFromServer.orientationEuler;
                                shouldPushNewCallbackData = true;
                            }
                            break;
                        case HiFiUserDataSubscription_1.AvailableUserDataSubscriptionComponents.OrientationQuat:
                            if (currentDataFromServer.orientationQuat) {
                                newCallbackData.orientationQuat = currentDataFromServer.orientationQuat;
                                shouldPushNewCallbackData = true;
                            }
                            break;
                        case HiFiUserDataSubscription_1.AvailableUserDataSubscriptionComponents.VolumeDecibels:
                            if (typeof (currentDataFromServer.volumeDecibels) === "number") {
                                newCallbackData.volumeDecibels = currentDataFromServer.volumeDecibels;
                                shouldPushNewCallbackData = true;
                            }
                            break;
                        case HiFiUserDataSubscription_1.AvailableUserDataSubscriptionComponents.HiFiGain:
                            if (typeof (currentDataFromServer.hiFiGain) === "number") {
                                newCallbackData.hiFiGain = currentDataFromServer.hiFiGain;
                                shouldPushNewCallbackData = true;
                            }
                            break;
                    }
                }
                if (shouldPushNewCallbackData) {
                    currentSubscriptionCallbackData.push(newCallbackData);
                }
            }
            if (currentSubscription.callback && currentSubscriptionCallbackData.length > 0) {
                currentSubscription.callback(currentSubscriptionCallbackData);
            }
        }
    }
    _onUsersDisconnected(usersDisconnected) {
        if (this.onUsersDisconnected) {
            this.onUsersDisconnected(usersDisconnected);
        }
    }
    addUserDataSubscription(newSubscription) {
        if (!this._mixerSession) {
            HiFiLogger_1.HiFiLogger.error(`No \`_mixerSession\`! Data subscription not added.`);
            return;
        }
        if (this._mixerSession.userDataStreamingScope === HiFiUserDataStreamingScopes.None) {
            HiFiLogger_1.HiFiLogger.error(`During \`HiFiCommunicator\` construction, the server was set up to **not** send user data! Data subscription not added.`);
            return;
        }
        HiFiLogger_1.HiFiLogger.log(`Adding new User Data Subscription:\n${JSON.stringify(newSubscription)}`);
        this._userDataSubscriptions.push(newSubscription);
    }
}
exports.HiFiCommunicator = HiFiCommunicator;


/***/ }),

/***/ "./src/classes/HiFiMixerSession.ts":
/*!*****************************************!*\
  !*** ./src/classes/HiFiMixerSession.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HiFiMixerSession = void 0;
const HiFiAudioAPIData_1 = __webpack_require__(/*! ./HiFiAudioAPIData */ "./src/classes/HiFiAudioAPIData.ts");
const HiFiLogger_1 = __webpack_require__(/*! ../utilities/HiFiLogger */ "./src/utilities/HiFiLogger.ts");
const HiFiCommunicator_1 = __webpack_require__(/*! ./HiFiCommunicator */ "./src/classes/HiFiCommunicator.ts");
const RaviUtils_1 = __webpack_require__(/*! ../libravi/RaviUtils */ "./src/libravi/RaviUtils.ts");
const RaviSession_1 = __webpack_require__(/*! ../libravi/RaviSession */ "./src/libravi/RaviSession.ts");
const RaviSignalingConnection_1 = __webpack_require__(/*! ../libravi/RaviSignalingConnection */ "./src/libravi/RaviSignalingConnection.ts");
const HiFiAxisConfiguration_1 = __webpack_require__(/*! ./HiFiAxisConfiguration */ "./src/classes/HiFiAxisConfiguration.ts");
const pako = __webpack_require__(/*! pako */ "./node_modules/pako/index.js");
const INIT_TIMEOUT_MS = 5000;
class HiFiMixerSession {
    constructor({ userDataStreamingScope = HiFiCommunicator_1.HiFiUserDataStreamingScopes.All, onUserDataUpdated, onUsersDisconnected, onConnectionStateChanged }) {
        this.webRTCAddress = undefined;
        this.userDataStreamingScope = userDataStreamingScope;
        this.onUserDataUpdated = onUserDataUpdated;
        this.onUsersDisconnected = onUsersDisconnected;
        this._mixerPeerKeyToProvidedUserIDDict = {};
        this._mixerPeerKeyToHashedVisitIDDict = {};
        RaviUtils_1.RaviUtils.setDebug(false);
        this._raviSignalingConnection = new RaviSignalingConnection_1.RaviSignalingConnection();
        this._raviSignalingConnection.addStateChangeHandler((event) => {
            this.onRAVISignalingStateChanged(event);
        });
        this._raviSession = new RaviSession_1.RaviSession();
        this._raviSession.addStateChangeHandler((event) => {
            this.onRAVISessionStateChanged(event);
        });
        this.onConnectionStateChanged = onConnectionStateChanged;
        this._resetMixerInfo();
    }
    promiseToRunAudioInit() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                let initData = {
                    primary: true,
                    visit_id: this._raviSession.getUUID(),
                    session: this._raviSession.getUUID(),
                    streaming_scope: this.userDataStreamingScope,
                    is_input_stream_stereo: this._inputAudioMediaStreamIsStereo
                };
                let commandController = this._raviSession.getCommandController();
                if (!commandController) {
                    return Promise.reject({
                        success: false,
                        error: `Couldn't connect to mixer: no \`commandController\`!`
                    });
                }
                let initTimeout = setTimeout(() => {
                    this.disconnect();
                    return Promise.reject({
                        success: false,
                        error: `Couldn't connect to mixer: Call to \`init\` timed out!`
                    });
                }, INIT_TIMEOUT_MS);
                commandController.queueCommand("audionet.init", initData, (response) => __awaiter(this, void 0, void 0, function* () {
                    clearTimeout(initTimeout);
                    let parsedResponse;
                    try {
                        parsedResponse = JSON.parse(response);
                        this.mixerInfo["connected"] = true;
                        this.mixerInfo["build_number"] = parsedResponse.build_number;
                        this.mixerInfo["build_type"] = parsedResponse.build_type;
                        this.mixerInfo["build_version"] = parsedResponse.build_version;
                        this.mixerInfo["visit_id_hash"] = parsedResponse.visit_id_hash;
                        parsedResponse["unhashedVisitID"] = this._raviSession.getUUID();
                        resolve({
                            success: true,
                            audionetInitResponse: parsedResponse
                        });
                    }
                    catch (e) {
                        reject({
                            success: false,
                            error: `Couldn't parse init response! Parse error:\n${e}`
                        });
                    }
                }));
            });
        });
    }
    handleRAVISessionBinaryData(data) {
        let unGZippedData = pako.ungzip(data, { to: 'string' });
        let jsonData = JSON.parse(unGZippedData);
        if (jsonData.deleted_visit_ids) {
            let allDeletedUserData = [];
            let deletedVisitIDs = jsonData.deleted_visit_ids;
            for (const deletedVisitID of deletedVisitIDs) {
                let hashedVisitID = deletedVisitID;
                let deletedUserData = new HiFiAudioAPIData_1.ReceivedHiFiAudioAPIData({
                    hashedVisitID: hashedVisitID
                });
                let mixerPeerKeys = Object.keys(this._mixerPeerKeyToHashedVisitIDDict);
                for (const mixerPeerKey of mixerPeerKeys) {
                    if (this._mixerPeerKeyToHashedVisitIDDict[mixerPeerKey] === hashedVisitID) {
                        if (this._mixerPeerKeyToProvidedUserIDDict[mixerPeerKey]) {
                            deletedUserData.providedUserID = this._mixerPeerKeyToProvidedUserIDDict[mixerPeerKey];
                        }
                        break;
                    }
                }
                allDeletedUserData.push(deletedUserData);
            }
            if (this.onUsersDisconnected && allDeletedUserData.length > 0) {
                this.onUsersDisconnected(allDeletedUserData);
            }
        }
        if (jsonData.peers) {
            let allNewUserData = [];
            let peerKeys = Object.keys(jsonData.peers);
            for (let itr = 0; itr < peerKeys.length; itr++) {
                let peerDataFromMixer = jsonData.peers[peerKeys[itr]];
                let newUserData = new HiFiAudioAPIData_1.ReceivedHiFiAudioAPIData();
                if (this._mixerPeerKeyToProvidedUserIDDict[peerKeys[itr]]) {
                    newUserData.providedUserID = this._mixerPeerKeyToProvidedUserIDDict[peerKeys[itr]];
                }
                else if (typeof (peerDataFromMixer.J) === "string") {
                    newUserData.providedUserID = peerDataFromMixer.J;
                    this._mixerPeerKeyToProvidedUserIDDict[peerKeys[itr]] = newUserData.providedUserID;
                }
                if (this._mixerPeerKeyToHashedVisitIDDict[peerKeys[itr]]) {
                    newUserData.hashedVisitID = this._mixerPeerKeyToHashedVisitIDDict[peerKeys[itr]];
                }
                else if (typeof (peerDataFromMixer.e) === "string") {
                    newUserData.hashedVisitID = peerDataFromMixer.e;
                    this._mixerPeerKeyToHashedVisitIDDict[peerKeys[itr]] = newUserData.hashedVisitID;
                }
                let serverSentNewUserData = false;
                if (typeof (peerDataFromMixer.x) === "number") {
                    if (!newUserData.position) {
                        newUserData.position = new HiFiAudioAPIData_1.Point3D();
                    }
                    newUserData.position.x = peerDataFromMixer.x / 1000;
                    serverSentNewUserData = true;
                }
                if (typeof (peerDataFromMixer.y) === "number") {
                    if (!newUserData.position) {
                        newUserData.position = new HiFiAudioAPIData_1.Point3D();
                    }
                    newUserData.position.y = peerDataFromMixer.y / 1000;
                    serverSentNewUserData = true;
                }
                if (typeof (peerDataFromMixer.z) === "number") {
                    if (!newUserData.position) {
                        newUserData.position = new HiFiAudioAPIData_1.Point3D();
                    }
                    newUserData.position.z = peerDataFromMixer.z / 1000;
                    serverSentNewUserData = true;
                }
                if (typeof (peerDataFromMixer.k) === "number") {
                    if (!newUserData.orientationEuler) {
                        newUserData.orientationEuler = new HiFiAudioAPIData_1.OrientationEuler3D();
                    }
                    newUserData.orientationEuler.pitchDegrees = peerDataFromMixer.k;
                    serverSentNewUserData = true;
                }
                if (typeof (peerDataFromMixer.o) === "number") {
                    if (!newUserData.orientationEuler) {
                        newUserData.orientationEuler = new HiFiAudioAPIData_1.OrientationEuler3D();
                    }
                    newUserData.orientationEuler.yawDegrees = peerDataFromMixer.o;
                    serverSentNewUserData = true;
                }
                if (typeof (peerDataFromMixer.l) === "number") {
                    if (!newUserData.orientationEuler) {
                        newUserData.orientationEuler = new HiFiAudioAPIData_1.OrientationEuler3D();
                    }
                    newUserData.orientationEuler.rollDegrees = peerDataFromMixer.l;
                    serverSentNewUserData = true;
                }
                if (typeof (peerDataFromMixer.W) === "number" && typeof (peerDataFromMixer.X) === "number" && typeof (peerDataFromMixer.Y) === "number" && typeof (peerDataFromMixer.Z) === "number") {
                    newUserData.orientationQuat = new HiFiAudioAPIData_1.OrientationQuat3D({
                        w: peerDataFromMixer.W / 1000,
                        x: peerDataFromMixer.X / 1000,
                        y: peerDataFromMixer.Y / 1000,
                        z: peerDataFromMixer.Z / 1000
                    });
                    serverSentNewUserData = true;
                }
                if (typeof (peerDataFromMixer.g) === "number") {
                    newUserData.hiFiGain = peerDataFromMixer.g;
                    serverSentNewUserData = true;
                }
                if (typeof (peerDataFromMixer.v) === "number") {
                    newUserData.volumeDecibels = peerDataFromMixer.v;
                    serverSentNewUserData = true;
                }
                if (serverSentNewUserData) {
                    allNewUserData.push(newUserData);
                }
            }
            if (this.onUserDataUpdated && allNewUserData.length > 0) {
                this.onUserDataUpdated(allNewUserData);
            }
        }
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.webRTCAddress) {
                let errMsg = `Couldn't connect: \`this.webRTCAddress\` is falsey!`;
                this.disconnect();
                return Promise.reject(errMsg);
            }
            this._currentHiFiConnectionState = undefined;
            try {
                yield this._raviSignalingConnection.open(this.webRTCAddress);
            }
            catch (errorOpeningSignalingConnection) {
                let errMsg = `Couldn't open signaling connection to \`${this.webRTCAddress.slice(0, this.webRTCAddress.indexOf("token="))}<token redacted>\`! Error:\n${errorOpeningSignalingConnection}`;
                this.disconnect();
                return Promise.reject(errMsg);
            }
            try {
                yield this._raviSession.open(this._raviSignalingConnection);
            }
            catch (errorOpeningRAVISession) {
                let errMsg = `Couldn't open RAVI session associated with \`${this.webRTCAddress.slice(0, this.webRTCAddress.indexOf("token="))}<token redacted>\`! Error:\n${errorOpeningRAVISession}`;
                this.disconnect();
                return Promise.reject(errMsg);
            }
            let audionetInitResponse;
            try {
                audionetInitResponse = yield this.promiseToRunAudioInit();
            }
            catch (initError) {
                let errMsg = `\`audionet.init\` command failed! Error:\n${initError.error}`;
                this.disconnect();
                return Promise.reject(errMsg);
            }
            this._raviSession.getCommandController().addBinaryHandler((data) => { this.handleRAVISessionBinaryData(data); }, true);
            return Promise.resolve(audionetInitResponse);
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            function close(thingToClose, nameOfThingToClose, closedState) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (thingToClose) {
                        let state = thingToClose.getState();
                        if (!thingToClose || state === closedState) {
                            HiFiLogger_1.HiFiLogger.log(`The RAVI ${nameOfThingToClose} was already closed.`);
                        }
                        else {
                            try {
                                yield thingToClose.close();
                                HiFiLogger_1.HiFiLogger.log(`The RAVI ${nameOfThingToClose} closed successfully from state ${state}.`);
                            }
                            catch (e) {
                                HiFiLogger_1.HiFiLogger.warn(`The RAVI ${nameOfThingToClose} didn't close successfully from state ${state}! Error:\n${e}`);
                            }
                        }
                    }
                    else {
                        HiFiLogger_1.HiFiLogger.warn(`The RAVI ${nameOfThingToClose} was missing.`);
                    }
                    thingToClose = null;
                });
            }
            yield close(this._raviSignalingConnection, "Signaling Connection", RaviSignalingConnection_1.SignalingStates.CLOSED);
            yield close(this._raviSession, "Session", RaviSession_1.RaviSessionStates.CLOSED);
            this._resetMixerInfo();
            return Promise.resolve(`Successfully disconnected.`);
        });
    }
    setRAVIInputAudio(inputAudioMediaStream, isStereo = false) {
        return __awaiter(this, void 0, void 0, function* () {
            let retval = false;
            if (this._raviSession) {
                let streamController = this._raviSession.getStreamController();
                if (!streamController) {
                    HiFiLogger_1.HiFiLogger.warn(`Couldn't set input audio on _raviSession.streamController: No \`streamController\`!`);
                    retval = false;
                }
                else {
                    streamController.setInputAudio(inputAudioMediaStream, isStereo);
                    HiFiLogger_1.HiFiLogger.log(`Successfully set input audio on _raviSession.streamController!`);
                    retval = true;
                }
            }
            else {
                HiFiLogger_1.HiFiLogger.warn(`Couldn't set input audio on _raviSession.streamController: No \`_raviSession\`!`);
                retval = false;
            }
            if (retval) {
                if (this._inputAudioMediaStreamIsStereo != isStereo) {
                    if (this._raviSession.getState() === RaviSession_1.RaviSessionStates.CONNECTED) {
                        HiFiLogger_1.HiFiLogger.warn(`Stereo status has changed from ${this._inputAudioMediaStreamIsStereo} to ${isStereo}; attempting to re-initialize with the mixer`);
                        let audionetInitResponse;
                        try {
                            this._inputAudioMediaStreamIsStereo = isStereo;
                            audionetInitResponse = yield this.promiseToRunAudioInit();
                        }
                        catch (initError) {
                            let errMsg = `Attempt to call \`audionet.init\` for change in stereo status failed! Error:\n${initError.error}`;
                            return Promise.reject(errMsg);
                        }
                    }
                    else {
                        this._inputAudioMediaStreamIsStereo = isStereo;
                    }
                }
            }
            return retval;
        });
    }
    setInputAudioMuted(newMutedValue) {
        return __awaiter(this, void 0, void 0, function* () {
            let streamController = this._raviSession.getStreamController();
            if (this._raviSession && streamController) {
                let hasMicPermission = false;
                if (navigator.permissions && navigator.permissions.query) {
                    let result = yield navigator.permissions.query({ name: 'microphone' });
                    if (result.state === "granted") {
                        hasMicPermission = true;
                    }
                }
                if (!hasMicPermission || typeof self === 'undefined') {
                    let raviAudioStream = streamController._inputAudioStream;
                    if (raviAudioStream) {
                        raviAudioStream.getTracks().forEach((track) => {
                            track.enabled = !newMutedValue;
                        });
                        HiFiLogger_1.HiFiLogger.log(`Successfully set mute state to ${newMutedValue} on _raviSession.streamController._inputAudioStream`);
                        return true;
                    }
                    else {
                        HiFiLogger_1.HiFiLogger.warn(`Couldn't set mute state: No \`_inputAudioStream\` on \`_raviSession.streamController\`.`);
                    }
                }
                else {
                    let raviAudioStream = streamController._inputAudioStream;
                    if (raviAudioStream && newMutedValue) {
                        raviAudioStream.getTracks().forEach((track) => {
                            this._cachedMediaTrackConstraints = track.getConstraints();
                            track.stop();
                        });
                        streamController.setInputAudio(null);
                        HiFiLogger_1.HiFiLogger.log(`Successfully set mute state to \`true\` by stopping all input media tracks!`);
                        return true;
                    }
                    else if (!raviAudioStream && !newMutedValue) {
                        let newMediaStream = yield navigator.mediaDevices.getUserMedia({ audio: this._cachedMediaTrackConstraints, video: false });
                        streamController.setInputAudio(newMediaStream);
                        HiFiLogger_1.HiFiLogger.log(`Successfully set mute state to \`false\` by getting new input media stream!`);
                        return true;
                    }
                    else if (raviAudioStream && !newMutedValue) {
                        raviAudioStream.getTracks().forEach((track) => {
                            track.enabled = true;
                        });
                        HiFiLogger_1.HiFiLogger.log(`Successfully set mute state to \`false\` by enabling all tracks on \`_raviSession.streamController._inputAudioStream\`!`);
                        return true;
                    }
                    else {
                        HiFiLogger_1.HiFiLogger.warn(`Couldn't set mute state: No \`_inputAudioStream\` on \`_raviSession.streamController\`.`);
                    }
                }
            }
            else {
                HiFiLogger_1.HiFiLogger.warn(`Couldn't set mute state: No \`_raviSession\`, or \`_raviSession.getStreamController()\` returned null.`);
                return false;
            }
        });
    }
    getOutputAudioMediaStream() {
        if (!this._raviSession) {
            return null;
        }
        let streamController = this._raviSession.getStreamController();
        if (!streamController) {
            return null;
        }
        return streamController.getAudioStream();
    }
    onRAVISignalingStateChanged(event) {
        HiFiLogger_1.HiFiLogger.log(`New RAVI signaling state: \`${event.state}\``);
        switch (event.state) {
            case RaviSignalingConnection_1.SignalingStates.UNAVAILABLE:
                this._currentHiFiConnectionState = HiFiCommunicator_1.HiFiConnectionStates.Unavailable;
                if (this.onConnectionStateChanged) {
                    this.onConnectionStateChanged(this._currentHiFiConnectionState);
                }
                this.disconnect();
                break;
        }
    }
    onRAVISessionStateChanged(event) {
        HiFiLogger_1.HiFiLogger.log(`New RAVI session state: \`${event.state}\``);
        switch (event.state) {
            case RaviSession_1.RaviSessionStates.CONNECTED:
                this._mixerPeerKeyToProvidedUserIDDict = {};
                this._mixerPeerKeyToHashedVisitIDDict = {};
                this._currentHiFiConnectionState = HiFiCommunicator_1.HiFiConnectionStates.Connected;
                if (this.onConnectionStateChanged) {
                    this.onConnectionStateChanged(this._currentHiFiConnectionState);
                }
                break;
            case RaviSession_1.RaviSessionStates.DISCONNECTED:
                if (this._currentHiFiConnectionState === HiFiCommunicator_1.HiFiConnectionStates.Unavailable) {
                    break;
                }
                this._currentHiFiConnectionState = HiFiCommunicator_1.HiFiConnectionStates.Disconnected;
                if (this.onConnectionStateChanged) {
                    this.onConnectionStateChanged(this._currentHiFiConnectionState);
                }
                break;
            case RaviSession_1.RaviSessionStates.FAILED:
                if (this._currentHiFiConnectionState === HiFiCommunicator_1.HiFiConnectionStates.Unavailable) {
                    break;
                }
                this._currentHiFiConnectionState = HiFiCommunicator_1.HiFiConnectionStates.Failed;
                if (this.onConnectionStateChanged) {
                    this.onConnectionStateChanged(this._currentHiFiConnectionState);
                }
                break;
        }
    }
    startCollectingWebRTCStats(callback) {
        if (!this._raviSession) {
            HiFiLogger_1.HiFiLogger.error(`Couldn't start collecting WebRTC stats: No \`_raviSession\`!`);
            return;
        }
        if (this._statsObserverCallback) {
            this.stopCollectingWebRTCStats();
        }
        this._statsObserverCallback = callback;
        this._raviSession.addStatsObserver(this._statsObserverCallback);
    }
    stopCollectingWebRTCStats() {
        if (!this._raviSession) {
            HiFiLogger_1.HiFiLogger.error(`Couldn't stop collecting WebRTC stats: No \`_raviSession\`!`);
            return;
        }
        this._raviSession.removeStatsObserver(this._statsObserverCallback);
        this._statsObserverCallback = undefined;
    }
    _transmitHiFiAudioAPIDataToServer(hifiAudioAPIData) {
        if (!this.mixerInfo["connected"] || !this._raviSession) {
            return {
                success: false,
                error: `Can't transmit data to mixer; not connected to mixer.`
            };
        }
        let dataForMixer = {};
        if (hifiAudioAPIData.position) {
            let translatedPosition = HiFiAxisConfiguration_1.HiFiAxisUtilities.translatePoint3DToMixerSpace(HiFiAxisConfiguration_1.ourHiFiAxisConfiguration, hifiAudioAPIData.position);
            if (typeof (translatedPosition.x) === "number") {
                dataForMixer["x"] = Math.round(translatedPosition.x * 1000);
            }
            if (typeof (translatedPosition.y) === "number") {
                dataForMixer["y"] = Math.round(translatedPosition.y * 1000);
            }
            if (typeof (translatedPosition.z) === "number") {
                dataForMixer["z"] = Math.round(translatedPosition.z * 1000);
            }
        }
        if (hifiAudioAPIData.orientationEuler) {
            let translatedOrientation = HiFiAxisConfiguration_1.HiFiAxisUtilities.translateOrientationEuler3DToMixerSpace(HiFiAxisConfiguration_1.ourHiFiAxisConfiguration, hifiAudioAPIData.orientationEuler);
            if (typeof (translatedOrientation.pitchDegrees) === "number") {
                dataForMixer["k"] = translatedOrientation.pitchDegrees;
            }
            if (typeof (translatedOrientation.yawDegrees) === "number") {
                dataForMixer["o"] = translatedOrientation.yawDegrees;
            }
            if (typeof (translatedOrientation.rollDegrees) === "number") {
                dataForMixer["l"] = translatedOrientation.rollDegrees;
            }
        }
        if (hifiAudioAPIData.orientationQuat) {
            if (typeof (hifiAudioAPIData.orientationQuat.w) === "number") {
                dataForMixer["W"] = hifiAudioAPIData.orientationQuat.w * 1000;
            }
            if (typeof (hifiAudioAPIData.orientationQuat.x) === "number") {
                dataForMixer["X"] = hifiAudioAPIData.orientationQuat.x * 1000;
            }
            if (typeof (hifiAudioAPIData.orientationQuat.y) === "number") {
                dataForMixer["Y"] = hifiAudioAPIData.orientationQuat.y * 1000;
            }
            if (typeof (hifiAudioAPIData.orientationQuat.z) === "number") {
                dataForMixer["Z"] = hifiAudioAPIData.orientationQuat.z * 1000;
            }
        }
        if (typeof (hifiAudioAPIData.hiFiGain) === "number") {
            dataForMixer["g"] = Math.max(0, hifiAudioAPIData.hiFiGain);
        }
        if (Object.keys(dataForMixer).length === 0) {
            return {
                success: true,
                stringifiedDataForMixer: JSON.stringify({})
            };
        }
        else {
            let commandController = this._raviSession.getCommandController();
            if (commandController) {
                let stringifiedDataForMixer = JSON.stringify(dataForMixer);
                commandController.sendInput(stringifiedDataForMixer);
                return {
                    success: true,
                    stringifiedDataForMixer: stringifiedDataForMixer
                };
            }
            else {
                return {
                    success: false,
                    error: `Can't transmit data to mixer; no \`commandController\`!.`
                };
            }
        }
    }
    _resetMixerInfo() {
        this.mixerInfo = {
            "connected": false,
        };
    }
}
exports.HiFiMixerSession = HiFiMixerSession;


/***/ }),

/***/ "./src/classes/HiFiUserDataSubscription.ts":
/*!*************************************************!*\
  !*** ./src/classes/HiFiUserDataSubscription.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserDataSubscription = exports.AvailableUserDataSubscriptionComponents = void 0;
var AvailableUserDataSubscriptionComponents;
(function (AvailableUserDataSubscriptionComponents) {
    AvailableUserDataSubscriptionComponents["Position"] = "Position";
    AvailableUserDataSubscriptionComponents["OrientationEuler"] = "Orientation (Euler)";
    AvailableUserDataSubscriptionComponents["OrientationQuat"] = "Orientation (Quaternion)";
    AvailableUserDataSubscriptionComponents["VolumeDecibels"] = "Volume (Decibels)";
    AvailableUserDataSubscriptionComponents["HiFiGain"] = "HiFiGain";
})(AvailableUserDataSubscriptionComponents = exports.AvailableUserDataSubscriptionComponents || (exports.AvailableUserDataSubscriptionComponents = {}));
class UserDataSubscription {
    constructor({ providedUserID = null, components, callback }) {
        this.providedUserID = providedUserID;
        this.components = components;
        this.callback = callback;
    }
}
exports.UserDataSubscription = UserDataSubscription;


/***/ }),

/***/ "./src/constants/HiFiConstants.ts":
/*!****************************************!*\
  !*** ./src/constants/HiFiConstants.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HiFiConstants = void 0;
class HiFiConstants {
    constructor() { }
}
exports.HiFiConstants = HiFiConstants;
HiFiConstants.MIN_TRANSMIT_RATE_LIMIT_TIMEOUT_MS = 10;
HiFiConstants.DEFAULT_TRANSMIT_RATE_LIMIT_TIMEOUT_MS = 50;
HiFiConstants.DEFAULT_PROD_HIGH_FIDELITY_ENDPOINT = "wss://api.highfidelity.com:8001";
;


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const HiFiAudioAPIData_1 = __webpack_require__(/*! ./classes/HiFiAudioAPIData */ "./src/classes/HiFiAudioAPIData.ts");
const HiFiCommunicator_1 = __webpack_require__(/*! ./classes/HiFiCommunicator */ "./src/classes/HiFiCommunicator.ts");
const HiFiUserDataSubscription_1 = __webpack_require__(/*! ./classes/HiFiUserDataSubscription */ "./src/classes/HiFiUserDataSubscription.ts");
const HiFiLogger_1 = __webpack_require__(/*! ./utilities/HiFiLogger */ "./src/utilities/HiFiLogger.ts");
const HiFiUtilities_1 = __webpack_require__(/*! ./utilities/HiFiUtilities */ "./src/utilities/HiFiUtilities.ts");
const HiFiConstants_1 = __webpack_require__(/*! ./constants/HiFiConstants */ "./src/constants/HiFiConstants.ts");
const HiFiAxisConfiguration_1 = __webpack_require__(/*! ./classes/HiFiAxisConfiguration */ "./src/classes/HiFiAxisConfiguration.ts");
let isBrowserContext = typeof self !== 'undefined';
if (isBrowserContext) {
    exports.HiFiAPIVersion = "v0.2.8";
}
exports.HiFiCommunicator = HiFiCommunicator_1.HiFiCommunicator;
exports.HiFiConnectionStates = HiFiCommunicator_1.HiFiConnectionStates;
exports.HiFiUserDataStreamingScopes = HiFiCommunicator_1.HiFiUserDataStreamingScopes;
exports.AvailableUserDataSubscriptionComponents = HiFiUserDataSubscription_1.AvailableUserDataSubscriptionComponents;
exports.UserDataSubscription = HiFiUserDataSubscription_1.UserDataSubscription;
exports.ReceivedHiFiAudioAPIData = HiFiAudioAPIData_1.ReceivedHiFiAudioAPIData;
exports.HiFiAudioAPIData = HiFiAudioAPIData_1.HiFiAudioAPIData;
exports.Point3D = HiFiAudioAPIData_1.Point3D;
exports.OrientationEuler3D = HiFiAudioAPIData_1.OrientationEuler3D;
exports.OrientationQuat3D = HiFiAudioAPIData_1.OrientationQuat3D;
exports.HiFiLogger = HiFiLogger_1.HiFiLogger;
exports.HiFiLogLevel = HiFiLogger_1.HiFiLogLevel;
exports.getBestAudioConstraints = HiFiUtilities_1.getBestAudioConstraints;
exports.preciseInterval = HiFiUtilities_1.preciseInterval;
exports.HiFiConstants = HiFiConstants_1.HiFiConstants;
exports.HiFiAxes = HiFiAxisConfiguration_1.HiFiAxes;
exports.HiFiHandedness = HiFiAxisConfiguration_1.HiFiHandedness;
exports.HiFiAxisConfiguration = HiFiAxisConfiguration_1.HiFiAxisConfiguration;


/***/ }),

/***/ "./src/libravi/RaviCommandController.ts":
/*!**********************************************!*\
  !*** ./src/libravi/RaviCommandController.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RaviCommandController = void 0;
const RaviUtils_1 = __webpack_require__(/*! ./RaviUtils */ "./src/libravi/RaviUtils.ts");
const _BINARY_COMMAND_KEY = "_BINARY";
const _MOUSE_STATE_BUFFER_SIZE = 28;
var _KEY_CODE_TABLE;
(function (_KEY_CODE_TABLE) {
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ControlLeft"] = 0] = "ControlLeft";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["AltLeft"] = 1] = "AltLeft";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["OSLeft"] = 2] = "OSLeft";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Space"] = 3] = "Space";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["OSRight"] = 4] = "OSRight";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["AltRight"] = 5] = "AltRight";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ControlRight"] = 6] = "ControlRight";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ShiftLeft"] = 7] = "ShiftLeft";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ShiftRight"] = 8] = "ShiftRight";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Comma"] = 9] = "Comma";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Period"] = 10] = "Period";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Slash"] = 11] = "Slash";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["CapsLock"] = 12] = "CapsLock";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Enter"] = 13] = "Enter";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Semicolon"] = 14] = "Semicolon";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Quote"] = 15] = "Quote";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Tab"] = 16] = "Tab";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["BracketLeft"] = 17] = "BracketLeft";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["BracketRight"] = 18] = "BracketRight";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Backslash"] = 19] = "Backslash";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Backquote"] = 20] = "Backquote";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Minus"] = 21] = "Minus";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Equal"] = 22] = "Equal";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit0"] = 23] = "Digit0";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit1"] = 24] = "Digit1";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit2"] = 25] = "Digit2";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit3"] = 26] = "Digit3";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit4"] = 27] = "Digit4";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit5"] = 28] = "Digit5";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit6"] = 29] = "Digit6";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit7"] = 30] = "Digit7";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit8"] = 31] = "Digit8";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit9"] = 32] = "Digit9";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Backspace"] = 33] = "Backspace";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Escape"] = 34] = "Escape";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ArrowLeft"] = 35] = "ArrowLeft";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ArrowRight"] = 36] = "ArrowRight";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ArrowDown"] = 37] = "ArrowDown";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ArrowUp"] = 38] = "ArrowUp";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["PageDown"] = 39] = "PageDown";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["PageUp"] = 40] = "PageUp";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["End"] = 41] = "End";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Home"] = 42] = "Home";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Delete"] = 43] = "Delete";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Insert"] = 44] = "Insert";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad0"] = 45] = "Numpad0";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad1"] = 46] = "Numpad1";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad2"] = 47] = "Numpad2";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad3"] = 48] = "Numpad3";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad4"] = 49] = "Numpad4";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad5"] = 50] = "Numpad5";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad6"] = 51] = "Numpad6";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad7"] = 52] = "Numpad7";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad8"] = 53] = "Numpad8";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad9"] = 54] = "Numpad9";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadDecimal"] = 55] = "NumpadDecimal";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadEnter"] = 56] = "NumpadEnter";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadAdd"] = 57] = "NumpadAdd";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadSubtract"] = 58] = "NumpadSubtract";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumLock"] = 59] = "NumLock";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadEqual"] = 60] = "NumpadEqual";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadMultiply"] = 61] = "NumpadMultiply";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadDivide"] = 62] = "NumpadDivide";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyA"] = 63] = "KeyA";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyB"] = 64] = "KeyB";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyC"] = 65] = "KeyC";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyD"] = 66] = "KeyD";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyE"] = 67] = "KeyE";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyF"] = 68] = "KeyF";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyG"] = 69] = "KeyG";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyH"] = 70] = "KeyH";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyI"] = 71] = "KeyI";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyJ"] = 72] = "KeyJ";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyK"] = 73] = "KeyK";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyL"] = 74] = "KeyL";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyM"] = 75] = "KeyM";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyN"] = 76] = "KeyN";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyO"] = 77] = "KeyO";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyP"] = 78] = "KeyP";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyQ"] = 79] = "KeyQ";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyR"] = 80] = "KeyR";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyS"] = 81] = "KeyS";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyT"] = 82] = "KeyT";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyU"] = 83] = "KeyU";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyV"] = 84] = "KeyV";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyW"] = 85] = "KeyW";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyX"] = 86] = "KeyX";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyY"] = 87] = "KeyY";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyZ"] = 88] = "KeyZ";
})(_KEY_CODE_TABLE || (_KEY_CODE_TABLE = {}));
;
const _KEYBOARD_STATE_BUFFER_SIZE = 12;
class RaviCommandController {
    constructor() {
        RaviUtils_1.RaviUtils.log("constructor", "RaviCommandController");
        this._commandQueueMap = new Map();
        this._numQueuedCommands = 0;
        this._commandQueueInterval = 1000;
        this._commandPumpTimer = null;
        this._inputTarget;
        this._keyboardTarget;
        this._mouseStateBuffer = new ArrayBuffer(_MOUSE_STATE_BUFFER_SIZE + 4);
        this._mouseStateUint8 = new Uint8Array(this._mouseStateBuffer);
        this._mouseStateUint8[0] = 0x4D;
        this._mouseStateFloat = new Float32Array(this._mouseStateBuffer, 4);
        this._mouseStateFloat[0] = -1.0;
        this._mouseStateFloat[1] = -1.0;
        this._mouseStateFloat[2] = -1.0;
        this._mouseStateFloat[3] = -1.0;
        this._keyboardStateBuffer = new ArrayBuffer(_KEYBOARD_STATE_BUFFER_SIZE + 1);
        this._keyboardState = new Uint8Array(this._keyboardStateBuffer);
        this._keyboardState[0] = 0x4B;
    }
    setCommandQueueInterval(queueInterval) {
        this._commandQueueInterval = queueInterval;
        if (this._commandPumpTimer) {
            this.stopMonitoringQueues();
            this.monitorQueues();
        }
    }
    queueCommand(command, param, handler) {
        var commandQueue = this._commandQueueMap.get(command);
        if (!commandQueue) {
            commandQueue = { toSend: [], listener: [] };
            this._commandQueueMap.set(command, commandQueue);
        }
        var handlerInstance = null;
        if (handler) {
            handlerInstance = new RaviCommandHandlerInstance(handler, false, true);
        }
        commandQueue.toSend.push(new RaviCommandInstance(command, param, handlerInstance));
        this._numQueuedCommands++;
        RaviUtils_1.RaviUtils.log("Added command " + command, "RaviCommandController");
    }
    queueBinaryCommand(message) {
        let command = _BINARY_COMMAND_KEY;
        var commandQueue = this._commandQueueMap.get(command);
        if (!commandQueue) {
            commandQueue = { toSend: [], listener: [] };
            this._commandQueueMap.set(command, commandQueue);
        }
        commandQueue.toSend.push(new RaviCommandInstance(message, null, null));
        this._numQueuedCommands++;
        RaviUtils_1.RaviUtils.log("Added binary command", "RaviCommandController");
    }
    addMessageHandler(expectedMessage, handler, isSticky) {
        var messageEntry = this._commandQueueMap.get(expectedMessage);
        if (!messageEntry) {
            messageEntry = { toSend: [], listener: [] };
            this._commandQueueMap.set(expectedMessage, messageEntry);
        }
        var handlerInstance = new RaviCommandHandlerInstance(handler, isSticky, false);
        messageEntry.listener.push(handlerInstance);
    }
    addBinaryHandler(handler, isSticky) {
        this.addMessageHandler(_BINARY_COMMAND_KEY, handler, isSticky);
    }
    sendInput(inputEvent) {
        if (this._inputDataChannel && this._inputDataChannel.readyState === 'open') {
            this._inputDataChannel.send(inputEvent);
        }
    }
    monitorQueues() {
        RaviUtils_1.RaviUtils.log("Begin monitoring for queued commands", "RaviCommandController");
        this._commandPumpTimer = setInterval(this._processSendingQueuedCommands.bind(this), this._commandQueueInterval);
    }
    stopMonitoringQueues() {
        RaviUtils_1.RaviUtils.log("Stop monitoring for queued commands", "RaviCommandController");
        clearInterval(this._commandPumpTimer);
        this._commandPumpTimer = null;
    }
    _processSendingQueuedCommands() {
        if (this._numQueuedCommands <= 0) {
            return;
        }
        this._commandQueueMap.forEach(function (value, key, map) {
            if (value.toSend.length) {
                var commandInstance = value.toSend.shift();
                if (commandInstance._handler) {
                    value.listener.push(commandInstance._handler);
                }
                if (this._sendCommandInstance(commandInstance)) {
                    this._numQueuedCommands--;
                }
                else {
                    RaviUtils_1.RaviUtils.log("Send failed. CommandDataChannel may have been disconnected. Will not retry.", "RaviCommandController");
                }
            }
        }.bind(this));
    }
    _serializeJsonCommandMessageToSend(command, payload) {
        return JSON.stringify({ "c": command, "p": payload });
    }
    _unserializeJsonCommandMessageFromReceived(message) {
        let commandMessage;
        try {
            commandMessage = JSON.parse(message);
        }
        catch (e) {
            RaviUtils_1.RaviUtils.err(`Couldn't parse command message! Error:\n${e}\n Full message contents:\n${message}`, "RaviCommandController");
            return;
        }
        if (commandMessage && commandMessage.c && commandMessage.p) {
            return { 'command': commandMessage.c, 'payload': commandMessage.p };
        }
        RaviUtils_1.RaviUtils.err("Message cannot be unserialized into a CommandMessage: " + message, "RaviCommandController");
        return null;
    }
    _sendCommandInstance(commandInstance) {
        try {
            let message = commandInstance._command;
            if (typeof message === "string") {
                message = this._serializeJsonCommandMessageToSend(commandInstance._command, commandInstance._param);
                RaviUtils_1.RaviUtils.log("Sending command " + message, "RaviCommandController");
            }
            else {
                RaviUtils_1.RaviUtils.log("Sending binary command", "RaviCommandController");
            }
            this._commandDataChannel.send(message);
            return true;
        }
        catch (err) {
            RaviUtils_1.RaviUtils.err("Received error while sending: " + err.message, "RaviCommandController");
            return false;
        }
    }
    _processListeningCommand(fromServerMessage) {
        let serverData = fromServerMessage.data;
        let commandMessage = null;
        if (serverData) {
            if (typeof serverData === 'string') {
                commandMessage = this._unserializeJsonCommandMessageFromReceived(serverData);
                this._continueProcessingListeningCommand(commandMessage);
            }
            else if (serverData instanceof ArrayBuffer) {
                commandMessage = { 'command': _BINARY_COMMAND_KEY, 'payload': new Uint8Array(serverData) };
                this._continueProcessingListeningCommand(commandMessage);
            }
            else if (serverData instanceof Blob) {
                serverData.arrayBuffer()
                    .then((processedArrayBuffer) => {
                    commandMessage = { 'command': _BINARY_COMMAND_KEY, 'payload': new Uint8Array(processedArrayBuffer) };
                    this._continueProcessingListeningCommand(commandMessage);
                });
            }
        }
    }
    _continueProcessingListeningCommand(commandMessage) {
        if (!commandMessage) {
            RaviUtils_1.RaviUtils.err("Received invalid command message, ignoring: " + JSON.stringify(commandMessage), "RaviCommandController");
            return;
        }
        RaviUtils_1.RaviUtils.log("_continueProcessingListeningCommand: " + commandMessage, "RaviCommandController");
        var foundCommandInstance = this._commandQueueMap.get(commandMessage.command);
        if (foundCommandInstance) {
            var length = foundCommandInstance.listener.length;
            if (length > 0) {
                if (foundCommandInstance.listener[0] && foundCommandInstance.listener[0]._hasMatchingSentCommand) {
                    var commandInstance = foundCommandInstance.listener.shift();
                    if (commandInstance && commandInstance._handler) {
                        commandInstance._handler(commandMessage.payload);
                        return;
                    }
                    else {
                        RaviUtils_1.RaviUtils.err("Undefined command handler: " + commandMessage, "RaviCommandController");
                    }
                }
                else {
                    var newListeners = [];
                    for (var i = 0; i < length; i++) {
                        var listener = foundCommandInstance.listener[i];
                        if (listener && listener._handler) {
                            listener._handler(commandMessage.payload);
                        }
                        else {
                            RaviUtils_1.RaviUtils.err("Undefined message handler: " + commandMessage, "RaviCommandController");
                        }
                        if (listener && listener._isSticky) {
                            newListeners.push(listener);
                        }
                    }
                    foundCommandInstance.listener = newListeners;
                }
            }
        }
    }
    _setInputDataChannel(inputDataChannel) {
        this._inputDataChannel = inputDataChannel;
        RaviUtils_1.RaviUtils.log("Received new input data channel with id " + this._inputDataChannel.id, "RaviCommandController");
        this._inputDataChannel.onopen = function () {
            RaviUtils_1.RaviUtils.log("_inputDataChannel onopen, state is " + this._inputDataChannel.readyState, "RaviCommandController");
        }.bind(this);
        this._inputDataChannel.onclose = function () {
            RaviUtils_1.RaviUtils.log("_inputDataChannel onclose, state is " + this._inputDataChannel.readyState, "RaviCommandController");
        }.bind(this);
        this._inputDataChannel.onmessage = function (message) {
            RaviUtils_1.RaviUtils.log("_inputDataChannel got message: " + (message.data), "RaviCommandController");
        }.bind(this);
    }
    _setCommandDataChannel(commandDataChannel) {
        this._commandDataChannel = commandDataChannel;
        RaviUtils_1.RaviUtils.log("Received new data channel with id " + this._commandDataChannel.id, "RaviCommandController");
        this._commandDataChannel.onopen = function () {
            RaviUtils_1.RaviUtils.log("_commandDataChannel ononpen, state is " + this._commandDataChannel.readyState, "RaviCommandController");
            this.monitorQueues();
        }.bind(this);
        this._commandDataChannel.onclose = function () {
            RaviUtils_1.RaviUtils.log("_commandDataChannel onclose, state is " + this._commandDataChannel.readyState, "RaviCommandController");
            this.stopMonitoringQueues();
        }.bind(this);
        this._commandDataChannel.onmessage = function (message) {
            this._processListeningCommand(message);
        }.bind(this);
    }
    setInputTarget(inputTargetElement) {
        if (this._inputTarget) {
            this._inputTarget.onmousemove = null;
            this._inputTarget.onmouseenter = null;
            this._inputTarget.onmouseleave = null;
            this._inputTarget.onmousedown = null;
            this._inputTarget.onmouseup = null;
            this._inputTarget.onwheel = null;
        }
        this._inputTarget = inputTargetElement;
        if (this._inputTarget) {
            var that = this;
            this._inputTarget.onmousemove = function (event) { that._trackMouse(event); };
            this._inputTarget.onmouseenter = null;
            this._inputTarget.onmouseleave = null;
            this._inputTarget.onmousedown = function (event) { that._captureMouseDown(event); };
            this._inputTarget.onmouseup = function (event) { that._resetMouseDown(event); };
            this._inputTarget.onwheel = function (event) { that._wheelMouse(event); };
        }
    }
    setKeyboardTarget(inputTargetElement) {
        if (this._keyboardTarget) {
            this._keyboardTarget.onkeydown = null;
            this._keyboardTarget.onkeyup = null;
        }
        this._keyboardTarget = inputTargetElement;
        if (this._keyboardTarget) {
            var that = this;
            this._keyboardTarget.onkeydown = function (event) { that._onKeyboardDown(event); };
            this._keyboardTarget.onkeyup = function (event) { that._onKeyboardUp(event); };
        }
    }
    _captureMouseDown(e) {
        this._mouseStateFloat[0] = e.offsetX;
        this._mouseStateFloat[1] = e.offsetY;
        this._mouseStateFloat[2] = e.offsetX;
        this._mouseStateFloat[3] = e.offsetY;
        this._mouseStateUint8[1] = e.buttons;
        this._sendMouseState();
    }
    _resetMouseDown(e) {
        this._mouseStateFloat[0] = -1.0;
        this._mouseStateFloat[1] = -1.0;
        this._mouseStateFloat[2] = -1.0;
        this._mouseStateFloat[3] = -1.0;
        this._mouseStateUint8[1] = e.buttons;
        this._sendMouseState();
    }
    _trackMouse(e) {
        this._mouseStateFloat[0] = e.offsetX;
        this._mouseStateFloat[1] = e.offsetY;
        this._mouseStateFloat[4] = this._inputTarget.offsetWidth;
        this._mouseStateFloat[5] = this._inputTarget.offsetHeight;
        this._mouseStateUint8[1] = e.buttons;
        this._sendMouseState();
    }
    _wheelMouse(e) {
        this._mouseStateFloat[6] = e.deltaY;
        this._sendMouseState();
        this._mouseStateFloat[6] = 0;
    }
    _sendMouseState() {
        this.sendInput(this._mouseStateBuffer);
    }
    _keyByteNum(c) {
        return c >> 3;
    }
    _keyBitMask(c) {
        return (1 << (c % 8));
    }
    _onKeyboardDown(e) {
        let c = _KEY_CODE_TABLE[e.code];
        let keyByteNum = 1 + this._keyByteNum(c);
        let keyByteMask = this._keyBitMask(c);
        if ((this._keyboardState[keyByteNum] & keyByteMask) === 0) {
            this._keyboardState[keyByteNum] |= keyByteMask;
            this._sendKeyboardState();
        }
    }
    _onKeyboardUp(e) {
        let c = _KEY_CODE_TABLE[e.code];
        let keyByteNum = 1 + this._keyByteNum(c);
        let keyByteMask = this._keyBitMask(c);
        if ((this._keyboardState[keyByteNum] & keyByteMask) !== 0) {
            this._keyboardState[keyByteNum] ^= keyByteMask;
            this._sendKeyboardState();
        }
    }
    _sendKeyboardState() {
        this.sendInput(this._keyboardStateBuffer);
    }
}
exports.RaviCommandController = RaviCommandController;
class RaviCommandInstance {
    constructor(command, param, handler) {
        RaviUtils_1.RaviUtils.log("constructor", "RaviCommandInstance");
        this._command = command;
        this._param = param;
        this._handler = handler;
    }
}
class RaviCommandHandlerInstance {
    constructor(handler, isSticky, hasMatchingSentCommand) {
        RaviUtils_1.RaviUtils.log("constructor", "RaviCommandHandlerInstance");
        this._handler = handler;
        this._isSticky = isSticky;
        this._hasMatchingSentCommand = hasMatchingSentCommand;
    }
}


/***/ }),

/***/ "./src/libravi/RaviSession.ts":
/*!************************************!*\
  !*** ./src/libravi/RaviSession.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RaviSession = exports.RaviSessionStates = void 0;
const RaviStreamController_1 = __webpack_require__(/*! ./RaviStreamController */ "./src/libravi/RaviStreamController.ts");
const RaviUtils_1 = __webpack_require__(/*! ./RaviUtils */ "./src/libravi/RaviUtils.ts");
const RaviCommandController_1 = __webpack_require__(/*! ./RaviCommandController */ "./src/libravi/RaviCommandController.ts");
var RaviSessionStates;
(function (RaviSessionStates) {
    RaviSessionStates["NEW"] = "new";
    RaviSessionStates["CONNECTING"] = "checking";
    RaviSessionStates["CONNECTED"] = "connected";
    RaviSessionStates["COMPLETED"] = "completed";
    RaviSessionStates["DISCONNECTED"] = "disconnected";
    RaviSessionStates["FAILED"] = "failed";
    RaviSessionStates["CLOSED"] = "closed";
})(RaviSessionStates = exports.RaviSessionStates || (exports.RaviSessionStates = {}));
;
class RaviSession {
    constructor() {
        RaviUtils_1.RaviUtils.log("Constructor", "RaviSession");
        this._stateChangeHandlers = new Set();
        this._uuid = RaviUtils_1.RaviUtils.createUUID();
        this._commandController = new RaviCommandController_1.RaviCommandController();
        this._streamController = new RaviStreamController_1.RaviStreamController(this._commandController);
        this._state = RaviSessionStates.CLOSED;
        this._raviImplementation = new RaviWebRTCImplementation(this);
        const raviImpl = this._raviImplementation;
        this._streamController.setInputAudioChangeHandler(raviImpl._addAudioInputStream.bind(raviImpl));
        this._streamController.setInputVideoChangeHandler(raviImpl._addVideoInputStream.bind(raviImpl));
    }
    getState() {
        return this._state;
    }
    getUUID() {
        return this._uuid;
    }
    addStateChangeHandler(changeHandler) {
        try {
            this._stateChangeHandlers.add(changeHandler);
            return true;
        }
        catch (err) {
            RaviUtils_1.RaviUtils.err("Error adding a state change handler: " +
                err.message, "RaviSession");
            return false;
        }
        return false;
    }
    removeStateChangeHandler(changeHandler) {
        try {
            this._stateChangeHandlers.delete(changeHandler);
            return true;
        }
        catch (err) {
            RaviUtils_1.RaviUtils.err("Error removing a state change handler: " +
                err.message, "RaviSession");
            return false;
        }
        return false;
    }
    getCommandController() {
        return this._commandController;
    }
    getStreamController() {
        return this._streamController;
    }
    open(signalingConnection, timeout = 5000, params = null) {
        var raviSession = this;
        this._raviImplementation._assignSignalingConnection(signalingConnection);
        return new Promise((resolve, reject) => {
            RaviUtils_1.RaviUtils.log("Opening RAVI session", "RaviSession");
            let timer = setTimeout(() => {
                RaviUtils_1.RaviUtils.log("RaviSession.open timed out after " + timeout + " ms", "RaviSession");
                reject(Error("RaviSession.open timed out"));
                raviSession.close();
            }, timeout);
            const stateHandler = function (event) {
                var state = "";
                if (event && event.state)
                    state = event.state;
                if (state === RaviSessionStates.NEW ||
                    state === RaviSessionStates.CONNECTING ||
                    state === RaviSessionStates.DISCONNECTED) {
                    RaviUtils_1.RaviUtils.log("RAVI session state is " + state, "RaviSession");
                }
                else if (state === RaviSessionStates.CONNECTED ||
                    state === RaviSessionStates.COMPLETED) {
                    clearHandlerAndTimeout();
                    resolve(state);
                }
                else if (state === RaviSessionStates.FAILED) {
                    clearHandlerAndTimeout();
                    const closeTimer = setTimeout(() => {
                        raviSession._raviImplementation._close();
                    }, 0);
                    reject(Error(state));
                }
                else if (state === RaviSessionStates.CLOSED) {
                    clearHandlerAndTimeout();
                    reject(Error(state));
                }
            };
            const clearHandlerAndTimeout = function () {
                raviSession.removeStateChangeHandler(stateHandler);
                if (timer) {
                    clearTimeout(timer);
                    timer = null;
                }
            };
            raviSession.addStateChangeHandler(stateHandler);
            raviSession._raviImplementation._open(params);
        });
    }
    close() {
        var raviSession = this;
        this._streamController._stop();
        this._commandController.stopMonitoringQueues();
        return new Promise((resolve, reject) => {
            RaviUtils_1.RaviUtils.log("Closing RAVI session", "RaviSession");
            const stateHandler = function (event) {
                var state = "";
                if (event && event.state)
                    state = event.state;
                if (state === RaviSessionStates.DISCONNECTED) {
                    RaviUtils_1.RaviUtils.log("Closing...", "RaviSession");
                }
                else if (state === RaviSessionStates.CLOSED) {
                    raviSession.removeStateChangeHandler(stateHandler);
                    resolve(state);
                }
                else {
                    raviSession.removeStateChangeHandler(stateHandler);
                    reject(Error(state));
                }
            };
            raviSession.addStateChangeHandler(stateHandler);
            var event = { "state": RaviSessionStates.DISCONNECTED };
            raviSession._handleStateChange(event, RaviSessionStates.DISCONNECTED);
            raviSession._raviImplementation._close();
        });
    }
    _doOntrack(event) {
        RaviUtils_1.RaviUtils.log("Received new track: ", "RaviSession");
        RaviUtils_1.RaviUtils.log(event, "RaviSession");
        if (event && event.track && event.track.kind === "video") {
            RaviUtils_1.RaviUtils.log("Adding remote video track to stream controller", "RaviSession");
            this._streamController._setVideoStream(event.streams[0]);
            this._streamController._onVideoStreamStateChanged("ready");
        }
        if (event && event.track && event.track.kind === "audio") {
            RaviUtils_1.RaviUtils.log("Adding remote audio track to stream controller", "RaviSession");
            this._streamController._setAudioStream(event.streams[0]);
        }
    }
    _doOndatachannel(event) {
        RaviUtils_1.RaviUtils.log("Received new channel: ", "RaviSession");
        RaviUtils_1.RaviUtils.log(event, "RaviSession");
        switch (event.channel.label) {
            case "ravi.input":
                this._commandController._setInputDataChannel(event.channel);
                break;
            case "ravi.command":
                this._commandController._setCommandDataChannel(event.channel);
                break;
            default:
                RaviUtils_1.RaviUtils.log("Received unknown data channel named " + event.channel.label, "RaviSession");
                break;
        }
    }
    _handleStateChange(event, state) {
        this._state = state;
        if (!event) {
            return;
        }
        event["state"] = state;
        RaviUtils_1.RaviUtils.log("_handleStateChange: " + JSON.stringify(event), "RaviSession");
        this._stateChangeHandlers.forEach(function (handler) {
            if (handler) {
                handler(event);
            }
        });
    }
    addStatsObserver(observer) {
        return this._raviImplementation._addStatsObserver(observer);
    }
    removeStatsObserver(observer) {
        return this._raviImplementation._removeStatsObserver(observer);
    }
}
exports.RaviSession = RaviSession;
const STATS_WATCHER_FILTER = new Map([
    ["remote-inbound-rtp", ["id", "type", "timestamp", "roundTripTime", "jitter"]],
    ["inbound-rtp", ["id", "type", "timestamp", "jitterBufferDelay", "jitterBufferEmittedCount", "bytesReceived"]]
]);
class RaviWebRTCStatsWatcher {
    constructor(webRTCImplementation) {
        RaviUtils_1.RaviUtils.log("constructor", "RaviStatsWatcher");
        this._raviImplementation = webRTCImplementation;
        this._observers = new Set();
        this._filter = STATS_WATCHER_FILTER;
        this._interval = 0;
        this._prevStats = [];
    }
    stop() {
        if (this._interval) {
            window.clearInterval(this._interval);
            this._interval = 0;
        }
    }
    addObserver(observer) {
        try {
            this._observers.add(observer);
            this._onObserverChange();
            return true;
        }
        catch (err) {
            RaviUtils_1.RaviUtils.err("Error adding a stats observer: " +
                err.message, "RaviStatsWatcher");
            return false;
        }
        return false;
    }
    removeObserver(observer) {
        try {
            this._observers.delete(observer);
            this._onObserverChange();
            return true;
        }
        catch (err) {
            RaviUtils_1.RaviUtils.err("Error removing a stats observer handler: " +
                err.message, "RaviSession");
            return false;
        }
        return false;
    }
    _onObserverChange() {
        const INTERVAL = 1000;
        this._prevStats = [];
        if (this._observers.size > 0) {
            if (!this._interval) {
                window.setInterval((handler, timeout) => __awaiter(this, void 0, void 0, function* () {
                    const stats = yield this._raviImplementation._getStats();
                    let filteredStats = [];
                    if (stats) {
                        stats.forEach((report) => {
                            if (this._filter.has(report.type)) {
                                let selectedFields = this._filter.get(report.type);
                                let filteredReport = {};
                                selectedFields.forEach(key => {
                                    filteredReport[key] = report[key];
                                });
                                filteredStats.push(filteredReport);
                            }
                        });
                    }
                    if (filteredStats.length) {
                        this._observers.forEach((observer) => {
                            observer(filteredStats, this._prevStats);
                        });
                    }
                    this._prevStats = filteredStats;
                }), INTERVAL);
            }
        }
        else {
            if (this._interval) {
                window.clearInterval(this._interval);
                this._interval = 0;
            }
        }
    }
}
let crossPlatformRTCPeerConnection = null;
let crossPlatformRTCSessionDescription = null;
if (typeof self === 'undefined') {
    crossPlatformRTCPeerConnection = __webpack_require__(/*! wrtc */ "./node_modules/wrtc/lib/browser.js").RTCPeerConnection;
    crossPlatformRTCSessionDescription = __webpack_require__(/*! wrtc */ "./node_modules/wrtc/lib/browser.js").RTCSessionDescription;
}
else {
    crossPlatformRTCPeerConnection = RTCPeerConnection;
    crossPlatformRTCSessionDescription = RTCSessionDescription;
}
const peerConnectionConfig = {
    'iceServers': [
        { 'urls': 'stun:stun.l.google.com:19302' },
        { 'urls': 'turn:turn.highfidelity.com:3478',
            'username': 'clouduser',
            'credential': 'chariot-travesty-hook'
        }
    ]
};
class RaviWebRTCImplementation {
    constructor(raviSession) {
        RaviUtils_1.RaviUtils.log("constructor", "RaviWebRTCImplementation");
        this._raviSession = raviSession;
        this._negotiator = this._setupConnection.bind(this);
        this._initRtcConnection();
        this._statsWatcher = new RaviWebRTCStatsWatcher(this);
    }
    _initRtcConnection() {
        const raviSession = this._raviSession;
        const that = this;
        this._rtcConnection = new crossPlatformRTCPeerConnection(peerConnectionConfig);
        const rtcConnection = this._rtcConnection;
        let senders = rtcConnection.getSenders();
        senders.forEach((sender) => {
            sender.replaceTrack(null);
        });
        this._raviAudioSenders = [];
        this._raviVideoSenders = [];
        rtcConnection.addEventListener('iceconnectionstatechange', function (event) {
            raviSession._handleStateChange(event, rtcConnection.iceConnectionState);
        });
        rtcConnection.addEventListener('datachannel', function (event) { raviSession._doOndatachannel(event); });
        rtcConnection.addEventListener('track', function (event) { raviSession._doOntrack(event); });
        rtcConnection.addEventListener('icecandidate', function (event) { that._doOnicecandidate(event); });
        rtcConnection.addEventListener('negotiationneeded', function (event) { that._doOnnegotiationneeded(event); });
        rtcConnection.addEventListener("signalingstatechange", function (event) { that._doOnsignalingstatechanged(event); });
    }
    _assignSignalingConnection(signalingConnection) {
        this._signalingConnection = signalingConnection;
    }
    _addAudioInputStream(stream) {
        const rtcConnection = this._rtcConnection;
        const that = this;
        var retval = false;
        if (stream) {
            const currentSenders = this._raviAudioSenders;
            const newAudioTracks = stream.getAudioTracks();
            const numNewTracks = newAudioTracks.length;
            let i = 0;
            for (i; i < currentSenders.length; i++) {
                if (i < numNewTracks) {
                    RaviUtils_1.RaviUtils.log("Replacing audio track #" + i + "  in rtcConnection", "RaviWebRTCImplementation");
                    currentSenders[i].replaceTrack(newAudioTracks[i]);
                }
                else {
                    RaviUtils_1.RaviUtils.log("Setting audio sender #" + i + " to null", "RaviWebRTCImplementation");
                    currentSenders[i].replaceTrack(null);
                }
            }
            for (i; i < numNewTracks; i++) {
                RaviUtils_1.RaviUtils.log("Adding local audio track #" + i + " to rtcConnection", "RaviWebRTCImplementation");
                currentSenders.push(rtcConnection.addTrack(newAudioTracks[i]));
            }
        }
        else {
            const currentSenders = this._raviAudioSenders;
            let i = 0;
            for (i; i < currentSenders.length; i++) {
                RaviUtils_1.RaviUtils.log("Setting audio sender #" + i + " to null", "RaviWebRTCImplementation");
                currentSenders[i].replaceTrack(null);
            }
        }
        return retval;
    }
    _addVideoInputStream(stream) {
        const rtcConnection = this._rtcConnection;
        const that = this;
        var retval = false;
        if (stream) {
            const currentSenders = this._raviVideoSenders;
            const newVideoTracks = stream.getVideoTracks();
            const numNewTracks = newVideoTracks.length;
            if (numNewTracks > 0) {
                if (currentSenders.length > 0) {
                    RaviUtils_1.RaviUtils.log("Replacing video track #0 in rtcConnection", "RaviWebRTCImplementation");
                    currentSenders[0].replaceTrack(newVideoTracks[0]);
                }
                else {
                    RaviUtils_1.RaviUtils.log("Adding video track #0 to rtcConnection", "RaviWebRTCImplementation");
                    currentSenders.push(rtcConnection.addTrack(newVideoTracks[0]));
                }
                retval = true;
            }
            else {
                RaviUtils_1.RaviUtils.log("Assigned video stream doesn't contain vidoe track", "RaviWebRTCImplementation");
            }
        }
        else {
            const currentSenders = this._raviVideoSenders;
            let i = 0;
            for (i; i < currentSenders.length; i++) {
                RaviUtils_1.RaviUtils.log("Setting video sender #" + i + " to null", "RaviWebRTCImplementation");
                currentSenders[i].replaceTrack(null);
            }
        }
        return retval;
    }
    _open(params) {
        RaviUtils_1.RaviUtils.log("Attempting to open connection...", "RaviWebRTCImplementation");
        if (this._rtcConnection.connectionState == 'connecting' || this._rtcConnection.connectionState == 'connected') {
            RaviUtils_1.RaviUtils.log("We already have a connection in progress. Will not attempt a new one.", "RaviWebRTCImplementation");
            this._raviSession._handleStateChange({ "state": this._rtcConnection.connectionState }, this._rtcConnection.connectionState);
            return;
        }
        if (this._signalingConnection) {
            this._signalingConnection.addMessageHandler(this._negotiator);
            let message = {};
            if (params) {
                message = params;
                message["sessionID"] = this._raviSession.getUUID();
            }
            else {
                message = this._raviSession.getUUID();
            }
            this._signalingConnection.send(JSON.stringify({ 'request': message }));
        }
    }
    _close() {
        if (this._rtcConnection) {
            this._statsWatcher.stop();
            RaviUtils_1.RaviUtils.log("closing", "RaviWebRTCImplementation");
            this._rtcConnection.close();
            this._rtcConnection = null;
            var event = { "state": RaviSessionStates.CLOSED };
            this._raviSession._handleStateChange(event, RaviSessionStates.CLOSED);
            this._signalingConnection.removeMessageHandler(this._negotiator);
            this._initRtcConnection();
        }
    }
    _doOnicecandidate(event) {
        if (event.candidate && event.candidate != "") {
            RaviUtils_1.RaviUtils.log("Sending local ICE candidate: " + JSON.stringify(event.candidate), "RaviWebRTCImplementation");
            this._signalingConnection.send(JSON.stringify({ 'ice': event.candidate, 'uuid': this._raviSession.getUUID() }));
        }
        else {
            RaviUtils_1.RaviUtils.log("End of local ICE candidates", "RaviSession");
        }
    }
    _doOnnegotiationneeded(event) {
        RaviUtils_1.RaviUtils.log("need renegotiation please", "RaviWebRTCImplementation");
        const msg = {
            renegotiate: "please",
            uuid: this._raviSession.getUUID()
        };
        const desc = JSON.stringify(msg);
        if (this._signalingConnection && this._rtcConnection.signalingState === "stable") {
            this._signalingConnection.send(desc);
        }
    }
    _doOnsignalingstatechanged(event) {
        RaviUtils_1.RaviUtils.log("SignalingState changed: " + this._rtcConnection.signalingState, "RaviWebRTCImplementation");
    }
    _forceBitrateUp(sdp) {
        const localAudioIsStereo = this._raviSession._streamController.isStereoInput();
        const bitrate = localAudioIsStereo ? 128000 : 64000;
        return sdp.replace(/a=fmtp:111 /g, 'a=fmtp:111 maxaveragebitrate=' + bitrate + ';');
    }
    _forceStereoDown(sdp) {
        return sdp.replace(/a=fmtp:111 /g, 'a=fmtp:111 maxaveragebitrate=128000;sprop-stereo=1;stereo=1;');
    }
    _setupConnection(event) {
        let fullMessage = "";
        let signal = "";
        const raviSession = this._raviSession;
        const rtcConnection = this._rtcConnection;
        const signalingConnection = this._signalingConnection;
        const that = this;
        if (!raviSession || !rtcConnection || !signalingConnection) {
            RaviUtils_1.RaviUtils.err("Missing one of raviSession, rtcConnection, or signalingConnection! Can't set up connection.", "RaviWebRTCImplementation");
            return;
        }
        if (event && event.data) {
            RaviUtils_1.RaviUtils.log('Message from server: ' + event.data, "RaviWebRTCImplementation");
            fullMessage = JSON.parse(event.data);
        }
        else {
            RaviUtils_1.RaviUtils.log('No message received by onMessage handler', "RaviWebRTCImplementation");
            return;
        }
        signal = fullMessage[raviSession.getUUID()];
        if (!signal)
            return;
        if (signal.sdp) {
            RaviUtils_1.RaviUtils.log("Got sdp of type:" + signal.type, "RaviWebRTCImplementation");
            signal.sdp = that._forceBitrateUp(signal.sdp);
            const desc = new crossPlatformRTCSessionDescription(signal);
            rtcConnection.setRemoteDescription(desc)
                .then(function () {
                return rtcConnection.createAnswer();
            })
                .then(function (answer) {
                answer.sdp = that._forceStereoDown(answer.sdp);
                RaviUtils_1.RaviUtils.log("Answer:", "RaviWebRTCImplementation");
                RaviUtils_1.RaviUtils.log(answer, "RaviWebRTCImplementation");
                return rtcConnection.setLocalDescription(answer);
            })
                .then(function () {
                const msg = {
                    type: "answer",
                    sdp: rtcConnection.localDescription,
                    uuid: raviSession.getUUID()
                };
                const desc = JSON.stringify(msg);
                RaviUtils_1.RaviUtils.log("Sending answer to server", "RaviWebRTCImplementation");
                signalingConnection.send(desc);
            });
        }
        else if (signal.ice) {
            RaviUtils_1.RaviUtils.log("Received remote ICE candidate: " + JSON.stringify(signal.ice), "RaviWebRTCImplementation");
            rtcConnection.addIceCandidate(signal.ice)
                .then(function () {
                RaviUtils_1.RaviUtils.log("Added remote candidate", "RaviWebRTCImplementation");
            })
                .catch(function (e) {
                RaviUtils_1.RaviUtils.err("Error attempting to add remote ICE candidate: " + e.message, "RaviWebRTCImplementation");
            });
        }
        else {
            RaviUtils_1.RaviUtils.log("Unknown message " + JSON.stringify(signal), "RaviWebRTCImplementation");
        }
    }
    _addStatsObserver(observer) {
        return this._statsWatcher.addObserver(observer);
    }
    _removeStatsObserver(observer) {
        return this._statsWatcher.removeObserver(observer);
    }
    _getStats(selector = null) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._rtcConnection) {
                return this._rtcConnection.getStats(selector);
            }
            else {
                return {};
            }
        });
    }
}


/***/ }),

/***/ "./src/libravi/RaviSignalingConnection.ts":
/*!************************************************!*\
  !*** ./src/libravi/RaviSignalingConnection.ts ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RaviSignalingConnection = exports.SignalingStates = void 0;
const { RaviUtils } = __webpack_require__(/*! ./RaviUtils */ "./src/libravi/RaviUtils.ts");
var SignalingStates;
(function (SignalingStates) {
    SignalingStates["CONNECTING"] = "connecting";
    SignalingStates["OPEN"] = "open";
    SignalingStates["ERROR"] = "error";
    SignalingStates["CLOSING"] = "closing";
    SignalingStates["CLOSED"] = "closed";
    SignalingStates["UNAVAILABLE"] = "unavailable";
})(SignalingStates = exports.SignalingStates || (exports.SignalingStates = {}));
;
class RaviSignalingConnection {
    constructor() {
        RaviUtils.log("Constructor", "RaviSignalingConnection");
        this._stateChangeHandlers = new Set();
        this._messageHandlers = new Set();
        this._state = SignalingStates.CLOSED;
        this._signalingImplementation = new RaviSignalingWebSocketImplementation(this);
    }
    getState() {
        return this._state;
    }
    addStateChangeHandler(changeHandler) {
        try {
            this._stateChangeHandlers.add(changeHandler);
            return true;
        }
        catch (err) {
            RaviUtils.err("Error adding a state change handler: " +
                err.message, "RaviSignalingConnection");
            return false;
        }
        return false;
    }
    removeStateChangeHandler(changeHandler) {
        try {
            this._stateChangeHandlers.delete(changeHandler);
            return true;
        }
        catch (err) {
            RaviUtils.err("Error removing a state change handler: " +
                err.message, "RaviSignalingConnection");
            return false;
        }
        return false;
    }
    addMessageHandler(messageHandler) {
        try {
            this._messageHandlers.add(messageHandler);
            return true;
        }
        catch (err) {
            RaviUtils.err("Error adding a message handler: " +
                err.message, "RaviSignalingConnection");
            return false;
        }
        return false;
    }
    removeMessageHandler(messageHandler) {
        try {
            this._messageHandlers.delete(messageHandler);
            return true;
        }
        catch (err) {
            RaviUtils.err("Error removing a state change handler: " +
                err.message, "RaviSignalingConnection");
            return false;
        }
        return false;
    }
    open(URL) {
        var signalingConnection = this;
        return new Promise((resolve, reject) => {
            RaviUtils.log("Opening signaling connection to " + URL, "RaviSignalingController");
            const stateHandler = function (event) {
                var state = "";
                if (event && event.state)
                    state = event.state;
                if (state === SignalingStates.CONNECTING) {
                    RaviUtils.log("Connecting...", "RaviSignalingController");
                }
                else if (state === SignalingStates.OPEN) {
                    signalingConnection.removeStateChangeHandler(stateHandler);
                    resolve(state);
                }
                else {
                    signalingConnection.removeStateChangeHandler(stateHandler);
                    reject(event.error || new Error(event.message || state));
                }
            };
            signalingConnection.addStateChangeHandler(stateHandler);
            var event = { "state": SignalingStates.CONNECTING };
            this._handleStateChange(event, SignalingStates.CONNECTING);
            this._signalingImplementation._open(URL);
        });
    }
    send(message) {
        this._signalingImplementation._send(message);
    }
    close() {
        var signalingConnection = this;
        return new Promise((resolve, reject) => {
            RaviUtils.log("Closing signaling connection");
            const stateHandler = function (event) {
                var state = "";
                if (event && event.state)
                    state = event.state;
                if (state === SignalingStates.CLOSING) {
                    RaviUtils.log("Closing...", "RaviSignalingConnection");
                }
                else if (state === SignalingStates.CLOSED) {
                    signalingConnection.removeStateChangeHandler(stateHandler);
                    resolve(state);
                }
                else {
                    signalingConnection.removeStateChangeHandler(stateHandler);
                    reject(Error(state));
                }
            };
            signalingConnection.addStateChangeHandler(stateHandler);
            var event = { "state": SignalingStates.CLOSING };
            this._handleStateChange(event, SignalingStates.CLOSING);
            this._signalingImplementation._close();
        });
    }
    _handleStateChange(event, state) {
        this._state = state;
        event["state"] = state;
        RaviUtils.log("_handleStateChange: " + RaviUtils.safelyPrintable(event), "RaviSignalingConnection");
        this._stateChangeHandlers.forEach(function (handler) {
            if (handler) {
                handler(event);
            }
        });
    }
    _handleMessage(message) {
        RaviUtils.log("_doOnmessage: " + RaviUtils.safelyPrintable(message), "RaviSignalingConnection");
        if (message.data) {
            try {
                let messageData = JSON.parse(message.data);
                if (messageData.error && messageData.error == "service-unavailable") {
                    this._handleStateChange({}, SignalingStates.UNAVAILABLE);
                }
            }
            catch (err) {
            }
        }
        this._messageHandlers.forEach(function (handler) {
            if (handler) {
                handler(message);
            }
        });
    }
}
exports.RaviSignalingConnection = RaviSignalingConnection;
let crossPlatformWebSocket = null;
if (typeof self === 'undefined') {
    crossPlatformWebSocket = __webpack_require__(/*! ws */ "./node_modules/ws/browser.js");
}
else {
    crossPlatformWebSocket = WebSocket;
}
class RaviSignalingWebSocketImplementation {
    constructor(raviSignalingConnection) {
        RaviUtils.log("constructor", "RaviSignalingWebSocketImplementation");
        this._raviSignalingConnection = raviSignalingConnection;
    }
    _open(socketAddress) {
        this._webSocket = new crossPlatformWebSocket(socketAddress);
        var signalingConnection = this._raviSignalingConnection;
        this._webSocket.addEventListener('open', function (event) { signalingConnection._handleStateChange(event, SignalingStates.OPEN); });
        this._webSocket.addEventListener('error', function (event) { signalingConnection._handleStateChange(event, SignalingStates.ERROR); });
        this._webSocket.addEventListener('close', function (event) { signalingConnection._handleStateChange(event, SignalingStates.CLOSED); });
        this._webSocket.addEventListener('message', function (event) { signalingConnection._handleMessage(event); });
    }
    _send(message) {
        if (this._webSocket && this._webSocket.readyState === crossPlatformWebSocket.OPEN) {
            RaviUtils.log("Sending message to server: " + message, "RaviSignalingWebSocketImplementation");
            this._webSocket.send(message);
        }
    }
    _close() {
        if (this._webSocket) {
            this._webSocket.close();
            this._webSocket = null;
        }
    }
}
module.exports.SignalingStates = SignalingStates;


/***/ }),

/***/ "./src/libravi/RaviStreamController.ts":
/*!*********************************************!*\
  !*** ./src/libravi/RaviStreamController.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RaviStreamController = void 0;
const { RaviUtils } = __webpack_require__(/*! ./RaviUtils */ "./src/libravi/RaviUtils.ts");
class RaviStreamController {
    constructor(raviCommandController) {
        RaviUtils.log("constructor", "RaviStreamController");
        this._commandController = raviCommandController;
        this._audioStream = null;
        this._videoStream = null;
        this._onVideoStreamStateChanged = function (state) { RaviUtils.log("onvideostreamstatechanged " + state, "RaviStreamController"); };
        this._onInputAudioChanged = null;
        this._onInputVideoChanged = null;
    }
    getVideoStream() {
        return this._videoStream;
    }
    _setVideoStream(videoStream) {
        this._videoStream = videoStream;
        if (this._videoContainer) {
            this._videoContainer.srcObject = this._videoStream;
        }
    }
    setVideoContainer(videoElement, onvideostreamstatechanged) {
        this._videoContainer = videoElement;
        if (this._videoStream) {
            this._videoContainer.srcObject = this._videoStream;
        }
        this.setVideoStateChangeHandler(onvideostreamstatechanged);
    }
    setVideoStateChangeHandler(onvideostreamstatechanged) {
        if (onvideostreamstatechanged) {
            this._onVideoStreamStateChanged = onvideostreamstatechanged;
        }
    }
    showVideoDashboard(enabled) {
        this._commandController.queueCommand("video.showDashboard", { "enabled": enabled }, null);
    }
    showVideoCursor(enabled) {
        this._commandController.queueCommand("video.showCursor", { "enabled": enabled }, null);
    }
    getAudioStream() {
        return this._audioStream;
    }
    _setAudioStream(audioStream) {
        this._audioStream = audioStream;
        if (this._audioContainer) {
            this._audioContainer.srcObject = this._audioStream;
        }
    }
    setAudioContainer(audioElement) {
        this._audioContainer = audioElement;
        if (this._audioStream) {
            this._audioContainer.srcObject = this._audioStream;
        }
    }
    setInputAudio(stream, isStereo = false) {
        this._inputAudioStream = stream;
        this._isStereo = isStereo;
        if (this._onInputAudioChanged)
            this._onInputAudioChanged(stream);
    }
    setInputAudioChangeHandler(oninputaudiochanged) {
        if (oninputaudiochanged) {
            this._onInputAudioChanged = oninputaudiochanged;
        }
    }
    setInputVideo(stream) {
        this._inputVideoStream = stream;
        if (this._onInputVideoChanged)
            this._onInputVideoChanged(stream);
    }
    setInputVideoChangeHandler(oninputvideochanged) {
        if (oninputvideochanged) {
            this._onInputVideoChanged = oninputvideochanged;
        }
    }
    isStereoInput() {
        return this._isStereo;
    }
    _stop() {
        RaviUtils.log("stopping streams", "RaviStreamController");
        if (this._videoContainer && this._videoContainer.srcObject) {
            let srcObject = this._videoContainer.srcObject;
            let tracks = srcObject.getTracks();
            tracks.forEach(track => track.stop());
            this._videoContainer.srcObject = null;
            this._onVideoStreamStateChanged("over");
        }
        if (this._audioStream) {
            this._audioStream.getTracks().forEach(track => track.stop());
            this._audioStream = null;
        }
    }
}
exports.RaviStreamController = RaviStreamController;


/***/ }),

/***/ "./src/libravi/RaviUtils.ts":
/*!**********************************!*\
  !*** ./src/libravi/RaviUtils.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RaviUtils = void 0;
var DEBUG = true;
class RaviUtils {
    static createUUID() {
        function s4() {
            return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
        }
        return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    }
    static log(message, classname) {
        if (typeof classname !== 'undefined')
            message = classname + ": " + message;
        if (DEBUG) {
            console.log(message);
        }
        if (typeof document !== 'undefined') {
            try {
                document.dispatchEvent(new CustomEvent('logger', { detail: message }));
            }
            catch (err) {
                console.log(message);
                console.log("Additionally, an error was encountered trying to log that.");
                console.log(err);
            }
        }
    }
    static err(message, classname) {
        if (typeof classname !== 'undefined')
            message = classname + ": " + message;
        console.log('%c %s', 'color: #FB0A1C', message);
        if (typeof document !== 'undefined') {
            document.dispatchEvent(new CustomEvent('errlogger', { detail: message }));
        }
    }
    static safelyPrintable(item) {
        try {
            return JSON.stringify(item);
        }
        catch (e) {
            return item;
        }
    }
    static getElementCSSSize(el) {
        if (!getComputedStyle) {
            return;
        }
        var cs = getComputedStyle(el);
        var w = parseInt(cs.getPropertyValue("width"), 10);
        var h = parseInt(cs.getPropertyValue("height"), 10);
        return { width: w, height: h };
    }
    static setDebug(debug) {
        DEBUG = debug;
    }
}
exports.RaviUtils = RaviUtils;


/***/ }),

/***/ "./src/utilities/HiFiLogger.ts":
/*!*************************************!*\
  !*** ./src/utilities/HiFiLogger.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HiFiLogger = exports.HiFiLogLevel = void 0;
var HiFiLogLevel;
(function (HiFiLogLevel) {
    HiFiLogLevel["None"] = "None";
    HiFiLogLevel["Error"] = "Error";
    HiFiLogLevel["Warn"] = "Warn";
    HiFiLogLevel["Debug"] = "Debug";
})(HiFiLogLevel = exports.HiFiLogLevel || (exports.HiFiLogLevel = {}));
class HiFiLogger {
    constructor(logLevel) {
        logLevel = logLevel ? logLevel : HiFiLogLevel.Debug;
    }
    static setHiFiLogLevel(newLogLevel) {
        HiFiLogger.logLevel = newLogLevel;
    }
    static log(message) {
        if (HiFiLogger.logLevel === HiFiLogLevel.Debug) {
            console.log(message);
            return true;
        }
        else {
            return false;
        }
    }
    static debug(message) {
        return this.log(message);
    }
    static warn(message) {
        if (HiFiLogger.logLevel === HiFiLogLevel.Debug || HiFiLogger.logLevel === HiFiLogLevel.Warn) {
            console.warn(message);
            return true;
        }
        else {
            return false;
        }
    }
    static error(message) {
        if (HiFiLogger.logLevel === HiFiLogLevel.Debug || HiFiLogger.logLevel === HiFiLogLevel.Warn || HiFiLogger.logLevel === HiFiLogLevel.Error) {
            console.error(message);
            return true;
        }
        else {
            return false;
        }
    }
}
exports.HiFiLogger = HiFiLogger;
HiFiLogger.logLevel = HiFiLogLevel.Error;


/***/ }),

/***/ "./src/utilities/HiFiUtilities.ts":
/*!****************************************!*\
  !*** ./src/utilities/HiFiUtilities.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.preciseInterval = exports.getBestAudioConstraints = exports.recursivelyDiffObjects = void 0;
const HiFiLogger_1 = __webpack_require__(/*! ./HiFiLogger */ "./src/utilities/HiFiLogger.ts");
let now;
if (typeof self === 'undefined') {
    try {
        now = __webpack_require__(/*! perf_hooks */ "?ad5c").performance.now;
    }
    catch (_a) { }
}
function recursivelyDiffObjects(obj1, obj2) {
    if (!obj2 || Object.prototype.toString.call(obj2) !== '[object Object]') {
        return obj1;
    }
    let diffs = {};
    let key;
    let doArraysMatch = (arr1, arr2) => {
        if (arr1.length !== arr2.length) {
            return false;
        }
        for (let i = 0; i < arr1.length; i++) {
            if (arr1[i] !== arr2[i]) {
                return false;
            }
        }
        return true;
    };
    let compare = (item1, item2, key) => {
        let type1 = Object.prototype.toString.call(item1);
        let type2 = Object.prototype.toString.call(item2);
        if (type2 === '[object Undefined]') {
            diffs[key] = null;
            return;
        }
        if (type1 !== type2) {
            diffs[key] = item2;
            return;
        }
        if (type1 === '[object Object]') {
            let objDiff = recursivelyDiffObjects(item1, item2);
            if (Object.keys(objDiff).length > 0) {
                diffs[key] = objDiff;
            }
            return;
        }
        if (type1 === '[object Array]') {
            if (!doArraysMatch(item1, item2)) {
                diffs[key] = item2;
            }
            return;
        }
        if (type1 === '[object Function]') {
            if (item1.toString() !== item2.toString()) {
                diffs[key] = item2;
            }
        }
        else {
            if (item1 !== item2) {
                diffs[key] = item2;
            }
        }
    };
    for (key in obj1) {
        if (obj1.hasOwnProperty(key)) {
            compare(obj1[key], obj2[key], key);
        }
    }
    for (key in obj2) {
        if (obj2.hasOwnProperty(key)) {
            if (!obj1[key] && obj1[key] !== obj2[key]) {
                diffs[key] = obj2[key];
            }
        }
    }
    return diffs;
}
exports.recursivelyDiffObjects = recursivelyDiffObjects;
;
function getBestAudioConstraints() {
    let audioConstraints = {};
    if (typeof (navigator) !== "undefined" && typeof (navigator.mediaDevices) !== "undefined" && typeof (navigator.mediaDevices.getSupportedConstraints) !== "undefined" && navigator.mediaDevices.getSupportedConstraints().echoCancellation) {
        audioConstraints.echoCancellation = false;
    }
    if (typeof (navigator) !== "undefined" && typeof (navigator.mediaDevices) !== "undefined" && typeof (navigator.mediaDevices.getSupportedConstraints) !== "undefined" && navigator.mediaDevices.getSupportedConstraints().noiseSuppression) {
        audioConstraints.noiseSuppression = false;
    }
    if (typeof (navigator) !== "undefined" && typeof (navigator.mediaDevices) !== "undefined" && typeof (navigator.mediaDevices.getSupportedConstraints) !== "undefined" && navigator.mediaDevices.getSupportedConstraints().autoGainControl) {
        audioConstraints.autoGainControl = false;
    }
    return audioConstraints;
}
exports.getBestAudioConstraints = getBestAudioConstraints;
function preciseInterval(callback, intervalMS) {
    if (!now) {
        HiFiLogger_1.HiFiLogger.warn(`\`preciseInterval()\` is a wrapper for \`setInterval()\` in the browser context!`);
        return setInterval(callback, intervalMS);
    }
    let nextTick = now();
    let clear = clearTimeout;
    let wrapper = () => {
        let thisTick = now();
        if (thisTick < nextTick) {
            clear = clearImmediate;
            return timeout = setImmediate(wrapper);
        }
        nextTick += intervalMS;
        clear = clearTimeout;
        timeout = setTimeout(wrapper, nextTick - thisTick - 2);
        callback();
    };
    let timeout = setTimeout(wrapper);
    return { clear: () => clear(timeout) };
}
exports.preciseInterval = preciseInterval;


/***/ }),

/***/ "./node_modules/wrtc/lib/browser.js":
/*!******************************************!*\
  !*** ./node_modules/wrtc/lib/browser.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.MediaStream = window.MediaStream;
exports.MediaStreamTrack = window.MediaStreamTrack;
exports.RTCDataChannel = window.RTCDataChannel;
exports.RTCDataChannelEvent = window.RTCDataChannelEvent;
exports.RTCDtlsTransport = window.RTCDtlsTransport;
exports.RTCIceCandidate = window.RTCIceCandidate;
exports.RTCIceTransport = window.RTCIceTransport;
exports.RTCPeerConnection = window.RTCPeerConnection;
exports.RTCPeerConnectionIceEvent = window.RTCPeerConnectionIceEvent;
exports.RTCRtpReceiver = window.RTCRtpReceiver;
exports.RTCRtpSender = window.RTCRtpSender;
exports.RTCRtpTransceiver = window.RTCRtpTransceiver;
exports.RTCSctpTransport = window.RTCSctpTransport;
exports.RTCSessionDescription = window.RTCSessionDescription;
exports.getUserMedia = window.getUserMedia;
exports.mediaDevices = navigator.mediaDevices;


/***/ }),

/***/ "./node_modules/ws/browser.js":
/*!************************************!*\
  !*** ./node_modules/ws/browser.js ***!
  \************************************/
/***/ ((module) => {

"use strict";


module.exports = function () {
  throw new Error(
    'ws does not work in the browser. Browser clients must use the native ' +
      'WebSocket object'
  );
};


/***/ }),

/***/ "?ad5c":
/*!****************************!*\
  !*** perf_hooks (ignored) ***!
  \****************************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__("./src/index.ts");
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9ub2RlX21vZHVsZXMvcGFrby9pbmRleC5qcyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvZGVmbGF0ZS5qcyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvaW5mbGF0ZS5qcyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvY29tbW9uLmpzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9zdHJpbmdzLmpzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2FkbGVyMzIuanMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY29uc3RhbnRzLmpzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NyYzMyLmpzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2RlZmxhdGUuanMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZ3poZWFkZXIuanMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mZmFzdC5qcyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZsYXRlLmpzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZnRyZWVzLmpzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL21lc3NhZ2VzLmpzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3RyZWVzLmpzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3pzdHJlYW0uanMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vc3JjL2NsYXNzZXMvSGlGaUF1ZGlvQVBJRGF0YS50cyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9zcmMvY2xhc3Nlcy9IaUZpQXhpc0NvbmZpZ3VyYXRpb24udHMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vc3JjL2NsYXNzZXMvSGlGaUNvbW11bmljYXRvci50cyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9zcmMvY2xhc3Nlcy9IaUZpTWl4ZXJTZXNzaW9uLnRzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL3NyYy9jbGFzc2VzL0hpRmlVc2VyRGF0YVN1YnNjcmlwdGlvbi50cyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9zcmMvY29uc3RhbnRzL0hpRmlDb25zdGFudHMudHMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vc3JjL2luZGV4LnRzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL3NyYy9saWJyYXZpL1JhdmlDb21tYW5kQ29udHJvbGxlci50cyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9zcmMvbGlicmF2aS9SYXZpU2Vzc2lvbi50cyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9zcmMvbGlicmF2aS9SYXZpU2lnbmFsaW5nQ29ubmVjdGlvbi50cyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9zcmMvbGlicmF2aS9SYXZpU3RyZWFtQ29udHJvbGxlci50cyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9zcmMvbGlicmF2aS9SYXZpVXRpbHMudHMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vc3JjL3V0aWxpdGllcy9IaUZpTG9nZ2VyLnRzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL3NyYy91dGlsaXRpZXMvSGlGaVV0aWxpdGllcy50cyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9ub2RlX21vZHVsZXMvd3J0Yy9saWIvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9ub2RlX21vZHVsZXMvd3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vaWdub3JlZHxwZXJmX2hvb2tzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vd2VicGFjay9zdGFydHVwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDYTs7QUFFYixPQUFPLHFDQUFxQyxHQUFHLG1CQUFPLENBQUMseURBQWU7O0FBRXRFLE9BQU8sdUNBQXVDLEdBQUcsbUJBQU8sQ0FBQyx5REFBZTs7QUFFeEUsa0JBQWtCLG1CQUFPLENBQUMsdUVBQXNCOztBQUVoRCxzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHlCQUF5QjtBQUN6QixtQkFBbUI7QUFDbkIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0Qix5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLHdCQUF3Qjs7Ozs7Ozs7Ozs7O0FDakJYOzs7QUFHYixxQkFBcUIsbUJBQU8sQ0FBQywrREFBZ0I7QUFDN0MscUJBQXFCLG1CQUFPLENBQUMsK0RBQWdCO0FBQzdDLHFCQUFxQixtQkFBTyxDQUFDLGlFQUFpQjtBQUM5QyxxQkFBcUIsbUJBQU8sQ0FBQyxpRUFBaUI7QUFDOUMscUJBQXFCLG1CQUFPLENBQUMsK0RBQWdCOztBQUU3Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRyxtQkFBTyxDQUFDLG1FQUFrQjs7QUFFOUI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxVQUFVO0FBQy9DO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxxQkFBcUIsOEJBQThCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZUFBZTs7QUFFbEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLHNCQUFzQjtBQUN0QixtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGNBQWM7O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscUJBQXFCLHlDQUF5Qzs7QUFFOUQ7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUFFQTtBQUNBLHFCQUFxQjs7QUFFckIsc0NBQXNDOztBQUV0Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUEsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1QkFBdUI7QUFDcEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQTtB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LEtBQUssQ0FBQyw4Q0FBOEMsaUJBQWlCLENBQUMsTUFBTSxzQkFBc0IsaUJBQWlCLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQztZQUM1SSxPQUFPLEdBQUcsS0FBSyxDQUFDO1NBQ25CO1FBRUQsSUFBSSxpQkFBaUIsQ0FBQyxNQUFNLEtBQUssUUFBUSxDQUFDLFNBQVMsSUFBSSxpQkFBaUIsQ0FBQyxRQUFRLEtBQUssUUFBUSxDQUFDLFNBQVMsRUFBRTtZQUN0Ryx1QkFBVSxDQUFDLEtBQUssQ0FBQyw4Q0FBOEMsaUJBQWlCLENBQUMsTUFBTSxzQkFBc0IsaUJBQWlCLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQztZQUM1SSxPQUFPLEdBQUcsS0FBSyxDQUFDO1NBQ25CO1FBQ0QsSUFBSSxpQkFBaUIsQ0FBQyxRQUFRLEtBQUssUUFBUSxDQUFDLFNBQVMsSUFBSSxpQkFBaUIsQ0FBQyxNQUFNLEtBQUssUUFBUSxDQUFDLFNBQVMsRUFBRTtZQUN0Ryx1QkFBVSxDQUFDLEtBQUssQ0FBQyw4Q0FBOEMsaUJBQWlCLENBQUMsTUFBTSxzQkFBc0IsaUJBQWlCLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQztZQUM1SSxPQUFPLEdBQUcsS0FBSyxDQUFDO1NBQ25CO1FBRUQsSUFBSSxpQkFBaUIsQ0FBQyxNQUFNLEtBQUssUUFBUSxDQUFDLFNBQVMsSUFBSSxpQkFBaUIsQ0FBQyxRQUFRLEtBQUssUUFBUSxDQUFDLFNBQVMsRUFBRTtZQUN0Ryx1QkFBVSxDQUFDLEtBQUssQ0FBQyw4Q0FBOEMsaUJBQWlCLENBQUMsTUFBTSxzQkFBc0IsaUJBQWlCLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQztZQUM1SSxPQUFPLEdBQUcsS0FBSyxDQUFDO1NBQ25CO1FBQ0QsSUFBSSxpQkFBaUIsQ0FBQyxRQUFRLEtBQUssUUFBUSxDQUFDLFNBQVMsSUFBSSxpQkFBaUIsQ0FBQyxNQUFNLEtBQUssUUFBUSxDQUFDLFNBQVMsRUFBRTtZQUN0Ryx1QkFBVSxDQUFDLEtBQUssQ0FBQyw4Q0FBOEMsaUJBQWlCLENBQUMsTUFBTSxz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OztBQUViLG1CQUFtQjtBQUNuQix3QkFBd0I7QUFDeEIsc0JBQXNCO0FBQ3RCLDJCQUEyQjtBQUMzQix3QkFBd0I7QUFDeEIsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekIsaUNBQWlDO0FBQ2pDLHNCQUFzQjtBQUN0QixvQkFBb0I7QUFDcEIseUJBQXlCO0FBQ3pCLHdCQUF3QjtBQUN4Qiw2QkFBNkI7QUFDN0Isb0JBQW9CO0FBQ3BCLG9CQUFvQjs7Ozs7Ozs7Ozs7O0FDakJQOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNQQSxlOzs7Ozs7VUNBQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7O1VDckJBO1VBQ0E7VUFDQTtVQUNBIiwiZmlsZSI6IkhpZ2hGaWRlbGl0eUF1ZGlvLWxhdGVzdC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRvcCBsZXZlbCBmaWxlIGlzIGp1c3QgYSBtaXhpbiBvZiBzdWJtb2R1bGVzICYgY29uc3RhbnRzXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgRGVmbGF0ZSwgZGVmbGF0ZSwgZGVmbGF0ZVJhdywgZ3ppcCB9ID0gcmVxdWlyZSgnLi9saWIvZGVmbGF0ZScpO1xuXG5jb25zdCB7IEluZmxhdGUsIGluZmxhdGUsIGluZmxhdGVSYXcsIHVuZ3ppcCB9ID0gcmVxdWlyZSgnLi9saWIvaW5mbGF0ZScpO1xuXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2xpYi96bGliL2NvbnN0YW50cycpO1xuXG5tb2R1bGUuZXhwb3J0cy5EZWZsYXRlID0gRGVmbGF0ZTtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZVJhdyA9IGRlZmxhdGVSYXc7XG5tb2R1bGUuZXhwb3J0cy5nemlwID0gZ3ppcDtcbm1vZHVsZS5leHBvcnRzLkluZmxhdGUgPSBJbmZsYXRlO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlUmF3ID0gaW5mbGF0ZVJhdztcbm1vZHVsZS5leHBvcnRzLnVuZ3ppcCA9IHVuZ3ppcDtcbm1vZHVsZS5leHBvcnRzLmNvbnN0YW50cyA9IGNvbnN0YW50cztcbiIsIid1c2Ugc3RyaWN0JztcblxuXG5jb25zdCB6bGliX2RlZmxhdGUgPSByZXF1aXJlKCcuL3psaWIvZGVmbGF0ZScpO1xuY29uc3QgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi91dGlscy9jb21tb24nKTtcbmNvbnN0IHN0cmluZ3MgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvc3RyaW5ncycpO1xuY29uc3QgbXNnICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL21lc3NhZ2VzJyk7XG5jb25zdCBaU3RyZWFtICAgICAgPSByZXF1aXJlKCcuL3psaWIvenN0cmVhbScpO1xuXG5jb25zdCB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5jb25zdCB7XG4gIFpfTk9fRkxVU0gsIFpfU1lOQ19GTFVTSCwgWl9GVUxMX0ZMVVNILCBaX0ZJTklTSCxcbiAgWl9PSywgWl9TVFJFQU1fRU5ELFxuICBaX0RFRkFVTFRfQ09NUFJFU1NJT04sXG4gIFpfREVGQVVMVF9TVFJBVEVHWSxcbiAgWl9ERUZMQVRFRFxufSA9IHJlcXVpcmUoJy4vemxpYi9jb25zdGFudHMnKTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKipcbiAqIGNsYXNzIERlZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tkZWZsYXRlXV0sXG4gKiBbW2RlZmxhdGVSYXddXSBhbmQgW1tnemlwXV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBEZWZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tEZWZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZGVuLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXlcbiAqXG4gKiBDb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tEZWZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tEZWZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0RlZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkuXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5lcnIgLT4gTnVtYmVyXG4gKlxuICogRXJyb3IgY29kZSBhZnRlciBkZWZsYXRlIGZpbmlzaGVkLiAwIChaX09LKSBvbiBzdWNjZXNzLlxuICogWW91IHdpbGwgbm90IG5lZWQgaXQgaW4gcmVhbCBsaWZlLCBiZWNhdXNlIGRlZmxhdGUgZXJyb3JzXG4gKiBhcmUgcG9zc2libGUgb25seSBvbiB3cm9uZyBvcHRpb25zIG9yIGJhZCBgb25EYXRhYCAvIGBvbkVuZGBcbiAqIGN1c3RvbSBoYW5kbGVycy5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0RlZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IERlZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgZGVmbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGBsZXZlbGBcbiAqIC0gYHdpbmRvd0JpdHNgXG4gKiAtIGBtZW1MZXZlbGBcbiAqIC0gYHN0cmF0ZWd5YFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgZGVmbGF0ZVxuICogLSBgZ3ppcGAgKEJvb2xlYW4pIC0gY3JlYXRlIGd6aXAgd3JhcHBlclxuICogLSBgaGVhZGVyYCAoT2JqZWN0KSAtIGN1c3RvbSBoZWFkZXIgZm9yIGd6aXBcbiAqICAgLSBgdGV4dGAgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dFxuICogICAtIGB0aW1lYCAoTnVtYmVyKSAtIG1vZGlmaWNhdGlvbiB0aW1lLCB1bml4IHRpbWVzdGFtcFxuICogICAtIGBvc2AgKE51bWJlcikgLSBvcGVyYXRpb24gc3lzdGVtIGNvZGVcbiAqICAgLSBgZXh0cmFgIChBcnJheSkgLSBhcnJheSBvZiBieXRlcyB3aXRoIGV4dHJhIGRhdGEgKG1heCA2NTUzNilcbiAqICAgLSBgbmFtZWAgKFN0cmluZykgLSBmaWxlIG5hbWUgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGNvbW1lbnRgIChTdHJpbmcpIC0gY29tbWVudCAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgaGNyY2AgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBoZWFkZXIgY3JjIHNob3VsZCBiZSBhZGRlZFxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGNodW5rMSA9IG5ldyBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gbmV3IFVpbnQ4QXJyYXkoWzEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5XSk7XG4gKlxuICogY29uc3QgZGVmbGF0ZSA9IG5ldyBwYWtvLkRlZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGRlZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGRlZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGRlZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihkZWZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhkZWZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIERlZmxhdGUob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGxldmVsOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04sXG4gICAgbWV0aG9kOiBaX0RFRkxBVEVELFxuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMTUsXG4gICAgbWVtTGV2ZWw6IDgsXG4gICAgc3RyYXRlZ3k6IFpfREVGQVVMVF9TVFJBVEVHWVxuICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICBsZXQgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gIGlmIChvcHQucmF3ICYmIChvcHQud2luZG93Qml0cyA+IDApKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmIChvcHQuZ3ppcCAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAxNjtcbiAgfVxuXG4gIHRoaXMuZXJyICAgID0gMDsgICAgICAvLyBlcnJvciBjb2RlLCBpZiBoYXBwZW5zICgwID0gWl9PSylcbiAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxsc1xuICB0aGlzLmNodW5rcyA9IFtdOyAgICAgLy8gY2h1bmtzIG9mIGNvbXByZXNzZWQgZGF0YVxuXG4gIHRoaXMuc3RybSA9IG5ldyBaU3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIGxldCBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZUluaXQyKFxuICAgIHRoaXMuc3RybSxcbiAgICBvcHQubGV2ZWwsXG4gICAgb3B0Lm1ldGhvZCxcbiAgICBvcHQud2luZG93Qml0cyxcbiAgICBvcHQubWVtTGV2ZWwsXG4gICAgb3B0LnN0cmF0ZWd5XG4gICk7XG5cbiAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gIH1cblxuICBpZiAob3B0LmhlYWRlcikge1xuICAgIHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0SGVhZGVyKHRoaXMuc3RybSwgb3B0LmhlYWRlcik7XG4gIH1cblxuICBpZiAob3B0LmRpY3Rpb25hcnkpIHtcbiAgICBsZXQgZGljdDtcbiAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBvcHQuZGljdGlvbmFyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIElmIHdlIG5lZWQgdG8gY29tcHJlc3MgdGV4dCwgY2hhbmdlIGVuY29kaW5nIHRvIHV0ZjguXG4gICAgICBkaWN0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBkaWN0ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWN0ID0gb3B0LmRpY3Rpb25hcnk7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgZGljdCk7XG5cbiAgICBpZiAoc3RhdHVzICE9PSBaX09LKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICAgIH1cblxuICAgIHRoaXMuX2RpY3Rfc2V0ID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIERlZmxhdGUjcHVzaChkYXRhWywgZmx1c2hfbW9kZV0pIC0+IEJvb2xlYW5cbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheUJ1ZmZlcnxTdHJpbmcpOiBpbnB1dCBkYXRhLiBTdHJpbmdzIHdpbGwgYmVcbiAqICAgY29udmVydGVkIHRvIHV0ZjggYnl0ZSBzZXF1ZW5jZS5cbiAqIC0gZmx1c2hfbW9kZSAoTnVtYmVyfEJvb2xlYW4pOiAwLi42IGZvciBjb3JyZXNwb25kaW5nIFpfTk9fRkxVU0guLlpfVFJFRSBtb2Rlcy5cbiAqICAgU2VlIGNvbnN0YW50cy4gU2tpcHBlZCBvciBgZmFsc2VgIG1lYW5zIFpfTk9fRkxVU0gsIGB0cnVlYCBtZWFucyBaX0ZJTklTSC5cbiAqXG4gKiBTZW5kcyBpbnB1dCBkYXRhIHRvIGRlZmxhdGUgcGlwZSwgZ2VuZXJhdGluZyBbW0RlZmxhdGUjb25EYXRhXV0gY2FsbHMgd2l0aFxuICogbmV3IGNvbXByZXNzZWQgY2h1bmtzLiBSZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLiBUaGUgbGFzdCBkYXRhIGJsb2NrIG11c3RcbiAqIGhhdmUgYGZsdXNoX21vZGVgIFpfRklOSVNIIChvciBgdHJ1ZWApLiBUaGF0IHdpbGwgZmx1c2ggaW50ZXJuYWwgcGVuZGluZ1xuICogYnVmZmVycyBhbmQgY2FsbCBbW0RlZmxhdGUjb25FbmRdXS5cbiAqXG4gKiBPbiBmYWlsIGNhbGwgW1tEZWZsYXRlI29uRW5kXV0gd2l0aCBlcnJvciBjb2RlIGFuZCByZXR1cm4gZmFsc2UuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBmbHVzaF9tb2RlKSB7XG4gIGNvbnN0IHN0cm0gPSB0aGlzLnN0cm07XG4gIGNvbnN0IGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gIGxldCBzdGF0dXMsIF9mbHVzaF9tb2RlO1xuXG4gIGlmICh0aGlzLmVuZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChmbHVzaF9tb2RlID09PSB+fmZsdXNoX21vZGUpIF9mbHVzaF9tb2RlID0gZmx1c2hfbW9kZTtcbiAgZWxzZSBfZmx1c2hfbW9kZSA9IGZsdXNoX21vZGUgPT09IHRydWUgPyBaX0ZJTklTSCA6IFpfTk9fRkxVU0g7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZm9yICg7Oykge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgVWludDhBcnJheShjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgYXZhaWxfb3V0ID4gNiB0byBhdm9pZCByZXBlYXRpbmcgbWFya2Vyc1xuICAgIGlmICgoX2ZsdXNoX21vZGUgPT09IFpfU1lOQ19GTFVTSCB8fCBfZmx1c2hfbW9kZSA9PT0gWl9GVUxMX0ZMVVNIKSAmJiBzdHJtLmF2YWlsX291dCA8PSA2KSB7XG4gICAgICB0aGlzLm9uRGF0YShzdHJtLm91dHB1dC5zdWJhcnJheSgwLCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZShzdHJtLCBfZmx1c2hfbW9kZSk7XG5cbiAgICAvLyBFbmRlZCA9PiBmbHVzaCBhbmQgZmluaXNoXG4gICAgaWYgKHN0YXR1cyA9PT0gWl9TVFJFQU1fRU5EKSB7XG4gICAgICBpZiAoc3RybS5uZXh0X291dCA+IDApIHtcbiAgICAgICAgdGhpcy5vbkRhdGEoc3RybS5vdXRwdXQuc3ViYXJyYXkoMCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgfVxuICAgICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHN0YXR1cyA9PT0gWl9PSztcbiAgICB9XG5cbiAgICAvLyBGbHVzaCBpZiBvdXQgYnVmZmVyIGZ1bGxcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEZsdXNoIGlmIHJlcXVlc3RlZCBhbmQgaGFzIGRhdGFcbiAgICBpZiAoX2ZsdXNoX21vZGUgPiAwICYmIHN0cm0ubmV4dF9vdXQgPiAwKSB7XG4gICAgICB0aGlzLm9uRGF0YShzdHJtLm91dHB1dC5zdWJhcnJheSgwLCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCkgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBEZWZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheSk6IG91dHB1dCBkYXRhLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogZGVmbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgb25jZSBhZnRlciB5b3UgdGVsbCBkZWZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKS4gQnkgZGVmYXVsdCAtIGpvaW4gY29sbGVjdGVkIGNodW5rcyxcbiAqIGZyZWUgbWVtb3J5IGFuZCBmaWxsIGByZXN1bHRzYCAvIGBlcnJgIHByb3BlcnRpZXMuXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgLy8gT24gc3VjY2VzcyAtIGpvaW5cbiAgaWYgKHN0YXR1cyA9PT0gWl9PSykge1xuICAgIHRoaXMucmVzdWx0ID0gdXRpbHMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBkZWZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheVxuICogLSBkYXRhIChVaW50OEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIENvbXByZXNzIGBkYXRhYCB3aXRoIGRlZmxhdGUgYWxnb3JpdGhtIGFuZCBgb3B0aW9uc2AuXG4gKlxuICogU3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqIC0gbGV2ZWxcbiAqIC0gd2luZG93Qml0c1xuICogLSBtZW1MZXZlbFxuICogLSBzdHJhdGVneVxuICogLSBkaWN0aW9uYXJ5XG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pO1xuICpcbiAqIGNvbnNvbGUubG9nKHBha28uZGVmbGF0ZShkYXRhKSk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGVmbGF0b3IgPSBuZXcgRGVmbGF0ZShvcHRpb25zKTtcblxuICBkZWZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTtcblxuICAvLyBUaGF0IHdpbGwgbmV2ZXIgaGFwcGVucywgaWYgeW91IGRvbid0IGNoZWF0IHdpdGggb3B0aW9ucyA6KVxuICBpZiAoZGVmbGF0b3IuZXJyKSB7IHRocm93IGRlZmxhdG9yLm1zZyB8fCBtc2dbZGVmbGF0b3IuZXJyXTsgfVxuXG4gIHJldHVybiBkZWZsYXRvci5yZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBkZWZsYXRlUmF3KGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheVxuICogLSBkYXRhIChVaW50OEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbZGVmbGF0ZV1dLCBidXQgY3JlYXRlcyByYXcgZGF0YSwgd2l0aG91dCB3cmFwcGVyXG4gKiAoaGVhZGVyIGFuZCBhZGxlcjMyIGNyYykuXG4gKiovXG5mdW5jdGlvbiBkZWZsYXRlUmF3KGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnJhdyA9IHRydWU7XG4gIHJldHVybiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIGd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5XG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgb2ZcbiAqIGRlZmxhdGUgb25lLlxuICoqL1xuZnVuY3Rpb24gZ3ppcChpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5nemlwID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzLkRlZmxhdGUgPSBEZWZsYXRlO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlUmF3ID0gZGVmbGF0ZVJhdztcbm1vZHVsZS5leHBvcnRzLmd6aXAgPSBnemlwO1xubW9kdWxlLmV4cG9ydHMuY29uc3RhbnRzID0gcmVxdWlyZSgnLi96bGliL2NvbnN0YW50cycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbmNvbnN0IHpsaWJfaW5mbGF0ZSA9IHJlcXVpcmUoJy4vemxpYi9pbmZsYXRlJyk7XG5jb25zdCB1dGlscyAgICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL2NvbW1vbicpO1xuY29uc3Qgc3RyaW5ncyAgICAgID0gcmVxdWlyZSgnLi91dGlscy9zdHJpbmdzJyk7XG5jb25zdCBtc2cgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvbWVzc2FnZXMnKTtcbmNvbnN0IFpTdHJlYW0gICAgICA9IHJlcXVpcmUoJy4vemxpYi96c3RyZWFtJyk7XG5jb25zdCBHWmhlYWRlciAgICAgPSByZXF1aXJlKCcuL3psaWIvZ3poZWFkZXInKTtcblxuY29uc3QgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuY29uc3Qge1xuICBaX05PX0ZMVVNILCBaX0ZJTklTSCxcbiAgWl9PSywgWl9TVFJFQU1fRU5ELCBaX05FRURfRElDVCwgWl9TVFJFQU1fRVJST1IsIFpfREFUQV9FUlJPUiwgWl9NRU1fRVJST1Jcbn0gPSByZXF1aXJlKCcuL3psaWIvY29uc3RhbnRzJyk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyoqXG4gKiBjbGFzcyBJbmZsYXRlXG4gKlxuICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZFxuICogc3RyZWFtaW5nIGJlaGF2aW91ciAtIHVzZSBtb3JlIHNpbXBsZSBmdW5jdGlvbnM6IFtbaW5mbGF0ZV1dXG4gKiBhbmQgW1tpbmZsYXRlUmF3XV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBpbmZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tJbmZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZGVuLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXl8U3RyaW5nXG4gKlxuICogVW5jb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tJbmZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tJbmZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0luZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkuXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5lcnIgLT4gTnVtYmVyXG4gKlxuICogRXJyb3IgY29kZSBhZnRlciBpbmZsYXRlIGZpbmlzaGVkLiAwIChaX09LKSBvbiBzdWNjZXNzLlxuICogU2hvdWxkIGJlIGNoZWNrZWQgaWYgYnJva2VuIGRhdGEgcG9zc2libGUuXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5tc2cgLT4gU3RyaW5nXG4gKlxuICogRXJyb3IgbWVzc2FnZSwgaWYgW1tJbmZsYXRlLmVycl1dICE9IDBcbiAqKi9cblxuXG4vKipcbiAqIG5ldyBJbmZsYXRlKG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIENyZWF0ZXMgbmV3IGluZmxhdG9yIGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHBhcmFtcy4gVGhyb3dzIGV4Y2VwdGlvblxuICogb24gYmFkIHBhcmFtcy4gU3VwcG9ydGVkIG9wdGlvbnM6XG4gKlxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYGRpY3Rpb25hcnlgXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogQWRkaXRpb25hbCBvcHRpb25zLCBmb3IgaW50ZXJuYWwgbmVlZHM6XG4gKlxuICogLSBgY2h1bmtTaXplYCAtIHNpemUgb2YgZ2VuZXJhdGVkIGRhdGEgY2h1bmtzICgxNksgYnkgZGVmYXVsdClcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gZG8gcmF3IGluZmxhdGVcbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIGNvbnZlcnRlZFxuICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gKlxuICogQnkgZGVmYXVsdCwgd2hlbiBubyBvcHRpb25zIHNldCwgYXV0b2RldGVjdCBkZWZsYXRlL2d6aXAgZGF0YSBmb3JtYXQgdmlhXG4gKiB3cmFwcGVyIGhlYWRlci5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqIGNvbnN0IGNodW5rMSA9IG5ldyBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiBjb25zdCBjaHVuazIgPSBuZXcgVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiBjb25zdCBpbmZsYXRlID0gbmV3IHBha28uSW5mbGF0ZSh7IGxldmVsOiAzfSk7XG4gKlxuICogaW5mbGF0ZS5wdXNoKGNodW5rMSwgZmFsc2UpO1xuICogaW5mbGF0ZS5wdXNoKGNodW5rMiwgdHJ1ZSk7ICAvLyB0cnVlIC0+IGxhc3QgY2h1bmtcbiAqXG4gKiBpZiAoaW5mbGF0ZS5lcnIpIHsgdGhyb3cgbmV3IEVycm9yKGluZmxhdGUuZXJyKTsgfVxuICpcbiAqIGNvbnNvbGUubG9nKGluZmxhdGUucmVzdWx0KTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gSW5mbGF0ZShvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IHV0aWxzLmFzc2lnbih7XG4gICAgY2h1bmtTaXplOiAxMDI0ICogNjQsXG4gICAgd2luZG93Qml0czogMTUsXG4gICAgdG86ICcnXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIGNvbnN0IG9wdCA9IHRoaXMub3B0aW9ucztcblxuICAvLyBGb3JjZSB3aW5kb3cgc2l6ZSBmb3IgYHJhd2AgZGF0YSwgaWYgbm90IHNldCBkaXJlY3RseSxcbiAgLy8gYmVjYXVzZSB3ZSBoYXZlIG5vIGhlYWRlciBmb3IgYXV0b2RldGVjdC5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICAgIGlmIChvcHQud2luZG93Qml0cyA9PT0gMCkgeyBvcHQud2luZG93Qml0cyA9IC0xNTsgfVxuICB9XG5cbiAgLy8gSWYgYHdpbmRvd0JpdHNgIG5vdCBkZWZpbmVkIChhbmQgbW9kZSBub3QgcmF3KSAtIHNldCBhdXRvZGV0ZWN0IGZsYWcgZm9yIGd6aXAvZGVmbGF0ZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSAmJlxuICAgICAgIShvcHRpb25zICYmIG9wdGlvbnMud2luZG93Qml0cykpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAzMjtcbiAgfVxuXG4gIC8vIEd6aXAgaGVhZGVyIGhhcyBubyBpbmZvIGFib3V0IHdpbmRvd3Mgc2l6ZSwgd2UgY2FuIGRvIGF1dG9kZXRlY3Qgb25seVxuICAvLyBmb3IgZGVmbGF0ZS4gU28sIGlmIHdpbmRvdyBzaXplIG5vdCBzZXQsIGZvcmNlIGl0IHRvIG1heCB3aGVuIGd6aXAgcG9zc2libGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+IDE1KSAmJiAob3B0LndpbmRvd0JpdHMgPCA0OCkpIHtcbiAgICAvLyBiaXQgMyAoMTYpIC0+IGd6aXBwZWQgZGF0YVxuICAgIC8vIGJpdCA0ICgzMikgLT4gYXV0b2RldGVjdCBnemlwL2RlZmxhdGVcbiAgICBpZiAoKG9wdC53aW5kb3dCaXRzICYgMTUpID09PSAwKSB7XG4gICAgICBvcHQud2luZG93Qml0cyB8PSAxNTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gICA9IG5ldyBaU3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIGxldCBzdGF0dXMgID0gemxpYl9pbmZsYXRlLmluZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LndpbmRvd0JpdHNcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBaX09LKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgfVxuXG4gIHRoaXMuaGVhZGVyID0gbmV3IEdaaGVhZGVyKCk7XG5cbiAgemxpYl9pbmZsYXRlLmluZmxhdGVHZXRIZWFkZXIodGhpcy5zdHJtLCB0aGlzLmhlYWRlcik7XG5cbiAgLy8gU2V0dXAgZGljdGlvbmFyeVxuICBpZiAob3B0LmRpY3Rpb25hcnkpIHtcbiAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBvcHQuZGljdGlvbmFyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gc3RyaW5ncy5zdHJpbmcyYnVmKG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBvcHQuZGljdGlvbmFyeSA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9XG4gICAgaWYgKG9wdC5yYXcpIHsgLy9JbiByYXcgbW9kZSB3ZSBuZWVkIHRvIHNldCB0aGUgZGljdGlvbmFyeSBlYXJseVxuICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgb3B0LmRpY3Rpb25hcnkpO1xuICAgICAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEluZmxhdGUjcHVzaChkYXRhWywgZmx1c2hfbW9kZV0pIC0+IEJvb2xlYW5cbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheUJ1ZmZlcik6IGlucHV0IGRhdGFcbiAqIC0gZmx1c2hfbW9kZSAoTnVtYmVyfEJvb2xlYW4pOiAwLi42IGZvciBjb3JyZXNwb25kaW5nIFpfTk9fRkxVU0guLlpfVFJFRVxuICogICBmbHVzaCBtb2Rlcy4gU2VlIGNvbnN0YW50cy4gU2tpcHBlZCBvciBgZmFsc2VgIG1lYW5zIFpfTk9fRkxVU0gsXG4gKiAgIGB0cnVlYCBtZWFucyBaX0ZJTklTSC5cbiAqXG4gKiBTZW5kcyBpbnB1dCBkYXRhIHRvIGluZmxhdGUgcGlwZSwgZ2VuZXJhdGluZyBbW0luZmxhdGUjb25EYXRhXV0gY2FsbHMgd2l0aFxuICogbmV3IG91dHB1dCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIElmIGVuZCBvZiBzdHJlYW0gZGV0ZWN0ZWQsXG4gKiBbW0luZmxhdGUjb25FbmRdXSB3aWxsIGJlIGNhbGxlZC5cbiAqXG4gKiBgZmx1c2hfbW9kZWAgaXMgbm90IG5lZWRlZCBmb3Igbm9ybWFsIG9wZXJhdGlvbiwgYmVjYXVzZSBlbmQgb2Ygc3RyZWFtXG4gKiBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5LiBZb3UgbWF5IHRyeSB0byB1c2UgaXQgZm9yIGFkdmFuY2VkIHRoaW5ncywgYnV0XG4gKiB0aGlzIGZ1bmN0aW9uYWxpdHkgd2FzIG5vdCB0ZXN0ZWQuXG4gKlxuICogT24gZmFpbCBjYWxsIFtbSW5mbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgZmx1c2hfbW9kZSkge1xuICBjb25zdCBzdHJtID0gdGhpcy5zdHJtO1xuICBjb25zdCBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICBjb25zdCBkaWN0aW9uYXJ5ID0gdGhpcy5vcHRpb25zLmRpY3Rpb25hcnk7XG4gIGxldCBzdGF0dXMsIF9mbHVzaF9tb2RlLCBsYXN0X2F2YWlsX291dDtcblxuICBpZiAodGhpcy5lbmRlZCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChmbHVzaF9tb2RlID09PSB+fmZsdXNoX21vZGUpIF9mbHVzaF9tb2RlID0gZmx1c2hfbW9kZTtcbiAgZWxzZSBfZmx1c2hfbW9kZSA9IGZsdXNoX21vZGUgPT09IHRydWUgPyBaX0ZJTklTSCA6IFpfTk9fRkxVU0g7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBmb3IgKDs7KSB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyBVaW50OEFycmF5KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlKHN0cm0sIF9mbHVzaF9tb2RlKTtcblxuICAgIGlmIChzdGF0dXMgPT09IFpfTkVFRF9ESUNUICYmIGRpY3Rpb25hcnkpIHtcbiAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KTtcblxuICAgICAgaWYgKHN0YXR1cyA9PT0gWl9PSykge1xuICAgICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZShzdHJtLCBfZmx1c2hfbW9kZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gWl9EQVRBX0VSUk9SKSB7XG4gICAgICAgIC8vIFJlcGxhY2UgY29kZSB3aXRoIG1vcmUgdmVyYm9zZVxuICAgICAgICBzdGF0dXMgPSBaX05FRURfRElDVDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTa2lwIHNueWMgbWFya2VycyBpZiBtb3JlIGRhdGEgZm9sbG93cyBhbmQgbm90IHJhdyBtb2RlXG4gICAgd2hpbGUgKHN0cm0uYXZhaWxfaW4gPiAwICYmXG4gICAgICAgICAgIHN0YXR1cyA9PT0gWl9TVFJFQU1fRU5EICYmXG4gICAgICAgICAgIHN0cm0uc3RhdGUud3JhcCA+IDAgJiZcbiAgICAgICAgICAgZGF0YVtzdHJtLm5leHRfaW5dICE9PSAwKVxuICAgIHtcbiAgICAgIHpsaWJfaW5mbGF0ZS5pbmZsYXRlUmVzZXQoc3RybSk7XG4gICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZShzdHJtLCBfZmx1c2hfbW9kZSk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgIGNhc2UgWl9TVFJFQU1fRVJST1I6XG4gICAgICBjYXNlIFpfREFUQV9FUlJPUjpcbiAgICAgIGNhc2UgWl9ORUVEX0RJQ1Q6XG4gICAgICBjYXNlIFpfTUVNX0VSUk9SOlxuICAgICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gUmVtZW1iZXIgcmVhbCBgYXZhaWxfb3V0YCB2YWx1ZSwgYmVjYXVzZSB3ZSBtYXkgcGF0Y2ggb3V0IGJ1ZmZlciBjb250ZW50XG4gICAgLy8gdG8gYWxpZ24gdXRmOCBzdHJpbmdzIGJvdW5kYXJpZXMuXG4gICAgbGFzdF9hdmFpbF9vdXQgPSBzdHJtLmF2YWlsX291dDtcblxuICAgIGlmIChzdHJtLm5leHRfb3V0KSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgc3RhdHVzID09PSBaX1NUUkVBTV9FTkQpIHtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgbGV0IG5leHRfb3V0X3V0ZjggPSBzdHJpbmdzLnV0Zjhib3JkZXIoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpO1xuXG4gICAgICAgICAgbGV0IHRhaWwgPSBzdHJtLm5leHRfb3V0IC0gbmV4dF9vdXRfdXRmODtcbiAgICAgICAgICBsZXQgdXRmOHN0ciA9IHN0cmluZ3MuYnVmMnN0cmluZyhzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCk7XG5cbiAgICAgICAgICAvLyBtb3ZlIHRhaWwgJiByZWFsaWduIGNvdW50ZXJzXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHRhaWw7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemUgLSB0YWlsO1xuICAgICAgICAgIGlmICh0YWlsKSBzdHJtLm91dHB1dC5zZXQoc3RybS5vdXRwdXQuc3ViYXJyYXkobmV4dF9vdXRfdXRmOCwgbmV4dF9vdXRfdXRmOCArIHRhaWwpLCAwKTtcblxuICAgICAgICAgIHRoaXMub25EYXRhKHV0ZjhzdHIpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbkRhdGEoc3RybS5vdXRwdXQubGVuZ3RoID09PSBzdHJtLm5leHRfb3V0ID8gc3RybS5vdXRwdXQgOiBzdHJtLm91dHB1dC5zdWJhcnJheSgwLCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNdXN0IHJlcGVhdCBpdGVyYXRpb24gaWYgb3V0IGJ1ZmZlciBpcyBmdWxsXG4gICAgaWYgKHN0YXR1cyA9PT0gWl9PSyAmJiBsYXN0X2F2YWlsX291dCA9PT0gMCkgY29udGludWU7XG5cbiAgICAvLyBGaW5hbGl6ZSBpZiBlbmQgb2Ygc3RyZWFtIHJlYWNoZWQuXG4gICAgaWYgKHN0YXR1cyA9PT0gWl9TVFJFQU1fRU5EKSB7XG4gICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCkgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBJbmZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheXxTdHJpbmcpOiBvdXRwdXQgZGF0YS4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgZWFjaCBjaHVuayB3aWxsIGJlIHN0cmluZy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbn07XG5cblxuLyoqXG4gKiBJbmZsYXRlI29uRW5kKHN0YXR1cykgLT4gVm9pZFxuICogLSBzdGF0dXMgKE51bWJlcik6IGluZmxhdGUgc3RhdHVzLiAwIChaX09LKSBvbiBzdWNjZXNzLFxuICogICBvdGhlciBpZiBub3QuXG4gKlxuICogQ2FsbGVkIGVpdGhlciBhZnRlciB5b3UgdGVsbCBpbmZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKS4gQnkgZGVmYXVsdCAtIGpvaW4gY29sbGVjdGVkIGNodW5rcyxcbiAqIGZyZWUgbWVtb3J5IGFuZCBmaWxsIGByZXN1bHRzYCAvIGBlcnJgIHByb3BlcnRpZXMuXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgLy8gT24gc3VjY2VzcyAtIGpvaW5cbiAgaWYgKHN0YXR1cyA9PT0gWl9PSykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHV0aWxzLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpO1xuICAgIH1cbiAgfVxuICB0aGlzLmNodW5rcyA9IFtdO1xuICB0aGlzLmVyciA9IHN0YXR1cztcbiAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnO1xufTtcblxuXG4vKipcbiAqIGluZmxhdGUoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5KTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBEZWNvbXByZXNzIGBkYXRhYCB3aXRoIGluZmxhdGUvdW5nemlwIGFuZCBgb3B0aW9uc2AuIEF1dG9kZXRlY3RcbiAqIGZvcm1hdCB2aWEgd3JhcHBlciBoZWFkZXIgYnkgZGVmYXVsdC4gVGhhdCdzIHdoeSB3ZSBkb24ndCBwcm92aWRlXG4gKiBzZXBhcmF0ZSBgdW5nemlwYCBtZXRob2QuXG4gKlxuICogU3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqIC0gd2luZG93Qml0c1xuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIGNvbnZlcnRlZFxuICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gKlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKTtcbiAqIGNvbnN0IGlucHV0ID0gcGFrby5kZWZsYXRlKG5ldyBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pKTtcbiAqIGxldCBvdXRwdXQ7XG4gKlxuICogdHJ5IHtcbiAqICAgb3V0cHV0ID0gcGFrby5pbmZsYXRlKGlucHV0KTtcbiAqIH0gY2F0Y2ggKGVycilcbiAqICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH1cbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucykge1xuICBjb25zdCBpbmZsYXRvciA9IG5ldyBJbmZsYXRlKG9wdGlvbnMpO1xuXG4gIGluZmxhdG9yLnB1c2goaW5wdXQpO1xuXG4gIC8vIFRoYXQgd2lsbCBuZXZlciBoYXBwZW5zLCBpZiB5b3UgZG9uJ3QgY2hlYXQgd2l0aCBvcHRpb25zIDopXG4gIGlmIChpbmZsYXRvci5lcnIpIHRocm93IGluZmxhdG9yLm1zZyB8fCBtc2dbaW5mbGF0b3IuZXJyXTtcblxuICByZXR1cm4gaW5mbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogaW5mbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXkpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbaW5mbGF0ZV1dLCBidXQgY3JlYXRlcyByYXcgZGF0YSwgd2l0aG91dCB3cmFwcGVyXG4gKiAoaGVhZGVyIGFuZCBhZGxlcjMyIGNyYykuXG4gKiovXG5mdW5jdGlvbiBpbmZsYXRlUmF3KGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnJhdyA9IHRydWU7XG4gIHJldHVybiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIHVuZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXkpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIEp1c3Qgc2hvcnRjdXQgdG8gW1tpbmZsYXRlXV0sIGJlY2F1c2UgaXQgYXV0b2RldGVjdHMgZm9ybWF0XG4gKiBieSBoZWFkZXIuY29udGVudC4gRG9uZSBmb3IgY29udmVuaWVuY2UuXG4gKiovXG5cblxubW9kdWxlLmV4cG9ydHMuSW5mbGF0ZSA9IEluZmxhdGU7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVSYXcgPSBpbmZsYXRlUmF3O1xubW9kdWxlLmV4cG9ydHMudW5nemlwID0gaW5mbGF0ZTtcbm1vZHVsZS5leHBvcnRzLmNvbnN0YW50cyA9IHJlcXVpcmUoJy4vemxpYi9jb25zdGFudHMnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG5jb25zdCBfaGFzID0gKG9iaiwga2V5KSA9PiB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuYXNzaWduID0gZnVuY3Rpb24gKG9iaiAvKmZyb20xLCBmcm9tMiwgZnJvbTMsIC4uLiovKSB7XG4gIGNvbnN0IHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7XG4gICAgaWYgKCFzb3VyY2UpIHsgY29udGludWU7IH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyAnbXVzdCBiZSBub24tb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBwIGluIHNvdXJjZSkge1xuICAgICAgaWYgKF9oYXMoc291cmNlLCBwKSkge1xuICAgICAgICBvYmpbcF0gPSBzb3VyY2VbcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cblxuLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxubW9kdWxlLmV4cG9ydHMuZmxhdHRlbkNodW5rcyA9IChjaHVua3MpID0+IHtcbiAgLy8gY2FsY3VsYXRlIGRhdGEgbGVuZ3RoXG4gIGxldCBsZW4gPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGxlbiArPSBjaHVua3NbaV0ubGVuZ3RoO1xuICB9XG5cbiAgLy8gam9pbiBjaHVua3NcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcblxuICBmb3IgKGxldCBpID0gMCwgcG9zID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBsZXQgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgcmVzdWx0LnNldChjaHVuaywgcG9zKTtcbiAgICBwb3MgKz0gY2h1bmsubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyBTdHJpbmcgZW5jb2RlL2RlY29kZSBoZWxwZXJzXG4ndXNlIHN0cmljdCc7XG5cblxuLy8gUXVpY2sgY2hlY2sgaWYgd2UgY2FuIHVzZSBmYXN0IGFycmF5IHRvIGJpbiBzdHJpbmcgY29udmVyc2lvblxuLy9cbi8vIC0gYXBwbHkoQXJyYXkpIGNhbiBmYWlsIG9uIEFuZHJvaWQgMi4yXG4vLyAtIGFwcGx5KFVpbnQ4QXJyYXkpIGNhbiBmYWlsIG9uIGlPUyA1LjEgU2FmYXJpXG4vL1xubGV0IFNUUl9BUFBMWV9VSUFfT0sgPSB0cnVlO1xuXG50cnkgeyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KDEpKTsgfSBjYXRjaCAoX18pIHsgU1RSX0FQUExZX1VJQV9PSyA9IGZhbHNlOyB9XG5cblxuLy8gVGFibGUgd2l0aCB1dGY4IGxlbmd0aHMgKGNhbGN1bGF0ZWQgYnkgZmlyc3QgYnl0ZSBvZiBzZXF1ZW5jZSlcbi8vIE5vdGUsIHRoYXQgNSAmIDYtYnl0ZSB2YWx1ZXMgYW5kIHNvbWUgNC1ieXRlIHZhbHVlcyBjYW4gbm90IGJlIHJlcHJlc2VudGVkIGluIEpTLFxuLy8gYmVjYXVzZSBtYXggcG9zc2libGUgY29kZXBvaW50IGlzIDB4MTBmZmZmXG5jb25zdCBfdXRmOGxlbiA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG5mb3IgKGxldCBxID0gMDsgcSA8IDI1NjsgcSsrKSB7XG4gIF91dGY4bGVuW3FdID0gKHEgPj0gMjUyID8gNiA6IHEgPj0gMjQ4ID8gNSA6IHEgPj0gMjQwID8gNCA6IHEgPj0gMjI0ID8gMyA6IHEgPj0gMTkyID8gMiA6IDEpO1xufVxuX3V0ZjhsZW5bMjU0XSA9IF91dGY4bGVuWzI1NF0gPSAxOyAvLyBJbnZhbGlkIHNlcXVlbmNlIHN0YXJ0XG5cblxuLy8gY29udmVydCBzdHJpbmcgdG8gYXJyYXkgKHR5cGVkLCB3aGVuIHBvc3NpYmxlKVxubW9kdWxlLmV4cG9ydHMuc3RyaW5nMmJ1ZiA9IChzdHIpID0+IHtcbiAgbGV0IGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7XG5cbiAgLy8gY291bnQgYmluYXJ5IHNpemVcbiAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgYnVmX2xlbiArPSBjIDwgMHg4MCA/IDEgOiBjIDwgMHg4MDAgPyAyIDogYyA8IDB4MTAwMDAgPyAzIDogNDtcbiAgfVxuXG4gIC8vIGFsbG9jYXRlIGJ1ZmZlclxuICBidWYgPSBuZXcgVWludDhBcnJheShidWZfbGVuKTtcblxuICAvLyBjb252ZXJ0XG4gIGZvciAoaSA9IDAsIG1fcG9zID0gMDsgaSA8IGJ1Zl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgLyogb25lIGJ5dGUgKi9cbiAgICAgIGJ1ZltpKytdID0gYztcbiAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4QzAgfCAoYyA+Pj4gNik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIC8qIHRocmVlIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4RTAgfCAoYyA+Pj4gMTIpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGZvdXIgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhmMCB8IChjID4+PiAxOCk7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gMTIgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWY7XG59O1xuXG4vLyBIZWxwZXJcbmNvbnN0IGJ1ZjJiaW5zdHJpbmcgPSAoYnVmLCBsZW4pID0+IHtcbiAgLy8gT24gQ2hyb21lLCB0aGUgYXJndW1lbnRzIGluIGEgZnVuY3Rpb24gY2FsbCB0aGF0IGFyZSBhbGxvd2VkIGlzIGA2NTUzNGAuXG4gIC8vIElmIHRoZSBsZW5ndGggb2YgdGhlIGJ1ZmZlciBpcyBzbWFsbGVyIHRoYW4gdGhhdCwgd2UgY2FuIHVzZSB0aGlzIG9wdGltaXphdGlvbixcbiAgLy8gb3RoZXJ3aXNlIHdlIHdpbGwgdGFrZSBhIHNsb3dlciBwYXRoLlxuICBpZiAobGVuIDwgNjU1MzQpIHtcbiAgICBpZiAoYnVmLnN1YmFycmF5ICYmIFNUUl9BUFBMWV9VSUFfT0spIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ1Zi5sZW5ndGggPT09IGxlbiA/IGJ1ZiA6IGJ1Zi5zdWJhcnJheSgwLCBsZW4pKTtcbiAgICB9XG4gIH1cblxuICBsZXQgcmVzdWx0ID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8vIGNvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG5tb2R1bGUuZXhwb3J0cy5idWYyc3RyaW5nID0gKGJ1ZiwgbWF4KSA9PiB7XG4gIGxldCBpLCBvdXQ7XG4gIGNvbnN0IGxlbiA9IG1heCB8fCBidWYubGVuZ3RoO1xuXG4gIC8vIFJlc2VydmUgbWF4IHBvc3NpYmxlIGxlbmd0aCAoMiB3b3JkcyBwZXIgY2hhcilcbiAgLy8gTkI6IGJ5IHVua25vd24gcmVhc29ucywgQXJyYXkgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgZm9yXG4gIC8vICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5IHRoYW4gVWludDE2QXJyYXkuXG4gIGNvbnN0IHV0ZjE2YnVmID0gbmV3IEFycmF5KGxlbiAqIDIpO1xuXG4gIGZvciAob3V0ID0gMCwgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgbGV0IGMgPSBidWZbaSsrXTtcbiAgICAvLyBxdWljayBwcm9jZXNzIGFzY2lpXG4gICAgaWYgKGMgPCAweDgwKSB7IHV0ZjE2YnVmW291dCsrXSA9IGM7IGNvbnRpbnVlOyB9XG5cbiAgICBsZXQgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAvLyBza2lwIDUgJiA2IGJ5dGUgY29kZXNcbiAgICBpZiAoY19sZW4gPiA0KSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgaSArPSBjX2xlbiAtIDE7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBhcHBseSBtYXNrIG9uIGZpcnN0IGJ5dGVcbiAgICBjICY9IGNfbGVuID09PSAyID8gMHgxZiA6IGNfbGVuID09PSAzID8gMHgwZiA6IDB4MDc7XG4gICAgLy8gam9pbiB0aGUgcmVzdFxuICAgIHdoaWxlIChjX2xlbiA+IDEgJiYgaSA8IGxlbikge1xuICAgICAgYyA9IChjIDw8IDYpIHwgKGJ1ZltpKytdICYgMHgzZik7XG4gICAgICBjX2xlbi0tO1xuICAgIH1cblxuICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz9cbiAgICBpZiAoY19sZW4gPiAxKSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgY29udGludWU7IH1cblxuICAgIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgYyAtPSAweDEwMDAwO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkODAwIHwgKChjID4+IDEwKSAmIDB4M2ZmKTtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYyYmluc3RyaW5nKHV0ZjE2YnVmLCBvdXQpO1xufTtcblxuXG4vLyBDYWxjdWxhdGUgbWF4IHBvc3NpYmxlIHBvc2l0aW9uIGluIHV0ZjggYnVmZmVyLFxuLy8gdGhhdCB3aWxsIG5vdCBicmVhayBzZXF1ZW5jZS4gSWYgdGhhdCdzIG5vdCBwb3NzaWJsZVxuLy8gLSAodmVyeSBzbWFsbCBsaW1pdHMpIHJldHVybiBtYXggc2l6ZSBhcyBpcy5cbi8vXG4vLyBidWZbXSAtIHV0ZjggYnl0ZXMgYXJyYXlcbi8vIG1heCAgIC0gbGVuZ3RoIGxpbWl0IChtYW5kYXRvcnkpO1xubW9kdWxlLmV4cG9ydHMudXRmOGJvcmRlciA9IChidWYsIG1heCkgPT4ge1xuXG4gIG1heCA9IG1heCB8fCBidWYubGVuZ3RoO1xuICBpZiAobWF4ID4gYnVmLmxlbmd0aCkgeyBtYXggPSBidWYubGVuZ3RoOyB9XG5cbiAgLy8gZ28gYmFjayBmcm9tIGxhc3QgcG9zaXRpb24sIHVudGlsIHN0YXJ0IG9mIHNlcXVlbmNlIGZvdW5kXG4gIGxldCBwb3MgPSBtYXggLSAxO1xuICB3aGlsZSAocG9zID49IDAgJiYgKGJ1Zltwb3NdICYgMHhDMCkgPT09IDB4ODApIHsgcG9zLS07IH1cblxuICAvLyBWZXJ5IHNtYWxsIGFuZCBicm9rZW4gc2VxdWVuY2UsXG4gIC8vIHJldHVybiBtYXgsIGJlY2F1c2Ugd2Ugc2hvdWxkIHJldHVybiBzb21ldGhpbmcgYW55d2F5LlxuICBpZiAocG9zIDwgMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgLy8gSWYgd2UgY2FtZSB0byBzdGFydCBvZiBidWZmZXIgLSB0aGF0IG1lYW5zIGJ1ZmZlciBpcyB0b28gc21hbGwsXG4gIC8vIHJldHVybiBtYXggdG9vLlxuICBpZiAocG9zID09PSAwKSB7IHJldHVybiBtYXg7IH1cblxuICByZXR1cm4gKHBvcyArIF91dGY4bGVuW2J1Zltwb3NdXSA+IG1heCkgPyBwb3MgOiBtYXg7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiBhZGxlcjMyIHRha2VzIDEyJSBmb3IgbGV2ZWwgMCBhbmQgMiUgZm9yIGxldmVsIDYuXG4vLyBJdCBpc24ndCB3b3J0aCBpdCB0byBtYWtlIGFkZGl0aW9uYWwgb3B0aW1pemF0aW9ucyBhcyBpbiBvcmlnaW5hbC5cbi8vIFNtYWxsIHNpemUgaXMgcHJlZmVyYWJsZS5cblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5jb25zdCBhZGxlcjMyID0gKGFkbGVyLCBidWYsIGxlbiwgcG9zKSA9PiB7XG4gIGxldCBzMSA9IChhZGxlciAmIDB4ZmZmZikgfDAsXG4gICAgICBzMiA9ICgoYWRsZXIgPj4+IDE2KSAmIDB4ZmZmZikgfDAsXG4gICAgICBuID0gMDtcblxuICB3aGlsZSAobGVuICE9PSAwKSB7XG4gICAgLy8gU2V0IGxpbWl0IH4gdHdpY2UgbGVzcyB0aGFuIDU1NTIsIHRvIGtlZXBcbiAgICAvLyBzMiBpbiAzMS1iaXRzLCBiZWNhdXNlIHdlIGZvcmNlIHNpZ25lZCBpbnRzLlxuICAgIC8vIGluIG90aGVyIGNhc2UgJT0gd2lsbCBmYWlsLlxuICAgIG4gPSBsZW4gPiAyMDAwID8gMjAwMCA6IGxlbjtcbiAgICBsZW4gLT0gbjtcblxuICAgIGRvIHtcbiAgICAgIHMxID0gKHMxICsgYnVmW3BvcysrXSkgfDA7XG4gICAgICBzMiA9IChzMiArIHMxKSB8MDtcbiAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgczEgJT0gNjU1MjE7XG4gICAgczIgJT0gNjU1MjE7XG4gIH1cblxuICByZXR1cm4gKHMxIHwgKHMyIDw8IDE2KSkgfDA7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4gIFpfTk9fRkxVU0g6ICAgICAgICAgMCxcbiAgWl9QQVJUSUFMX0ZMVVNIOiAgICAxLFxuICBaX1NZTkNfRkxVU0g6ICAgICAgIDIsXG4gIFpfRlVMTF9GTFVTSDogICAgICAgMyxcbiAgWl9GSU5JU0g6ICAgICAgICAgICA0LFxuICBaX0JMT0NLOiAgICAgICAgICAgIDUsXG4gIFpfVFJFRVM6ICAgICAgICAgICAgNixcblxuICAvKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICAqL1xuICBaX09LOiAgICAgICAgICAgICAgIDAsXG4gIFpfU1RSRUFNX0VORDogICAgICAgMSxcbiAgWl9ORUVEX0RJQ1Q6ICAgICAgICAyLFxuICBaX0VSUk5POiAgICAgICAgICAgLTEsXG4gIFpfU1RSRUFNX0VSUk9SOiAgICAtMixcbiAgWl9EQVRBX0VSUk9SOiAgICAgIC0zLFxuICBaX01FTV9FUlJPUjogICAgICAgLTQsXG4gIFpfQlVGX0VSUk9SOiAgICAgICAtNSxcbiAgLy9aX1ZFUlNJT05fRVJST1I6IC02LFxuXG4gIC8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuICBaX05PX0NPTVBSRVNTSU9OOiAgICAgICAgIDAsXG4gIFpfQkVTVF9TUEVFRDogICAgICAgICAgICAgMSxcbiAgWl9CRVNUX0NPTVBSRVNTSU9OOiAgICAgICA5LFxuICBaX0RFRkFVTFRfQ09NUFJFU1NJT046ICAgLTEsXG5cblxuICBaX0ZJTFRFUkVEOiAgICAgICAgICAgICAgIDEsXG4gIFpfSFVGRk1BTl9PTkxZOiAgICAgICAgICAgMixcbiAgWl9STEU6ICAgICAgICAgICAgICAgICAgICAzLFxuICBaX0ZJWEVEOiAgICAgICAgICAgICAgICAgIDQsXG4gIFpfREVGQVVMVF9TVFJBVEVHWTogICAgICAgMCxcblxuICAvKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4gIFpfQklOQVJZOiAgICAgICAgICAgICAgICAgMCxcbiAgWl9URVhUOiAgICAgICAgICAgICAgICAgICAxLFxuICAvL1pfQVNDSUk6ICAgICAgICAgICAgICAgIDEsIC8vID0gWl9URVhUIChkZXByZWNhdGVkKVxuICBaX1VOS05PV046ICAgICAgICAgICAgICAgIDIsXG5cbiAgLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG4gIFpfREVGTEFURUQ6ICAgICAgICAgICAgICAgOFxuICAvL1pfTlVMTDogICAgICAgICAgICAgICAgIG51bGwgLy8gVXNlIC0xIG9yIG51bGwgaW5saW5lLCBkZXBlbmRpbmcgb24gdmFyIHR5cGVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IHdlIGNhbid0IGdldCBzaWduaWZpY2FudCBzcGVlZCBib29zdCBoZXJlLlxuLy8gU28gd3JpdGUgY29kZSB0byBtaW5pbWl6ZSBzaXplIC0gbm8gcHJlZ2VuZXJhdGVkIHRhYmxlc1xuLy8gYW5kIGFycmF5IHRvb2xzIGRlcGVuZGVuY2llcy5cblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuY29uc3QgbWFrZVRhYmxlID0gKCkgPT4ge1xuICBsZXQgYywgdGFibGUgPSBbXTtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IDI1NjsgbisrKSB7XG4gICAgYyA9IG47XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGMgPSAoKGMgJiAxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgfVxuICAgIHRhYmxlW25dID0gYztcbiAgfVxuXG4gIHJldHVybiB0YWJsZTtcbn07XG5cbi8vIENyZWF0ZSB0YWJsZSBvbiBsb2FkLiBKdXN0IDI1NSBzaWduZWQgbG9uZ3MuIE5vdCBhIHByb2JsZW0uXG5jb25zdCBjcmNUYWJsZSA9IG5ldyBVaW50MzJBcnJheShtYWtlVGFibGUoKSk7XG5cblxuY29uc3QgY3JjMzIgPSAoY3JjLCBidWYsIGxlbiwgcG9zKSA9PiB7XG4gIGNvbnN0IHQgPSBjcmNUYWJsZTtcbiAgY29uc3QgZW5kID0gcG9zICsgbGVuO1xuXG4gIGNyYyBePSAtMTtcblxuICBmb3IgKGxldCBpID0gcG9zOyBpIDwgZW5kOyBpKyspIHtcbiAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgfVxuXG4gIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyYzMyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmNvbnN0IHsgX3RyX2luaXQsIF90cl9zdG9yZWRfYmxvY2ssIF90cl9mbHVzaF9ibG9jaywgX3RyX3RhbGx5LCBfdHJfYWxpZ24gfSA9IHJlcXVpcmUoJy4vdHJlZXMnKTtcbmNvbnN0IGFkbGVyMzIgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbmNvbnN0IGNyYzMyICAgPSByZXF1aXJlKCcuL2NyYzMyJyk7XG5jb25zdCBtc2cgICAgID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuY29uc3Qge1xuICBaX05PX0ZMVVNILCBaX1BBUlRJQUxfRkxVU0gsIFpfRlVMTF9GTFVTSCwgWl9GSU5JU0gsIFpfQkxPQ0ssXG4gIFpfT0ssIFpfU1RSRUFNX0VORCwgWl9TVFJFQU1fRVJST1IsIFpfREFUQV9FUlJPUiwgWl9CVUZfRVJST1IsXG4gIFpfREVGQVVMVF9DT01QUkVTU0lPTixcbiAgWl9GSUxURVJFRCwgWl9IVUZGTUFOX09OTFksIFpfUkxFLCBaX0ZJWEVELCBaX0RFRkFVTFRfU1RSQVRFR1ksXG4gIFpfVU5LTk9XTixcbiAgWl9ERUZMQVRFRFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuY29uc3QgTUFYX01FTV9MRVZFTCA9IDk7XG4vKiBNYXhpbXVtIHZhbHVlIGZvciBtZW1MZXZlbCBpbiBkZWZsYXRlSW5pdDIgKi9cbmNvbnN0IE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG5jb25zdCBERUZfTUVNX0xFVkVMID0gODtcblxuXG5jb25zdCBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cbmNvbnN0IExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cbmNvbnN0IExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cbmNvbnN0IERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuY29uc3QgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG5jb25zdCBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cbmNvbnN0IE1BWF9CSVRTICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbmNvbnN0IE1JTl9NQVRDSCA9IDM7XG5jb25zdCBNQVhfTUFUQ0ggPSAyNTg7XG5jb25zdCBNSU5fTE9PS0FIRUFEID0gKE1BWF9NQVRDSCArIE1JTl9NQVRDSCArIDEpO1xuXG5jb25zdCBQUkVTRVRfRElDVCA9IDB4MjA7XG5cbmNvbnN0IElOSVRfU1RBVEUgPSA0MjtcbmNvbnN0IEVYVFJBX1NUQVRFID0gNjk7XG5jb25zdCBOQU1FX1NUQVRFID0gNzM7XG5jb25zdCBDT01NRU5UX1NUQVRFID0gOTE7XG5jb25zdCBIQ1JDX1NUQVRFID0gMTAzO1xuY29uc3QgQlVTWV9TVEFURSA9IDExMztcbmNvbnN0IEZJTklTSF9TVEFURSA9IDY2NjtcblxuY29uc3QgQlNfTkVFRF9NT1JFICAgICAgPSAxOyAvKiBibG9jayBub3QgY29tcGxldGVkLCBuZWVkIG1vcmUgaW5wdXQgb3IgbW9yZSBvdXRwdXQgKi9cbmNvbnN0IEJTX0JMT0NLX0RPTkUgICAgID0gMjsgLyogYmxvY2sgZmx1c2ggcGVyZm9ybWVkICovXG5jb25zdCBCU19GSU5JU0hfU1RBUlRFRCA9IDM7IC8qIGZpbmlzaCBzdGFydGVkLCBuZWVkIG9ubHkgbW9yZSBvdXRwdXQgYXQgbmV4dCBkZWZsYXRlICovXG5jb25zdCBCU19GSU5JU0hfRE9ORSAgICA9IDQ7IC8qIGZpbmlzaCBkb25lLCBhY2NlcHQgbm8gbW9yZSBpbnB1dCBvciBvdXRwdXQgKi9cblxuY29uc3QgT1NfQ09ERSA9IDB4MDM7IC8vIFVuaXggOikgLiBEb24ndCBkZXRlY3QsIHVzZSB0aGlzIGRlZmF1bHQuXG5cbmNvbnN0IGVyciA9IChzdHJtLCBlcnJvckNvZGUpID0+IHtcbiAgc3RybS5tc2cgPSBtc2dbZXJyb3JDb2RlXTtcbiAgcmV0dXJuIGVycm9yQ29kZTtcbn07XG5cbmNvbnN0IHJhbmsgPSAoZikgPT4ge1xuICByZXR1cm4gKChmKSA8PCAxKSAtICgoZikgPiA0ID8gOSA6IDApO1xufTtcblxuY29uc3QgemVybyA9IChidWYpID0+IHtcbiAgbGV0IGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfVxufTtcblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovXG5sZXQgSEFTSF9aTElCID0gKHMsIHByZXYsIGRhdGEpID0+ICgocHJldiA8PCBzLmhhc2hfc2hpZnQpIF4gZGF0YSkgJiBzLmhhc2hfbWFzaztcbi8vIFRoaXMgaGFzaCBjYXVzZXMgbGVzcyBjb2xsaXNpb25zLCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL3Bha28vaXNzdWVzLzEzNVxuLy8gQnV0IGJyZWFrcyBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy9sZXQgSEFTSF9GQVNUID0gKHMsIHByZXYsIGRhdGEpID0+ICgocHJldiA8PCA4KSArIChwcmV2ID4+IDgpICsgKGRhdGEgPDwgNCkpICYgcy5oYXNoX21hc2s7XG5sZXQgSEFTSCA9IEhBU0hfWkxJQjtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZS4gQWxsIGRlZmxhdGUoKSBvdXRwdXQgZ29lc1xuICogdGhyb3VnaCB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdFxuICogdG8gYXZvaWQgYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPm91dHB1dCBidWZmZXIgYW5kIGNvcHlpbmcgaW50byBpdC5cbiAqIChTZWUgYWxzbyByZWFkX2J1ZigpKS5cbiAqL1xuY29uc3QgZmx1c2hfcGVuZGluZyA9IChzdHJtKSA9PiB7XG4gIGNvbnN0IHMgPSBzdHJtLnN0YXRlO1xuXG4gIC8vX3RyX2ZsdXNoX2JpdHMocyk7XG4gIGxldCBsZW4gPSBzLnBlbmRpbmc7XG4gIGlmIChsZW4gPiBzdHJtLmF2YWlsX291dCkge1xuICAgIGxlbiA9IHN0cm0uYXZhaWxfb3V0O1xuICB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgc3RybS5vdXRwdXQuc2V0KHMucGVuZGluZ19idWYuc3ViYXJyYXkocy5wZW5kaW5nX291dCwgcy5wZW5kaW5nX291dCArIGxlbiksIHN0cm0ubmV4dF9vdXQpO1xuICBzdHJtLm5leHRfb3V0ICs9IGxlbjtcbiAgcy5wZW5kaW5nX291dCArPSBsZW47XG4gIHN0cm0udG90YWxfb3V0ICs9IGxlbjtcbiAgc3RybS5hdmFpbF9vdXQgLT0gbGVuO1xuICBzLnBlbmRpbmcgLT0gbGVuO1xuICBpZiAocy5wZW5kaW5nID09PSAwKSB7XG4gICAgcy5wZW5kaW5nX291dCA9IDA7XG4gIH1cbn07XG5cblxuY29uc3QgZmx1c2hfYmxvY2tfb25seSA9IChzLCBsYXN0KSA9PiB7XG4gIF90cl9mbHVzaF9ibG9jayhzLCAocy5ibG9ja19zdGFydCA+PSAwID8gcy5ibG9ja19zdGFydCA6IC0xKSwgcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQsIGxhc3QpO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgZmx1c2hfcGVuZGluZyhzLnN0cm0pO1xufTtcblxuXG5jb25zdCBwdXRfYnl0ZSA9IChzLCBiKSA9PiB7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYjtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUHV0IGEgc2hvcnQgaW4gdGhlIHBlbmRpbmcgYnVmZmVyLiBUaGUgMTYtYml0IHZhbHVlIGlzIHB1dCBpbiBNU0Igb3JkZXIuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBzdHJlYW0gc3RhdGUgaXMgY29ycmVjdCBhbmQgdGhlcmUgaXMgZW5vdWdoIHJvb20gaW5cbiAqIHBlbmRpbmdfYnVmLlxuICovXG5jb25zdCBwdXRTaG9ydE1TQiA9IChzLCBiKSA9PiB7XG5cbiAgLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiID4+IDgpKTtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiAmIDB4ZmYpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAoYiA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGIgJiAweGZmO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlYWQgYSBuZXcgYnVmZmVyIGZyb20gdGhlIGN1cnJlbnQgaW5wdXQgc3RyZWFtLCB1cGRhdGUgdGhlIGFkbGVyMzJcbiAqIGFuZCB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC4gIEFsbCBkZWZsYXRlKCkgaW5wdXQgZ29lcyB0aHJvdWdoXG4gKiB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdCB0byBhdm9pZFxuICogYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPmlucHV0IGJ1ZmZlciBhbmQgY29weWluZyBmcm9tIGl0LlxuICogKFNlZSBhbHNvIGZsdXNoX3BlbmRpbmcoKSkuXG4gKi9cbmNvbnN0IHJlYWRfYnVmID0gKHN0cm0sIGJ1Ziwgc3RhcnQsIHNpemUpID0+IHtcblxuICBsZXQgbGVuID0gc3RybS5hdmFpbF9pbjtcblxuICBpZiAobGVuID4gc2l6ZSkgeyBsZW4gPSBzaXplOyB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuIDA7IH1cblxuICBzdHJtLmF2YWlsX2luIC09IGxlbjtcblxuICAvLyB6bWVtY3B5KGJ1Ziwgc3RybS0+bmV4dF9pbiwgbGVuKTtcbiAgYnVmLnNldChzdHJtLmlucHV0LnN1YmFycmF5KHN0cm0ubmV4dF9pbiwgc3RybS5uZXh0X2luICsgbGVuKSwgc3RhcnQpO1xuICBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAxKSB7XG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIGVsc2UgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMikge1xuICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgc3RybS5uZXh0X2luICs9IGxlbjtcbiAgc3RybS50b3RhbF9pbiArPSBsZW47XG5cbiAgcmV0dXJuIGxlbjtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZXQgbWF0Y2hfc3RhcnQgdG8gdGhlIGxvbmdlc3QgbWF0Y2ggc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHN0cmluZyBhbmRcbiAqIHJldHVybiBpdHMgbGVuZ3RoLiBNYXRjaGVzIHNob3J0ZXIgb3IgZXF1YWwgdG8gcHJldl9sZW5ndGggYXJlIGRpc2NhcmRlZCxcbiAqIGluIHdoaWNoIGNhc2UgdGhlIHJlc3VsdCBpcyBlcXVhbCB0byBwcmV2X2xlbmd0aCBhbmQgbWF0Y2hfc3RhcnQgaXNcbiAqIGdhcmJhZ2UuXG4gKiBJTiBhc3NlcnRpb25zOiBjdXJfbWF0Y2ggaXMgdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gZm9yIHRoZSBjdXJyZW50XG4gKiAgIHN0cmluZyAoc3Ryc3RhcnQpIGFuZCBpdHMgZGlzdGFuY2UgaXMgPD0gTUFYX0RJU1QsIGFuZCBwcmV2X2xlbmd0aCA+PSAxXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdCBncmVhdGVyIHRoYW4gcy0+bG9va2FoZWFkLlxuICovXG5jb25zdCBsb25nZXN0X21hdGNoID0gKHMsIGN1cl9tYXRjaCkgPT4ge1xuXG4gIGxldCBjaGFpbl9sZW5ndGggPSBzLm1heF9jaGFpbl9sZW5ndGg7ICAgICAgLyogbWF4IGhhc2ggY2hhaW4gbGVuZ3RoICovXG4gIGxldCBzY2FuID0gcy5zdHJzdGFydDsgLyogY3VycmVudCBzdHJpbmcgKi9cbiAgbGV0IG1hdGNoOyAgICAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2hlZCBzdHJpbmcgKi9cbiAgbGV0IGxlbjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBtYXRjaCAqL1xuICBsZXQgYmVzdF9sZW4gPSBzLnByZXZfbGVuZ3RoOyAgICAgICAgICAgICAgLyogYmVzdCBtYXRjaCBsZW5ndGggc28gZmFyICovXG4gIGxldCBuaWNlX21hdGNoID0gcy5uaWNlX21hdGNoOyAgICAgICAgICAgICAvKiBzdG9wIGlmIG1hdGNoIGxvbmcgZW5vdWdoICovXG4gIGNvbnN0IGxpbWl0ID0gKHMuc3Ryc3RhcnQgPiAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkgP1xuICAgICAgcy5zdHJzdGFydCAtIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIDogMC8qTklMKi87XG5cbiAgY29uc3QgX3dpbiA9IHMud2luZG93OyAvLyBzaG9ydGN1dFxuXG4gIGNvbnN0IHdtYXNrID0gcy53X21hc2s7XG4gIGNvbnN0IHByZXYgID0gcy5wcmV2O1xuXG4gIC8qIFN0b3Agd2hlbiBjdXJfbWF0Y2ggYmVjb21lcyA8PSBsaW1pdC4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsXG4gICAqIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmcgb2Ygd2luZG93IGluZGV4IDAuXG4gICAqL1xuXG4gIGNvbnN0IHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gIGxldCBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgbGV0IHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG5cbiAgLyogVGhlIGNvZGUgaXMgb3B0aW1pemVkIGZvciBIQVNIX0JJVFMgPj0gOCBhbmQgTUFYX01BVENILTIgbXVsdGlwbGUgb2YgMTYuXG4gICAqIEl0IGlzIGVhc3kgdG8gZ2V0IHJpZCBvZiB0aGlzIG9wdGltaXphdGlvbiBpZiBuZWNlc3NhcnkuXG4gICAqL1xuICAvLyBBc3NlcnQocy0+aGFzaF9iaXRzID49IDggJiYgTUFYX01BVENIID09IDI1OCwgXCJDb2RlIHRvbyBjbGV2ZXJcIik7XG5cbiAgLyogRG8gbm90IHdhc3RlIHRvbyBtdWNoIHRpbWUgaWYgd2UgYWxyZWFkeSBoYXZlIGEgZ29vZCBtYXRjaDogKi9cbiAgaWYgKHMucHJldl9sZW5ndGggPj0gcy5nb29kX21hdGNoKSB7XG4gICAgY2hhaW5fbGVuZ3RoID4+PSAyO1xuICB9XG4gIC8qIERvIG5vdCBsb29rIGZvciBtYXRjaGVzIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBpbnB1dC4gVGhpcyBpcyBuZWNlc3NhcnlcbiAgICogdG8gbWFrZSBkZWZsYXRlIGRldGVybWluaXN0aWMuXG4gICAqL1xuICBpZiAobmljZV9tYXRjaCA+IHMubG9va2FoZWFkKSB7IG5pY2VfbWF0Y2ggPSBzLmxvb2thaGVhZDsgfVxuXG4gIC8vIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplLU1JTl9MT09LQUhFQUQsIFwibmVlZCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIC8vIEFzc2VydChjdXJfbWF0Y2ggPCBzLT5zdHJzdGFydCwgXCJubyBmdXR1cmVcIik7XG4gICAgbWF0Y2ggPSBjdXJfbWF0Y2g7XG5cbiAgICAvKiBTa2lwIHRvIG5leHQgbWF0Y2ggaWYgdGhlIG1hdGNoIGxlbmd0aCBjYW5ub3QgaW5jcmVhc2VcbiAgICAgKiBvciBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIGxlc3MgdGhhbiAyLiAgTm90ZSB0aGF0IHRoZSBjaGVja3MgYmVsb3dcbiAgICAgKiBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IG9jY3VyIG9jY2FzaW9uYWxseSBmb3IgcGVyZm9ybWFuY2VcbiAgICAgKiByZWFzb25zLiAgVGhlcmVmb3JlIHVuaW5pdGlhbGl6ZWQgbWVtb3J5IHdpbGwgYmUgYWNjZXNzZWQsIGFuZFxuICAgICAqIGNvbmRpdGlvbmFsIGp1bXBzIHdpbGwgYmUgbWFkZSB0aGF0IGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMuXG4gICAgICogSG93ZXZlciB0aGUgbGVuZ3RoIG9mIHRoZSBtYXRjaCBpcyBsaW1pdGVkIHRvIHRoZSBsb29rYWhlYWQsIHNvXG4gICAgICogdGhlIG91dHB1dCBvZiBkZWZsYXRlIGlzIG5vdCBhZmZlY3RlZCBieSB0aGUgdW5pbml0aWFsaXplZCB2YWx1ZXMuXG4gICAgICovXG5cbiAgICBpZiAoX3dpblttYXRjaCArIGJlc3RfbGVuXSAgICAgIT09IHNjYW5fZW5kICB8fFxuICAgICAgICBfd2luW21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPT0gc2Nhbl9lbmQxIHx8XG4gICAgICAgIF93aW5bbWF0Y2hdICAgICAgICAgICAgICAgICE9PSBfd2luW3NjYW5dIHx8XG4gICAgICAgIF93aW5bKyttYXRjaF0gICAgICAgICAgICAgICE9PSBfd2luW3NjYW4gKyAxXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyogVGhlIGNoZWNrIGF0IGJlc3RfbGVuLTEgY2FuIGJlIHJlbW92ZWQgYmVjYXVzZSBpdCB3aWxsIGJlIG1hZGVcbiAgICAgKiBhZ2FpbiBsYXRlci4gKFRoaXMgaGV1cmlzdGljIGlzIG5vdCBhbHdheXMgYSB3aW4uKVxuICAgICAqIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gY29tcGFyZSBzY2FuWzJdIGFuZCBtYXRjaFsyXSBzaW5jZSB0aGV5XG4gICAgICogYXJlIGFsd2F5cyBlcXVhbCB3aGVuIHRoZSBvdGhlciBieXRlcyBtYXRjaCwgZ2l2ZW4gdGhhdFxuICAgICAqIHRoZSBoYXNoIGtleXMgYXJlIGVxdWFsIGFuZCB0aGF0IEhBU0hfQklUUyA+PSA4LlxuICAgICAqL1xuICAgIHNjYW4gKz0gMjtcbiAgICBtYXRjaCsrO1xuICAgIC8vIEFzc2VydCgqc2NhbiA9PSAqbWF0Y2gsIFwibWF0Y2hbMl0/XCIpO1xuXG4gICAgLyogV2UgY2hlY2sgZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBldmVyeSA4dGggY29tcGFyaXNvbjtcbiAgICAgKiB0aGUgMjU2dGggY2hlY2sgd2lsbCBiZSBtYWRlIGF0IHN0cnN0YXJ0KzI1OC5cbiAgICAgKi9cbiAgICBkbyB7XG4gICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICB9IHdoaWxlIChfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG5cbiAgICAvLyBBc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVuc2lnbmVkKShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG5cbiAgICBsZW4gPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgc2NhbiA9IHN0cmVuZCAtIE1BWF9NQVRDSDtcblxuICAgIGlmIChsZW4gPiBiZXN0X2xlbikge1xuICAgICAgcy5tYXRjaF9zdGFydCA9IGN1cl9tYXRjaDtcbiAgICAgIGJlc3RfbGVuID0gbGVuO1xuICAgICAgaWYgKGxlbiA+PSBuaWNlX21hdGNoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gICAgICBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuICAgIH1cbiAgfSB3aGlsZSAoKGN1cl9tYXRjaCA9IHByZXZbY3VyX21hdGNoICYgd21hc2tdKSA+IGxpbWl0ICYmIC0tY2hhaW5fbGVuZ3RoICE9PSAwKTtcblxuICBpZiAoYmVzdF9sZW4gPD0gcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gYmVzdF9sZW47XG4gIH1cbiAgcmV0dXJuIHMubG9va2FoZWFkO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZpbGwgdGhlIHdpbmRvdyB3aGVuIHRoZSBsb29rYWhlYWQgYmVjb21lcyBpbnN1ZmZpY2llbnQuXG4gKiBVcGRhdGVzIHN0cnN0YXJ0IGFuZCBsb29rYWhlYWQuXG4gKlxuICogSU4gYXNzZXJ0aW9uOiBsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEXG4gKiBPVVQgYXNzZXJ0aW9uczogc3Ryc3RhcnQgPD0gd2luZG93X3NpemUtTUlOX0xPT0tBSEVBRFxuICogICAgQXQgbGVhc3Qgb25lIGJ5dGUgaGFzIGJlZW4gcmVhZCwgb3IgYXZhaWxfaW4gPT0gMDsgcmVhZHMgYXJlXG4gKiAgICBwZXJmb3JtZWQgZm9yIGF0IGxlYXN0IHR3byBieXRlcyAocmVxdWlyZWQgZm9yIHRoZSB6aXAgdHJhbnNsYXRlX2VvbFxuICogICAgb3B0aW9uIC0tIG5vdCBzdXBwb3J0ZWQgaGVyZSkuXG4gKi9cbmNvbnN0IGZpbGxfd2luZG93ID0gKHMpID0+IHtcblxuICBjb25zdCBfd19zaXplID0gcy53X3NpemU7XG4gIGxldCBwLCBuLCBtLCBtb3JlLCBzdHI7XG5cbiAgLy9Bc3NlcnQocy0+bG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCwgXCJhbHJlYWR5IGVub3VnaCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIG1vcmUgPSBzLndpbmRvd19zaXplIC0gcy5sb29rYWhlYWQgLSBzLnN0cnN0YXJ0O1xuXG4gICAgLy8gSlMgaW50cyBoYXZlIDMyIGJpdCwgYmxvY2sgYmVsb3cgbm90IG5lZWRlZFxuICAgIC8qIERlYWwgd2l0aCAhQCMkJSA2NEsgbGltaXQ6ICovXG4gICAgLy9pZiAoc2l6ZW9mKGludCkgPD0gMikge1xuICAgIC8vICAgIGlmIChtb3JlID09IDAgJiYgcy0+c3Ryc3RhcnQgPT0gMCAmJiBzLT5sb29rYWhlYWQgPT0gMCkge1xuICAgIC8vICAgICAgICBtb3JlID0gd3NpemU7XG4gICAgLy9cbiAgICAvLyAgfSBlbHNlIGlmIChtb3JlID09ICh1bnNpZ25lZCkoLTEpKSB7XG4gICAgLy8gICAgICAgIC8qIFZlcnkgdW5saWtlbHksIGJ1dCBwb3NzaWJsZSBvbiAxNiBiaXQgbWFjaGluZSBpZlxuICAgIC8vICAgICAgICAgKiBzdHJzdGFydCA9PSAwICYmIGxvb2thaGVhZCA9PSAxIChpbnB1dCBkb25lIGEgYnl0ZSBhdCB0aW1lKVxuICAgIC8vICAgICAgICAgKi9cbiAgICAvLyAgICAgICAgbW9yZS0tO1xuICAgIC8vICAgIH1cbiAgICAvL31cblxuXG4gICAgLyogSWYgdGhlIHdpbmRvdyBpcyBhbG1vc3QgZnVsbCBhbmQgdGhlcmUgaXMgaW5zdWZmaWNpZW50IGxvb2thaGVhZCxcbiAgICAgKiBtb3ZlIHRoZSB1cHBlciBoYWxmIHRvIHRoZSBsb3dlciBvbmUgdG8gbWFrZSByb29tIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0ID49IF93X3NpemUgKyAoX3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG5cbiAgICAgIHMud2luZG93LnNldChzLndpbmRvdy5zdWJhcnJheShfd19zaXplLCBfd19zaXplICsgX3dfc2l6ZSksIDApO1xuICAgICAgcy5tYXRjaF9zdGFydCAtPSBfd19zaXplO1xuICAgICAgcy5zdHJzdGFydCAtPSBfd19zaXplO1xuICAgICAgLyogd2Ugbm93IGhhdmUgc3Ryc3RhcnQgPj0gTUFYX0RJU1QgKi9cbiAgICAgIHMuYmxvY2tfc3RhcnQgLT0gX3dfc2l6ZTtcblxuICAgICAgLyogU2xpZGUgdGhlIGhhc2ggdGFibGUgKGNvdWxkIGJlIGF2b2lkZWQgd2l0aCAzMiBiaXQgdmFsdWVzXG4gICAgICAgYXQgdGhlIGV4cGVuc2Ugb2YgbWVtb3J5IHVzYWdlKS4gV2Ugc2xpZGUgZXZlbiB3aGVuIGxldmVsID09IDBcbiAgICAgICB0byBrZWVwIHRoZSBoYXNoIHRhYmxlIGNvbnNpc3RlbnQgaWYgd2Ugc3dpdGNoIGJhY2sgdG8gbGV2ZWwgPiAwXG4gICAgICAgbGF0ZXIuIChVc2luZyBsZXZlbCAwIHBlcm1hbmVudGx5IGlzIG5vdCBhbiBvcHRpbWFsIHVzYWdlIG9mXG4gICAgICAgemxpYiwgc28gd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGlzIHBhdGhvbG9naWNhbCBjYXNlLilcbiAgICAgICAqL1xuXG4gICAgICBuID0gcy5oYXNoX3NpemU7XG4gICAgICBwID0gbjtcblxuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5oZWFkWy0tcF07XG4gICAgICAgIHMuaGVhZFtwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbiA9IF93X3NpemU7XG4gICAgICBwID0gbjtcblxuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5wcmV2Wy0tcF07XG4gICAgICAgIHMucHJldltwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgICAvKiBJZiBuIGlzIG5vdCBvbiBhbnkgaGFzaCBjaGFpbiwgcHJldltuXSBpcyBnYXJiYWdlIGJ1dFxuICAgICAgICAgKiBpdHMgdmFsdWUgd2lsbCBuZXZlciBiZSB1c2VkLlxuICAgICAgICAgKi9cbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG1vcmUgKz0gX3dfc2l6ZTtcbiAgICB9XG4gICAgaWYgKHMuc3RybS5hdmFpbF9pbiA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLyogSWYgdGhlcmUgd2FzIG5vIHNsaWRpbmc6XG4gICAgICogICAgc3Ryc3RhcnQgPD0gV1NJWkUrTUFYX0RJU1QtMSAmJiBsb29rYWhlYWQgPD0gTUlOX0xPT0tBSEVBRCAtIDEgJiZcbiAgICAgKiAgICBtb3JlID09IHdpbmRvd19zaXplIC0gbG9va2FoZWFkIC0gc3Ryc3RhcnRcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gKE1JTl9MT09LQUhFQUQtMSArIFdTSVpFICsgTUFYX0RJU1QtMSlcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gMipXU0laRSArIDJcbiAgICAgKiBJbiB0aGUgQklHX01FTSBvciBNTUFQIGNhc2UgKG5vdCB5ZXQgc3VwcG9ydGVkKSxcbiAgICAgKiAgIHdpbmRvd19zaXplID09IGlucHV0X3NpemUgKyBNSU5fTE9PS0FIRUFEICAmJlxuICAgICAqICAgc3Ryc3RhcnQgKyBzLT5sb29rYWhlYWQgPD0gaW5wdXRfc2l6ZSA9PiBtb3JlID49IE1JTl9MT09LQUhFQUQuXG4gICAgICogT3RoZXJ3aXNlLCB3aW5kb3dfc2l6ZSA9PSAyKldTSVpFIHNvIG1vcmUgPj0gMi5cbiAgICAgKiBJZiB0aGVyZSB3YXMgc2xpZGluZywgbW9yZSA+PSBXU0laRS4gU28gaW4gYWxsIGNhc2VzLCBtb3JlID49IDIuXG4gICAgICovXG4gICAgLy9Bc3NlcnQobW9yZSA+PSAyLCBcIm1vcmUgPCAyXCIpO1xuICAgIG4gPSByZWFkX2J1ZihzLnN0cm0sIHMud2luZG93LCBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQsIG1vcmUpO1xuICAgIHMubG9va2FoZWFkICs9IG47XG5cbiAgICAvKiBJbml0aWFsaXplIHRoZSBoYXNoIHZhbHVlIG5vdyB0aGF0IHdlIGhhdmUgc29tZSBpbnB1dDogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIHN0ciA9IHMuc3Ryc3RhcnQgLSBzLmluc2VydDtcbiAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzdHJdO1xuXG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIDFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3N0ciArIDFdKTtcbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgQ2FsbCB1cGRhdGVfaGFzaCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICB3aGlsZSAocy5pbnNlcnQpIHtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSk7XG5cbiAgICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgICBzdHIrKztcbiAgICAgICAgcy5pbnNlcnQtLTtcbiAgICAgICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPCBNSU5fTUFUQ0gpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGUgd2hvbGUgaW5wdXQgaGFzIGxlc3MgdGhhbiBNSU5fTUFUQ0ggYnl0ZXMsIGluc19oIGlzIGdhcmJhZ2UsXG4gICAgICogYnV0IHRoaXMgaXMgbm90IGltcG9ydGFudCBzaW5jZSBvbmx5IGxpdGVyYWwgYnl0ZXMgd2lsbCBiZSBlbWl0dGVkLlxuICAgICAqL1xuXG4gIH0gd2hpbGUgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBzLnN0cm0uYXZhaWxfaW4gIT09IDApO1xuXG4gIC8qIElmIHRoZSBXSU5fSU5JVCBieXRlcyBhZnRlciB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGRhdGEgaGF2ZSBuZXZlciBiZWVuXG4gICAqIHdyaXR0ZW4sIHRoZW4gemVybyB0aG9zZSBieXRlcyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgcmVwb3J0cyBvZlxuICAgKiB0aGUgdXNlIG9mIHVuaW5pdGlhbGl6ZWQgKG9yIHVuaW5pdGlhbGlzZWQgYXMgSnVsaWFuIHdyaXRlcykgYnl0ZXMgYnlcbiAgICogdGhlIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMuICBVcGRhdGUgdGhlIGhpZ2ggd2F0ZXIgbWFyayBmb3IgdGhlIG5leHRcbiAgICogdGltZSB0aHJvdWdoIGhlcmUuICBXSU5fSU5JVCBpcyBzZXQgdG8gTUFYX01BVENIIHNpbmNlIHRoZSBsb25nZXN0IG1hdGNoXG4gICAqIHJvdXRpbmVzIGFsbG93IHNjYW5uaW5nIHRvIHN0cnN0YXJ0ICsgTUFYX01BVENILCBpZ25vcmluZyBsb29rYWhlYWQuXG4gICAqL1xuLy8gIGlmIChzLmhpZ2hfd2F0ZXIgPCBzLndpbmRvd19zaXplKSB7XG4vLyAgICBjb25zdCBjdXJyID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkO1xuLy8gICAgbGV0IGluaXQgPSAwO1xuLy9cbi8vICAgIGlmIChzLmhpZ2hfd2F0ZXIgPCBjdXJyKSB7XG4vLyAgICAgIC8qIFByZXZpb3VzIGhpZ2ggd2F0ZXIgbWFyayBiZWxvdyBjdXJyZW50IGRhdGEgLS0gemVybyBXSU5fSU5JVFxuLy8gICAgICAgKiBieXRlcyBvciB1cCB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSBzLndpbmRvd19zaXplIC0gY3Vycjtcbi8vICAgICAgaWYgKGluaXQgPiBXSU5fSU5JVClcbi8vICAgICAgICBpbml0ID0gV0lOX0lOSVQ7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIGN1cnIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciA9IGN1cnIgKyBpbml0O1xuLy8gICAgfVxuLy8gICAgZWxzZSBpZiAocy0+aGlnaF93YXRlciA8ICh1bGcpY3VyciArIFdJTl9JTklUKSB7XG4vLyAgICAgIC8qIEhpZ2ggd2F0ZXIgbWFyayBhdCBvciBhYm92ZSBjdXJyZW50IGRhdGEsIGJ1dCBiZWxvdyBjdXJyZW50IGRhdGFcbi8vICAgICAgICogcGx1cyBXSU5fSU5JVCAtLSB6ZXJvIG91dCB0byBjdXJyZW50IGRhdGEgcGx1cyBXSU5fSU5JVCwgb3IgdXBcbi8vICAgICAgICogdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gKHVsZyljdXJyICsgV0lOX0lOSVQgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICBpZiAoaW5pdCA+IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcilcbi8vICAgICAgICBpbml0ID0gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBzLT5oaWdoX3dhdGVyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgKz0gaW5pdDtcbi8vICAgIH1cbi8vICB9XG4vL1xuLy8gIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplIC0gTUlOX0xPT0tBSEVBRCxcbi8vICAgIFwibm90IGVub3VnaCByb29tIGZvciBzZWFyY2hcIik7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgd2l0aG91dCBjb21wcmVzc2lvbiBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuXG4gKiB0aGUgY3VycmVudCBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgaW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IHNpbmNlXG4gKiB1bmNvbXByZXNzaWJsZSBkYXRhIGlzIHByb2JhYmx5IG5vdCB1c2VmdWwuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZFxuICogb25seSBmb3IgdGhlIGxldmVsPTAgY29tcHJlc3Npb24gb3B0aW9uLlxuICogTk9URTogdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgb3B0aW1pemVkIHRvIGF2b2lkIGV4dHJhIGNvcHlpbmcgZnJvbVxuICogd2luZG93IHRvIHBlbmRpbmdfYnVmLlxuICovXG5jb25zdCBkZWZsYXRlX3N0b3JlZCA9IChzLCBmbHVzaCkgPT4ge1xuXG4gIC8qIFN0b3JlZCBibG9ja3MgYXJlIGxpbWl0ZWQgdG8gMHhmZmZmIGJ5dGVzLCBwZW5kaW5nX2J1ZiBpcyBsaW1pdGVkXG4gICAqIHRvIHBlbmRpbmdfYnVmX3NpemUsIGFuZCBlYWNoIHN0b3JlZCBibG9jayBoYXMgYSA1IGJ5dGUgaGVhZGVyOlxuICAgKi9cbiAgbGV0IG1heF9ibG9ja19zaXplID0gMHhmZmZmO1xuXG4gIGlmIChtYXhfYmxvY2tfc2l6ZSA+IHMucGVuZGluZ19idWZfc2l6ZSAtIDUpIHtcbiAgICBtYXhfYmxvY2tfc2l6ZSA9IHMucGVuZGluZ19idWZfc2l6ZSAtIDU7XG4gIH1cblxuICAvKiBDb3B5IGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSBpbnB1dCB0byBvdXRwdXQ6ICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBGaWxsIHRoZSB3aW5kb3cgYXMgbXVjaCBhcyBwb3NzaWJsZTogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gMSkge1xuXG4gICAgICAvL0Fzc2VydChzLT5zdHJzdGFydCA8IHMtPndfc2l6ZStNQVhfRElTVChzKSB8fFxuICAgICAgLy8gIHMtPmJsb2NrX3N0YXJ0ID49IChsb25nKXMtPndfc2l6ZSwgXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgaWYgKCEocy5zdHJzdGFydCA8IHMud19zaXplICsgKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgfHxcbi8vICAgICAgICBzLmJsb2NrX3N0YXJ0ID49IHMud19zaXplKSkge1xuLy8gICAgICAgIHRocm93ICBuZXcgRXJyb3IoXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgfVxuXG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuXG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cbiAgICAvL0Fzc2VydChzLT5ibG9ja19zdGFydCA+PSAwTCwgXCJibG9jayBnb25lXCIpO1xuLy8gICAgaWYgKHMuYmxvY2tfc3RhcnQgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJibG9jayBnb25lXCIpO1xuXG4gICAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgICBzLmxvb2thaGVhZCA9IDA7XG5cbiAgICAvKiBFbWl0IGEgc3RvcmVkIGJsb2NrIGlmIHBlbmRpbmdfYnVmIHdpbGwgYmUgZnVsbDogKi9cbiAgICBjb25zdCBtYXhfc3RhcnQgPSBzLmJsb2NrX3N0YXJ0ICsgbWF4X2Jsb2NrX3NpemU7XG5cbiAgICBpZiAocy5zdHJzdGFydCA9PT0gMCB8fCBzLnN0cnN0YXJ0ID49IG1heF9zdGFydCkge1xuICAgICAgLyogc3Ryc3RhcnQgPT0gMCBpcyBwb3NzaWJsZSB3aGVuIHdyYXBhcm91bmQgb24gMTYtYml0IG1hY2hpbmUgKi9cbiAgICAgIHMubG9va2FoZWFkID0gcy5zdHJzdGFydCAtIG1heF9zdGFydDtcbiAgICAgIHMuc3Ryc3RhcnQgPSBtYXhfc3RhcnQ7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuXG5cbiAgICB9XG4gICAgLyogRmx1c2ggaWYgd2UgbWF5IGhhdmUgdG8gc2xpZGUsIG90aGVyd2lzZSBibG9ja19zdGFydCBtYXkgYmVjb21lXG4gICAgICogbmVnYXRpdmUgYW5kIHRoZSBkYXRhIHdpbGwgYmUgZ29uZTpcbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQgPj0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG5cbiAgcy5pbnNlcnQgPSAwO1xuXG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuXG4gIGlmIChzLnN0cnN0YXJ0ID4gcy5ibG9ja19zdGFydCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19ORUVEX01PUkU7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXByZXNzIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm4gdGhlIGN1cnJlbnRcbiAqIGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBwZXJmb3JtIGxhenkgZXZhbHVhdGlvbiBvZiBtYXRjaGVzIGFuZCBpbnNlcnRzXG4gKiBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBvbmx5IGZvciB1bm1hdGNoZWQgc3RyaW5ncyBvciBmb3Igc2hvcnRcbiAqIG1hdGNoZXMuIEl0IGlzIHVzZWQgb25seSBmb3IgdGhlIGZhc3QgY29tcHJlc3Npb24gb3B0aW9ucy5cbiAqL1xuY29uc3QgZGVmbGF0ZV9mYXN0ID0gKHMsIGZsdXNoKSA9PiB7XG5cbiAgbGV0IGhhc2hfaGVhZDsgICAgICAgIC8qIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gKi9cbiAgbGV0IGJmbHVzaDsgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBhbHdheXMgbWF0Y2hfbGVuZ3RoIDwgTUlOX01BVENIXG4gICAgICovXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgKChzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkKSA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkpIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuICAgIH1cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvLyBjaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCk7IC8vIGZvciBkZWJ1ZyBvbmx5XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuXG4gICAgICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoXG4gICAgICAgKiBpcyBub3QgdG9vIGxhcmdlLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuICAgICAgICovXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gcy5tYXhfbGF6eV9tYXRjaC8qbWF4X2luc2VydF9sZW5ndGgqLyAmJiBzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGgtLTsgLyogc3RyaW5nIGF0IHN0cnN0YXJ0IGFscmVhZHkgaW4gdGFibGUgKi9cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSk7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICAgIC8qIHN0cnN0YXJ0IG5ldmVyIGV4Y2VlZHMgV1NJWkUtTUFYX01BVENILCBzbyB0aGVyZSBhcmVcbiAgICAgICAgICAgKiBhbHdheXMgTUlOX01BVENIIGJ5dGVzIGFoZWFkLlxuICAgICAgICAgICAqL1xuICAgICAgICB9IHdoaWxlICgtLXMubWF0Y2hfbGVuZ3RoICE9PSAwKTtcbiAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgfSBlbHNlXG4gICAgICB7XG4gICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAgICAgcy5pbnNfaCA9IHMud2luZG93W3Muc3Ryc3RhcnRdO1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0KzFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCArIDFdKTtcblxuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICAgICAgICAgIENhbGwgVVBEQVRFX0hBU0goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgICAvKiBJZiBsb29rYWhlYWQgPCBNSU5fTUFUQ0gsIGluc19oIGlzIGdhcmJhZ2UsIGJ1dCBpdCBkb2VzIG5vdFxuICAgICAgICAgKiBtYXR0ZXIgc2luY2UgaXQgd2lsbCBiZSByZWNvbXB1dGVkIGF0IG5leHQgZGVmbGF0ZSBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9ICgocy5zdHJzdGFydCA8IChNSU5fTUFUQ0ggLSAxKSkgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMSk7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2FtZSBhcyBhYm92ZSwgYnV0IGFjaGlldmVzIGJldHRlciBjb21wcmVzc2lvbi4gV2UgdXNlIGEgbGF6eVxuICogZXZhbHVhdGlvbiBmb3IgbWF0Y2hlczogYSBtYXRjaCBpcyBmaW5hbGx5IGFkb3B0ZWQgb25seSBpZiB0aGVyZSBpc1xuICogbm8gYmV0dGVyIG1hdGNoIGF0IHRoZSBuZXh0IHdpbmRvdyBwb3NpdGlvbi5cbiAqL1xuY29uc3QgZGVmbGF0ZV9zbG93ID0gKHMsIGZsdXNoKSA9PiB7XG5cbiAgbGV0IGhhc2hfaGVhZDsgICAgICAgICAgLyogaGVhZCBvZiBoYXNoIGNoYWluICovXG4gIGxldCBiZmx1c2g7ICAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBsZXQgbWF4X2luc2VydDtcblxuICAvKiBQcm9jZXNzIHRoZSBpbnB1dCBibG9jay4gKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKTtcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKi9cbiAgICBzLnByZXZfbGVuZ3RoID0gcy5tYXRjaF9sZW5ndGg7XG4gICAgcy5wcmV2X21hdGNoID0gcy5tYXRjaF9zdGFydDtcbiAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG5cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiBzLnByZXZfbGVuZ3RoIDwgcy5tYXhfbGF6eV9tYXRjaCAmJlxuICAgICAgICBzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpLypNQVhfRElTVChzKSovKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cblxuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IDUgJiZcbiAgICAgICAgIChzLnN0cmF0ZWd5ID09PSBaX0ZJTFRFUkVEIHx8IChzLm1hdGNoX2xlbmd0aCA9PT0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0ID4gNDA5Ni8qVE9PX0ZBUiovKSkpIHtcblxuICAgICAgICAvKiBJZiBwcmV2X21hdGNoIGlzIGFsc28gTUlOX01BVENILCBtYXRjaF9zdGFydCBpcyBnYXJiYWdlXG4gICAgICAgICAqIGJ1dCB3ZSB3aWxsIGlnbm9yZSB0aGUgY3VycmVudCBtYXRjaCBhbnl3YXkuXG4gICAgICAgICAqL1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZXJlIHdhcyBhIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBzdGVwIGFuZCB0aGUgY3VycmVudFxuICAgICAqIG1hdGNoIGlzIG5vdCBiZXR0ZXIsIG91dHB1dCB0aGUgcHJldmlvdXMgbWF0Y2g6XG4gICAgICovXG4gICAgaWYgKHMucHJldl9sZW5ndGggPj0gTUlOX01BVENIICYmIHMubWF0Y2hfbGVuZ3RoIDw9IHMucHJldl9sZW5ndGgpIHtcbiAgICAgIG1heF9pbnNlcnQgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQgLSBNSU5fTUFUQ0g7XG4gICAgICAvKiBEbyBub3QgaW5zZXJ0IHN0cmluZ3MgaW4gaGFzaCB0YWJsZSBiZXlvbmQgdGhpcy4gKi9cblxuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LTEsIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCk7XG5cbiAgICAgIC8qKipfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7KioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENIKTtcbiAgICAgIC8qIEluc2VydCBpbiBoYXNoIHRhYmxlIGFsbCBzdHJpbmdzIHVwIHRvIHRoZSBlbmQgb2YgdGhlIG1hdGNoLlxuICAgICAgICogc3Ryc3RhcnQtMSBhbmQgc3Ryc3RhcnQgYXJlIGFscmVhZHkgaW5zZXJ0ZWQuIElmIHRoZXJlIGlzIG5vdFxuICAgICAgICogZW5vdWdoIGxvb2thaGVhZCwgdGhlIGxhc3QgdHdvIHN0cmluZ3MgYXJlIG5vdCBpbnNlcnRlZCBpblxuICAgICAgICogdGhlIGhhc2ggdGFibGUuXG4gICAgICAgKi9cbiAgICAgIHMubG9va2FoZWFkIC09IHMucHJldl9sZW5ndGggLSAxO1xuICAgICAgcy5wcmV2X2xlbmd0aCAtPSAyO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoKytzLnN0cnN0YXJ0IDw9IG1heF9pbnNlcnQpIHtcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSk7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgtLXMucHJldl9sZW5ndGggIT09IDApO1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICAvKioqL1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgICAgLyogSWYgdGhlcmUgd2FzIG5vIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBwb3NpdGlvbiwgb3V0cHV0IGFcbiAgICAgICAqIHNpbmdsZSBsaXRlcmFsLiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBidXQgdGhlIGN1cnJlbnQgbWF0Y2hcbiAgICAgICAqIGlzIGxvbmdlciwgdHJ1bmNhdGUgdGhlIHByZXZpb3VzIG1hdGNoIHRvIGEgc2luZ2xlIGxpdGVyYWwuXG4gICAgICAgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DS19PTkxZKHMsIDApICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIC8qKiovXG4gICAgICB9XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogVGhlcmUgaXMgbm8gcHJldmlvdXMgbWF0Y2ggdG8gY29tcGFyZSB3aXRoLCB3YWl0IGZvclxuICAgICAgICogdGhlIG5leHQgc3RlcCB0byBkZWNpZGUuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChmbHVzaCAhPSBaX05PX0ZMVVNILCBcIm5vIGZsdXNoP1wiKTtcbiAgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IF90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICB9XG4gIHMuaW5zZXJ0ID0gcy5zdHJzdGFydCA8IE1JTl9NQVRDSCAtIDEgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfUkxFLCBzaW1wbHkgbG9vayBmb3IgcnVucyBvZiBieXRlcywgZ2VuZXJhdGUgbWF0Y2hlcyBvbmx5IG9mIGRpc3RhbmNlXG4gKiBvbmUuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLiAgKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2ZcbiAqIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIFpfUkxFLilcbiAqL1xuY29uc3QgZGVmbGF0ZV9ybGUgPSAocywgZmx1c2gpID0+IHtcblxuICBsZXQgYmZsdXNoOyAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuICBsZXQgcHJldjsgICAgICAgICAgICAgIC8qIGJ5dGUgYXQgZGlzdGFuY2Ugb25lIHRvIG1hdGNoICovXG4gIGxldCBzY2FuLCBzdHJlbmQ7ICAgICAgLyogc2NhbiBnb2VzIHVwIHRvIHN0cmVuZCBmb3IgbGVuZ3RoIG9mIHJ1biAqL1xuXG4gIGNvbnN0IF93aW4gPSBzLndpbmRvdztcblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIGxvbmdlc3QgcnVuLCBwbHVzIG9uZSBmb3IgdGhlIHVucm9sbGVkIGxvb3AuXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBTZWUgaG93IG1hbnkgdGltZXMgdGhlIHByZXZpb3VzIGJ5dGUgcmVwZWF0cyAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgPiAwKSB7XG4gICAgICBzY2FuID0gcy5zdHJzdGFydCAtIDE7XG4gICAgICBwcmV2ID0gX3dpbltzY2FuXTtcbiAgICAgIGlmIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSkge1xuICAgICAgICBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgICAgIH0gd2hpbGUgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPiBzLmxvb2thaGVhZCkge1xuICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5sb29rYWhlYWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1SW50KShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG4gICAgfVxuXG4gICAgLyogRW1pdCBtYXRjaCBpZiBoYXZlIHJ1biBvZiBNSU5fTUFUQ0ggb3IgbG9uZ2VyLCBlbHNlIGVtaXQgbGl0ZXJhbCAqL1xuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5zdHJzdGFydCAtIDEsIHMubWF0Y2hfbGVuZ3RoKTtcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX0hVRkZNQU5fT05MWSwgZG8gbm90IGxvb2sgZm9yIG1hdGNoZXMuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLlxuICogKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2YgZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gSHVmZm1hbi4pXG4gKi9cbmNvbnN0IGRlZmxhdGVfaHVmZiA9IChzLCBmbHVzaCkgPT4ge1xuXG4gIGxldCBiZmx1c2g7ICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBoYXZlIGEgbGl0ZXJhbCB0byB3cml0ZS4gKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7ICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBPdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcbiAgICBzLmxvb2thaGVhZC0tO1xuICAgIHMuc3Ryc3RhcnQrKztcbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn07XG5cbi8qIFZhbHVlcyBmb3IgbWF4X2xhenlfbWF0Y2gsIGdvb2RfbWF0Y2ggYW5kIG1heF9jaGFpbl9sZW5ndGgsIGRlcGVuZGluZyBvblxuICogdGhlIGRlc2lyZWQgcGFjayBsZXZlbCAoMC4uOSkuIFRoZSB2YWx1ZXMgZ2l2ZW4gYmVsb3cgaGF2ZSBiZWVuIHR1bmVkIHRvXG4gKiBleGNsdWRlIHdvcnN0IGNhc2UgcGVyZm9ybWFuY2UgZm9yIHBhdGhvbG9naWNhbCBmaWxlcy4gQmV0dGVyIHZhbHVlcyBtYXkgYmVcbiAqIGZvdW5kIGZvciBzcGVjaWZpYyBmaWxlcy5cbiAqL1xuZnVuY3Rpb24gQ29uZmlnKGdvb2RfbGVuZ3RoLCBtYXhfbGF6eSwgbmljZV9sZW5ndGgsIG1heF9jaGFpbiwgZnVuYykge1xuXG4gIHRoaXMuZ29vZF9sZW5ndGggPSBnb29kX2xlbmd0aDtcbiAgdGhpcy5tYXhfbGF6eSA9IG1heF9sYXp5O1xuICB0aGlzLm5pY2VfbGVuZ3RoID0gbmljZV9sZW5ndGg7XG4gIHRoaXMubWF4X2NoYWluID0gbWF4X2NoYWluO1xuICB0aGlzLmZ1bmMgPSBmdW5jO1xufVxuXG5jb25zdCBjb25maWd1cmF0aW9uX3RhYmxlID0gW1xuICAvKiAgICAgIGdvb2QgbGF6eSBuaWNlIGNoYWluICovXG4gIG5ldyBDb25maWcoMCwgMCwgMCwgMCwgZGVmbGF0ZV9zdG9yZWQpLCAgICAgICAgICAvKiAwIHN0b3JlIG9ubHkgKi9cbiAgbmV3IENvbmZpZyg0LCA0LCA4LCA0LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgIC8qIDEgbWF4IHNwZWVkLCBubyBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg0LCA1LCAxNiwgOCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgIC8qIDIgKi9cbiAgbmV3IENvbmZpZyg0LCA2LCAzMiwgMzIsIGRlZmxhdGVfZmFzdCksICAgICAgICAgIC8qIDMgKi9cblxuICBuZXcgQ29uZmlnKDQsIDQsIDE2LCAxNiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAgLyogNCBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMzIsIDMyLCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgIC8qIDUgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDYgKi9cbiAgbmV3IENvbmZpZyg4LCAzMiwgMTI4LCAyNTYsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDcgKi9cbiAgbmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIGRlZmxhdGVfc2xvdyksICAgIC8qIDggKi9cbiAgbmV3IENvbmZpZygzMiwgMjU4LCAyNTgsIDQwOTYsIGRlZmxhdGVfc2xvdykgICAgIC8qIDkgbWF4IGNvbXByZXNzaW9uICovXG5dO1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgXCJsb25nZXN0IG1hdGNoXCIgcm91dGluZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtXG4gKi9cbmNvbnN0IGxtX2luaXQgPSAocykgPT4ge1xuXG4gIHMud2luZG93X3NpemUgPSAyICogcy53X3NpemU7XG5cbiAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAvKiBTZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzOlxuICAgKi9cbiAgcy5tYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2xhenk7XG4gIHMuZ29vZF9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZ29vZF9sZW5ndGg7XG4gIHMubmljZV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubmljZV9sZW5ndGg7XG4gIHMubWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2NoYWluO1xuXG4gIHMuc3Ryc3RhcnQgPSAwO1xuICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLmluc2VydCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgcy5pbnNfaCA9IDA7XG59O1xuXG5cbmZ1bmN0aW9uIERlZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5zdHJtID0gbnVsbDsgICAgICAgICAgICAvKiBwb2ludGVyIGJhY2sgdG8gdGhpcyB6bGliIHN0cmVhbSAqL1xuICB0aGlzLnN0YXR1cyA9IDA7ICAgICAgICAgICAgLyogYXMgdGhlIG5hbWUgaW1wbGllcyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmID0gbnVsbDsgICAgICAvKiBvdXRwdXQgc3RpbGwgcGVuZGluZyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmX3NpemUgPSAwOyAgLyogc2l6ZSBvZiBwZW5kaW5nX2J1ZiAqL1xuICB0aGlzLnBlbmRpbmdfb3V0ID0gMDsgICAgICAgLyogbmV4dCBwZW5kaW5nIGJ5dGUgdG8gb3V0cHV0IHRvIHRoZSBzdHJlYW0gKi9cbiAgdGhpcy5wZW5kaW5nID0gMDsgICAgICAgICAgIC8qIG5iIG9mIGJ5dGVzIGluIHRoZSBwZW5kaW5nIGJ1ZmZlciAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmd6aGVhZCA9IG51bGw7ICAgICAgICAgLyogZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gdG8gd3JpdGUgKi9cbiAgdGhpcy5nemluZGV4ID0gMDsgICAgICAgICAgIC8qIHdoZXJlIGluIGV4dHJhLCBuYW1lLCBvciBjb21tZW50ICovXG4gIHRoaXMubWV0aG9kID0gWl9ERUZMQVRFRDsgLyogY2FuIG9ubHkgYmUgREVGTEFURUQgKi9cbiAgdGhpcy5sYXN0X2ZsdXNoID0gLTE7ICAgLyogdmFsdWUgb2YgZmx1c2ggcGFyYW0gZm9yIHByZXZpb3VzIGRlZmxhdGUgY2FsbCAqL1xuXG4gIHRoaXMud19zaXplID0gMDsgIC8qIExaNzcgd2luZG93IHNpemUgKDMySyBieSBkZWZhdWx0KSAqL1xuICB0aGlzLndfYml0cyA9IDA7ICAvKiBsb2cyKHdfc2l6ZSkgICg4Li4xNikgKi9cbiAgdGhpcy53X21hc2sgPSAwOyAgLyogd19zaXplIC0gMSAqL1xuXG4gIHRoaXMud2luZG93ID0gbnVsbDtcbiAgLyogU2xpZGluZyB3aW5kb3cuIElucHV0IGJ5dGVzIGFyZSByZWFkIGludG8gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSB3aW5kb3csXG4gICAqIGFuZCBtb3ZlIHRvIHRoZSBmaXJzdCBoYWxmIGxhdGVyIHRvIGtlZXAgYSBkaWN0aW9uYXJ5IG9mIGF0IGxlYXN0IHdTaXplXG4gICAqIGJ5dGVzLiBXaXRoIHRoaXMgb3JnYW5pemF0aW9uLCBtYXRjaGVzIGFyZSBsaW1pdGVkIHRvIGEgZGlzdGFuY2Ugb2ZcbiAgICogd1NpemUtTUFYX01BVENIIGJ5dGVzLCBidXQgdGhpcyBlbnN1cmVzIHRoYXQgSU8gaXMgYWx3YXlzXG4gICAqIHBlcmZvcm1lZCB3aXRoIGEgbGVuZ3RoIG11bHRpcGxlIG9mIHRoZSBibG9jayBzaXplLlxuICAgKi9cblxuICB0aGlzLndpbmRvd19zaXplID0gMDtcbiAgLyogQWN0dWFsIHNpemUgb2Ygd2luZG93OiAyKndTaXplLCBleGNlcHQgd2hlbiB0aGUgdXNlciBpbnB1dCBidWZmZXJcbiAgICogaXMgZGlyZWN0bHkgdXNlZCBhcyBzbGlkaW5nIHdpbmRvdy5cbiAgICovXG5cbiAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgLyogTGluayB0byBvbGRlciBzdHJpbmcgd2l0aCBzYW1lIGhhc2ggaW5kZXguIFRvIGxpbWl0IHRoZSBzaXplIG9mIHRoaXNcbiAgICogYXJyYXkgdG8gNjRLLCB0aGlzIGxpbmsgaXMgbWFpbnRhaW5lZCBvbmx5IGZvciB0aGUgbGFzdCAzMksgc3RyaW5ncy5cbiAgICogQW4gaW5kZXggaW4gdGhpcyBhcnJheSBpcyB0aHVzIGEgd2luZG93IGluZGV4IG1vZHVsbyAzMksuXG4gICAqL1xuXG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgLyogSGVhZHMgb2YgdGhlIGhhc2ggY2hhaW5zIG9yIE5JTC4gKi9cblxuICB0aGlzLmluc19oID0gMDsgICAgICAgLyogaGFzaCBpbmRleCBvZiBzdHJpbmcgdG8gYmUgaW5zZXJ0ZWQgKi9cbiAgdGhpcy5oYXNoX3NpemUgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiBoYXNoIHRhYmxlICovXG4gIHRoaXMuaGFzaF9iaXRzID0gMDsgICAvKiBsb2cyKGhhc2hfc2l6ZSkgKi9cbiAgdGhpcy5oYXNoX21hc2sgPSAwOyAgIC8qIGhhc2hfc2l6ZS0xICovXG5cbiAgdGhpcy5oYXNoX3NoaWZ0ID0gMDtcbiAgLyogTnVtYmVyIG9mIGJpdHMgYnkgd2hpY2ggaW5zX2ggbXVzdCBiZSBzaGlmdGVkIGF0IGVhY2ggaW5wdXRcbiAgICogc3RlcC4gSXQgbXVzdCBiZSBzdWNoIHRoYXQgYWZ0ZXIgTUlOX01BVENIIHN0ZXBzLCB0aGUgb2xkZXN0XG4gICAqIGJ5dGUgbm8gbG9uZ2VyIHRha2VzIHBhcnQgaW4gdGhlIGhhc2gga2V5LCB0aGF0IGlzOlxuICAgKiAgIGhhc2hfc2hpZnQgKiBNSU5fTUFUQ0ggPj0gaGFzaF9iaXRzXG4gICAqL1xuXG4gIHRoaXMuYmxvY2tfc3RhcnQgPSAwO1xuICAvKiBXaW5kb3cgcG9zaXRpb24gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY3VycmVudCBvdXRwdXQgYmxvY2suIEdldHNcbiAgICogbmVnYXRpdmUgd2hlbiB0aGUgd2luZG93IGlzIG1vdmVkIGJhY2t3YXJkcy5cbiAgICovXG5cbiAgdGhpcy5tYXRjaF9sZW5ndGggPSAwOyAgICAgIC8qIGxlbmd0aCBvZiBiZXN0IG1hdGNoICovXG4gIHRoaXMucHJldl9tYXRjaCA9IDA7ICAgICAgICAvKiBwcmV2aW91cyBtYXRjaCAqL1xuICB0aGlzLm1hdGNoX2F2YWlsYWJsZSA9IDA7ICAgLyogc2V0IGlmIHByZXZpb3VzIG1hdGNoIGV4aXN0cyAqL1xuICB0aGlzLnN0cnN0YXJ0ID0gMDsgICAgICAgICAgLyogc3RhcnQgb2Ygc3RyaW5nIHRvIGluc2VydCAqL1xuICB0aGlzLm1hdGNoX3N0YXJ0ID0gMDsgICAgICAgLyogc3RhcnQgb2YgbWF0Y2hpbmcgc3RyaW5nICovXG4gIHRoaXMubG9va2FoZWFkID0gMDsgICAgICAgICAvKiBudW1iZXIgb2YgdmFsaWQgYnl0ZXMgYWhlYWQgaW4gd2luZG93ICovXG5cbiAgdGhpcy5wcmV2X2xlbmd0aCA9IDA7XG4gIC8qIExlbmd0aCBvZiB0aGUgYmVzdCBtYXRjaCBhdCBwcmV2aW91cyBzdGVwLiBNYXRjaGVzIG5vdCBncmVhdGVyIHRoYW4gdGhpc1xuICAgKiBhcmUgZGlzY2FyZGVkLiBUaGlzIGlzIHVzZWQgaW4gdGhlIGxhenkgbWF0Y2ggZXZhbHVhdGlvbi5cbiAgICovXG5cbiAgdGhpcy5tYXhfY2hhaW5fbGVuZ3RoID0gMDtcbiAgLyogVG8gc3BlZWQgdXAgZGVmbGF0aW9uLCBoYXNoIGNoYWlucyBhcmUgbmV2ZXIgc2VhcmNoZWQgYmV5b25kIHRoaXNcbiAgICogbGVuZ3RoLiAgQSBoaWdoZXIgbGltaXQgaW1wcm92ZXMgY29tcHJlc3Npb24gcmF0aW8gYnV0IGRlZ3JhZGVzIHRoZVxuICAgKiBzcGVlZC5cbiAgICovXG5cbiAgdGhpcy5tYXhfbGF6eV9tYXRjaCA9IDA7XG4gIC8qIEF0dGVtcHQgdG8gZmluZCBhIGJldHRlciBtYXRjaCBvbmx5IHdoZW4gdGhlIGN1cnJlbnQgbWF0Y2ggaXMgc3RyaWN0bHlcbiAgICogc21hbGxlciB0aGFuIHRoaXMgdmFsdWUuIFRoaXMgbWVjaGFuaXNtIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb25cbiAgICogbGV2ZWxzID49IDQuXG4gICAqL1xuICAvLyBUaGF0J3MgYWxpYXMgdG8gbWF4X2xhenlfbWF0Y2gsIGRvbid0IHVzZSBkaXJlY3RseVxuICAvL3RoaXMubWF4X2luc2VydF9sZW5ndGggPSAwO1xuICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdFxuICAgKiBncmVhdGVyIHRoYW4gdGhpcyBsZW5ndGguIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAqIG1heF9pbnNlcnRfbGVuZ3RoIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb24gbGV2ZWxzIDw9IDMuXG4gICAqL1xuXG4gIHRoaXMubGV2ZWwgPSAwOyAgICAgLyogY29tcHJlc3Npb24gbGV2ZWwgKDEuLjkpICovXG4gIHRoaXMuc3RyYXRlZ3kgPSAwOyAgLyogZmF2b3Igb3IgZm9yY2UgSHVmZm1hbiBjb2RpbmcqL1xuXG4gIHRoaXMuZ29vZF9tYXRjaCA9IDA7XG4gIC8qIFVzZSBhIGZhc3RlciBzZWFyY2ggd2hlbiB0aGUgcHJldmlvdXMgbWF0Y2ggaXMgbG9uZ2VyIHRoYW4gdGhpcyAqL1xuXG4gIHRoaXMubmljZV9tYXRjaCA9IDA7IC8qIFN0b3Agc2VhcmNoaW5nIHdoZW4gY3VycmVudCBtYXRjaCBleGNlZWRzIHRoaXMgKi9cblxuICAgICAgICAgICAgICAvKiB1c2VkIGJ5IHRyZWVzLmM6ICovXG5cbiAgLyogRGlkbid0IHVzZSBjdF9kYXRhIHR5cGVkZWYgYmVsb3cgdG8gc3VwcHJlc3MgY29tcGlsZXIgd2FybmluZyAqL1xuXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2x0cmVlW0hFQVBfU0laRV07ICAgLyogbGl0ZXJhbCBhbmQgbGVuZ3RoIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fZHRyZWVbMipEX0NPREVTKzFdOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgYmxfdHJlZVsyKkJMX0NPREVTKzFdOyAgLyogSHVmZm1hbiB0cmVlIGZvciBiaXQgbGVuZ3RocyAqL1xuXG4gIC8vIFVzZSBmbGF0IGFycmF5IG9mIERPVUJMRSBzaXplLCB3aXRoIGludGVybGVhdmVkIGZhdGEsXG4gIC8vIGJlY2F1c2UgSlMgZG9lcyBub3Qgc3VwcG9ydCBlZmZlY3RpdmVcbiAgdGhpcy5keW5fbHRyZWUgID0gbmV3IFVpbnQxNkFycmF5KEhFQVBfU0laRSAqIDIpO1xuICB0aGlzLmR5bl9kdHJlZSAgPSBuZXcgVWludDE2QXJyYXkoKDIgKiBEX0NPREVTICsgMSkgKiAyKTtcbiAgdGhpcy5ibF90cmVlICAgID0gbmV3IFVpbnQxNkFycmF5KCgyICogQkxfQ09ERVMgKyAxKSAqIDIpO1xuICB6ZXJvKHRoaXMuZHluX2x0cmVlKTtcbiAgemVybyh0aGlzLmR5bl9kdHJlZSk7XG4gIHplcm8odGhpcy5ibF90cmVlKTtcblxuICB0aGlzLmxfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgbGl0ZXJhbCB0cmVlICovXG4gIHRoaXMuZF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBkaXN0YW5jZSB0cmVlICovXG4gIHRoaXMuYmxfZGVzYyAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBiaXQgbGVuZ3RoIHRyZWUgKi9cblxuICAvL3VzaCBibF9jb3VudFtNQVhfQklUUysxXTtcbiAgdGhpcy5ibF9jb3VudCA9IG5ldyBVaW50MTZBcnJheShNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvL2ludCBoZWFwWzIqTF9DT0RFUysxXTsgICAgICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgdGhpcy5oZWFwID0gbmV3IFVpbnQxNkFycmF5KDIgKiBMX0NPREVTICsgMSk7ICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgemVybyh0aGlzLmhlYXApO1xuXG4gIHRoaXMuaGVhcF9sZW4gPSAwOyAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcCAqL1xuICB0aGlzLmhlYXBfbWF4ID0gMDsgICAgICAgICAgICAgICAvKiBlbGVtZW50IG9mIGxhcmdlc3QgZnJlcXVlbmN5ICovXG4gIC8qIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqIFRoZSBzYW1lIGhlYXAgYXJyYXkgaXMgdXNlZCB0byBidWlsZCBhbGwgdHJlZXMuXG4gICAqL1xuXG4gIHRoaXMuZGVwdGggPSBuZXcgVWludDE2QXJyYXkoMiAqIExfQ09ERVMgKyAxKTsgLy91Y2ggZGVwdGhbMipMX0NPREVTKzFdO1xuICB6ZXJvKHRoaXMuZGVwdGgpO1xuICAvKiBEZXB0aCBvZiBlYWNoIHN1YnRyZWUgdXNlZCBhcyB0aWUgYnJlYWtlciBmb3IgdHJlZXMgb2YgZXF1YWwgZnJlcXVlbmN5XG4gICAqL1xuXG4gIHRoaXMubF9idWYgPSAwOyAgICAgICAgICAvKiBidWZmZXIgaW5kZXggZm9yIGxpdGVyYWxzIG9yIGxlbmd0aHMgKi9cblxuICB0aGlzLmxpdF9idWZzaXplID0gMDtcbiAgLyogU2l6ZSBvZiBtYXRjaCBidWZmZXIgZm9yIGxpdGVyYWxzL2xlbmd0aHMuICBUaGVyZSBhcmUgNCByZWFzb25zIGZvclxuICAgKiBsaW1pdGluZyBsaXRfYnVmc2l6ZSB0byA2NEs6XG4gICAqICAgLSBmcmVxdWVuY2llcyBjYW4gYmUga2VwdCBpbiAxNiBiaXQgY291bnRlcnNcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZmlyc3QgYmxvY2ssIGFsbCBpbnB1dFxuICAgKiAgICAgZGF0YSBpcyBzdGlsbCBpbiB0aGUgd2luZG93IHNvIHdlIGNhbiBzdGlsbCBlbWl0IGEgc3RvcmVkIGJsb2NrIGV2ZW5cbiAgICogICAgIHdoZW4gaW5wdXQgY29tZXMgZnJvbSBzdGFuZGFyZCBpbnB1dC4gIChUaGlzIGNhbiBhbHNvIGJlIGRvbmUgZm9yXG4gICAqICAgICBhbGwgYmxvY2tzIGlmIGxpdF9idWZzaXplIGlzIG5vdCBncmVhdGVyIHRoYW4gMzJLLilcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciBhIGZpbGUgc21hbGxlciB0aGFuIDY0Sywgd2UgY2FuXG4gICAqICAgICBldmVuIGVtaXQgYSBzdG9yZWQgZmlsZSBpbnN0ZWFkIG9mIGEgc3RvcmVkIGJsb2NrIChzYXZpbmcgNSBieXRlcykuXG4gICAqICAgICBUaGlzIGlzIGFwcGxpY2FibGUgb25seSBmb3IgemlwIChub3QgZ3ppcCBvciB6bGliKS5cbiAgICogICAtIGNyZWF0aW5nIG5ldyBIdWZmbWFuIHRyZWVzIGxlc3MgZnJlcXVlbnRseSBtYXkgbm90IHByb3ZpZGUgZmFzdFxuICAgKiAgICAgYWRhcHRhdGlvbiB0byBjaGFuZ2VzIGluIHRoZSBpbnB1dCBkYXRhIHN0YXRpc3RpY3MuIChUYWtlIGZvclxuICAgKiAgICAgZXhhbXBsZSBhIGJpbmFyeSBmaWxlIHdpdGggcG9vcmx5IGNvbXByZXNzaWJsZSBjb2RlIGZvbGxvd2VkIGJ5XG4gICAqICAgICBhIGhpZ2hseSBjb21wcmVzc2libGUgc3RyaW5nIHRhYmxlLikgU21hbGxlciBidWZmZXIgc2l6ZXMgZ2l2ZVxuICAgKiAgICAgZmFzdCBhZGFwdGF0aW9uIGJ1dCBoYXZlIG9mIGNvdXJzZSB0aGUgb3ZlcmhlYWQgb2YgdHJhbnNtaXR0aW5nXG4gICAqICAgICB0cmVlcyBtb3JlIGZyZXF1ZW50bHkuXG4gICAqICAgLSBJIGNhbid0IGNvdW50IGFib3ZlIDRcbiAgICovXG5cbiAgdGhpcy5sYXN0X2xpdCA9IDA7ICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuXG4gIHRoaXMuZF9idWYgPSAwO1xuICAvKiBCdWZmZXIgaW5kZXggZm9yIGRpc3RhbmNlcy4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIGRfYnVmIGFuZCBsX2J1ZiBoYXZlXG4gICAqIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4gVG8gdXNlIGRpZmZlcmVudCBsZW5ndGhzLCBhbiBleHRyYSBmbGFnXG4gICAqIGFycmF5IHdvdWxkIGJlIG5lY2Vzc2FyeS5cbiAgICovXG5cbiAgdGhpcy5vcHRfbGVuID0gMDsgICAgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggb3B0aW1hbCB0cmVlcyAqL1xuICB0aGlzLnN0YXRpY19sZW4gPSAwOyAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBzdGF0aWMgdHJlZXMgKi9cbiAgdGhpcy5tYXRjaGVzID0gMDsgICAgICAgLyogbnVtYmVyIG9mIHN0cmluZyBtYXRjaGVzIGluIGN1cnJlbnQgYmxvY2sgKi9cbiAgdGhpcy5pbnNlcnQgPSAwOyAgICAgICAgLyogYnl0ZXMgYXQgZW5kIG9mIHdpbmRvdyBsZWZ0IHRvIGluc2VydCAqL1xuXG5cbiAgdGhpcy5iaV9idWYgPSAwO1xuICAvKiBPdXRwdXQgYnVmZmVyLiBiaXRzIGFyZSBpbnNlcnRlZCBzdGFydGluZyBhdCB0aGUgYm90dG9tIChsZWFzdFxuICAgKiBzaWduaWZpY2FudCBiaXRzKS5cbiAgICovXG4gIHRoaXMuYmlfdmFsaWQgPSAwO1xuICAvKiBOdW1iZXIgb2YgdmFsaWQgYml0cyBpbiBiaV9idWYuICBBbGwgYml0cyBhYm92ZSB0aGUgbGFzdCB2YWxpZCBiaXRcbiAgICogYXJlIGFsd2F5cyB6ZXJvLlxuICAgKi9cblxuICAvLyBVc2VkIGZvciB3aW5kb3cgbWVtb3J5IGluaXQuIFdlIHNhZmVseSBpZ25vcmUgaXQgZm9yIEpTLiBUaGF0IG1ha2VzXG4gIC8vIHNlbnNlIG9ubHkgZm9yIHBvaW50ZXJzIGFuZCBtZW1vcnkgY2hlY2sgdG9vbHMuXG4gIC8vdGhpcy5oaWdoX3dhdGVyID0gMDtcbiAgLyogSGlnaCB3YXRlciBtYXJrIG9mZnNldCBpbiB3aW5kb3cgZm9yIGluaXRpYWxpemVkIGJ5dGVzIC0tIGJ5dGVzIGFib3ZlXG4gICAqIHRoaXMgYXJlIHNldCB0byB6ZXJvIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayB3YXJuaW5ncyB3aGVuXG4gICAqIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMgYWNjZXNzIGJ5dGVzIHBhc3QgdGhlIGlucHV0LiAgVGhpcyBpcyB0aGVuXG4gICAqIHVwZGF0ZWQgdG8gdGhlIG5ldyBoaWdoIHdhdGVyIG1hcmsuXG4gICAqL1xufVxuXG5cbmNvbnN0IGRlZmxhdGVSZXNldEtlZXAgPSAoc3RybSkgPT4ge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gMDtcbiAgc3RybS5kYXRhX3R5cGUgPSBaX1VOS05PV047XG5cbiAgY29uc3QgcyA9IHN0cm0uc3RhdGU7XG4gIHMucGVuZGluZyA9IDA7XG4gIHMucGVuZGluZ19vdXQgPSAwO1xuXG4gIGlmIChzLndyYXAgPCAwKSB7XG4gICAgcy53cmFwID0gLXMud3JhcDtcbiAgICAvKiB3YXMgbWFkZSBuZWdhdGl2ZSBieSBkZWZsYXRlKC4uLiwgWl9GSU5JU0gpOyAqL1xuICB9XG4gIHMuc3RhdHVzID0gKHMud3JhcCA/IElOSVRfU1RBVEUgOiBCVVNZX1NUQVRFKTtcbiAgc3RybS5hZGxlciA9IChzLndyYXAgPT09IDIpID9cbiAgICAwICAvLyBjcmMzMigwLCBaX05VTEwsIDApXG4gIDpcbiAgICAxOyAvLyBhZGxlcjMyKDAsIFpfTlVMTCwgMClcbiAgcy5sYXN0X2ZsdXNoID0gWl9OT19GTFVTSDtcbiAgX3RyX2luaXQocyk7XG4gIHJldHVybiBaX09LO1xufTtcblxuXG5jb25zdCBkZWZsYXRlUmVzZXQgPSAoc3RybSkgPT4ge1xuXG4gIGNvbnN0IHJldCA9IGRlZmxhdGVSZXNldEtlZXAoc3RybSk7XG4gIGlmIChyZXQgPT09IFpfT0spIHtcbiAgICBsbV9pbml0KHN0cm0uc3RhdGUpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5cbmNvbnN0IGRlZmxhdGVTZXRIZWFkZXIgPSAoc3RybSwgaGVhZCkgPT4ge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgaWYgKHN0cm0uc3RhdGUud3JhcCAhPT0gMikgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RybS5zdGF0ZS5nemhlYWQgPSBoZWFkO1xuICByZXR1cm4gWl9PSztcbn07XG5cblxuY29uc3QgZGVmbGF0ZUluaXQyID0gKHN0cm0sIGxldmVsLCBtZXRob2QsIHdpbmRvd0JpdHMsIG1lbUxldmVsLCBzdHJhdGVneSkgPT4ge1xuXG4gIGlmICghc3RybSkgeyAvLyA9PT0gWl9OVUxMXG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIGxldCB3cmFwID0gMTtcblxuICBpZiAobGV2ZWwgPT09IFpfREVGQVVMVF9DT01QUkVTU0lPTikge1xuICAgIGxldmVsID0gNjtcbiAgfVxuXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkgeyAvKiBzdXBwcmVzcyB6bGliIHdyYXBwZXIgKi9cbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmICh3aW5kb3dCaXRzID4gMTUpIHtcbiAgICB3cmFwID0gMjsgICAgICAgICAgIC8qIHdyaXRlIGd6aXAgd3JhcHBlciBpbnN0ZWFkICovXG4gICAgd2luZG93Qml0cyAtPSAxNjtcbiAgfVxuXG5cbiAgaWYgKG1lbUxldmVsIDwgMSB8fCBtZW1MZXZlbCA+IE1BWF9NRU1fTEVWRUwgfHwgbWV0aG9kICE9PSBaX0RFRkxBVEVEIHx8XG4gICAgd2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1IHx8IGxldmVsIDwgMCB8fCBsZXZlbCA+IDkgfHxcbiAgICBzdHJhdGVneSA8IDAgfHwgc3RyYXRlZ3kgPiBaX0ZJWEVEKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuXG4gIGlmICh3aW5kb3dCaXRzID09PSA4KSB7XG4gICAgd2luZG93Qml0cyA9IDk7XG4gIH1cbiAgLyogdW50aWwgMjU2LWJ5dGUgd2luZG93IGJ1ZyBmaXhlZCAqL1xuXG4gIGNvbnN0IHMgPSBuZXcgRGVmbGF0ZVN0YXRlKCk7XG5cbiAgc3RybS5zdGF0ZSA9IHM7XG4gIHMuc3RybSA9IHN0cm07XG5cbiAgcy53cmFwID0gd3JhcDtcbiAgcy5nemhlYWQgPSBudWxsO1xuICBzLndfYml0cyA9IHdpbmRvd0JpdHM7XG4gIHMud19zaXplID0gMSA8PCBzLndfYml0cztcbiAgcy53X21hc2sgPSBzLndfc2l6ZSAtIDE7XG5cbiAgcy5oYXNoX2JpdHMgPSBtZW1MZXZlbCArIDc7XG4gIHMuaGFzaF9zaXplID0gMSA8PCBzLmhhc2hfYml0cztcbiAgcy5oYXNoX21hc2sgPSBzLmhhc2hfc2l6ZSAtIDE7XG4gIHMuaGFzaF9zaGlmdCA9IH5+KChzLmhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTtcblxuICBzLndpbmRvdyA9IG5ldyBVaW50OEFycmF5KHMud19zaXplICogMik7XG4gIHMuaGVhZCA9IG5ldyBVaW50MTZBcnJheShzLmhhc2hfc2l6ZSk7XG4gIHMucHJldiA9IG5ldyBVaW50MTZBcnJheShzLndfc2l6ZSk7XG5cbiAgLy8gRG9uJ3QgbmVlZCBtZW0gaW5pdCBtYWdpYyBmb3IgSlMuXG4gIC8vcy5oaWdoX3dhdGVyID0gMDsgIC8qIG5vdGhpbmcgd3JpdHRlbiB0byBzLT53aW5kb3cgeWV0ICovXG5cbiAgcy5saXRfYnVmc2l6ZSA9IDEgPDwgKG1lbUxldmVsICsgNik7IC8qIDE2SyBlbGVtZW50cyBieSBkZWZhdWx0ICovXG5cbiAgcy5wZW5kaW5nX2J1Zl9zaXplID0gcy5saXRfYnVmc2l6ZSAqIDQ7XG5cbiAgLy9vdmVybGF5ID0gKHVzaGYgKikgWkFMTE9DKHN0cm0sIHMtPmxpdF9idWZzaXplLCBzaXplb2YodXNoKSsyKTtcbiAgLy9zLT5wZW5kaW5nX2J1ZiA9ICh1Y2hmICopIG92ZXJsYXk7XG4gIHMucGVuZGluZ19idWYgPSBuZXcgVWludDhBcnJheShzLnBlbmRpbmdfYnVmX3NpemUpO1xuXG4gIC8vIEl0IGlzIG9mZnNldCBmcm9tIGBzLnBlbmRpbmdfYnVmYCAoc2l6ZSBpcyBgcy5saXRfYnVmc2l6ZSAqIDJgKVxuICAvL3MtPmRfYnVmID0gb3ZlcmxheSArIHMtPmxpdF9idWZzaXplL3NpemVvZih1c2gpO1xuICBzLmRfYnVmID0gMSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgLy9zLT5sX2J1ZiA9IHMtPnBlbmRpbmdfYnVmICsgKDErc2l6ZW9mKHVzaCkpKnMtPmxpdF9idWZzaXplO1xuICBzLmxfYnVmID0gKDEgKyAyKSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgcy5sZXZlbCA9IGxldmVsO1xuICBzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gIHMubWV0aG9kID0gbWV0aG9kO1xuXG4gIHJldHVybiBkZWZsYXRlUmVzZXQoc3RybSk7XG59O1xuXG5jb25zdCBkZWZsYXRlSW5pdCA9IChzdHJtLCBsZXZlbCkgPT4ge1xuXG4gIHJldHVybiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIFpfREVGTEFURUQsIE1BWF9XQklUUywgREVGX01FTV9MRVZFTCwgWl9ERUZBVUxUX1NUUkFURUdZKTtcbn07XG5cblxuY29uc3QgZGVmbGF0ZSA9IChzdHJtLCBmbHVzaCkgPT4ge1xuXG4gIGxldCBiZWcsIHZhbDsgLy8gZm9yIGd6aXAgaGVhZGVyIHdyaXRlIG9ubHlcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHxcbiAgICBmbHVzaCA+IFpfQkxPQ0sgfHwgZmx1c2ggPCAwKSB7XG4gICAgcmV0dXJuIHN0cm0gPyBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpIDogWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBjb25zdCBzID0gc3RybS5zdGF0ZTtcblxuICBpZiAoIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkgfHxcbiAgICAgIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIGZsdXNoICE9PSBaX0ZJTklTSCkpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIChzdHJtLmF2YWlsX291dCA9PT0gMCkgPyBaX0JVRl9FUlJPUiA6IFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHMuc3RybSA9IHN0cm07IC8qIGp1c3QgaW4gY2FzZSAqL1xuICBjb25zdCBvbGRfZmx1c2ggPSBzLmxhc3RfZmx1c2g7XG4gIHMubGFzdF9mbHVzaCA9IGZsdXNoO1xuXG4gIC8qIFdyaXRlIHRoZSBoZWFkZXIgKi9cbiAgaWYgKHMuc3RhdHVzID09PSBJTklUX1NUQVRFKSB7XG5cbiAgICBpZiAocy53cmFwID09PSAyKSB7IC8vIEdaSVAgaGVhZGVyXG4gICAgICBzdHJtLmFkbGVyID0gMDsgIC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICBwdXRfYnl0ZShzLCAzMSk7XG4gICAgICBwdXRfYnl0ZShzLCAxMzkpO1xuICAgICAgcHV0X2J5dGUocywgOCk7XG4gICAgICBpZiAoIXMuZ3poZWFkKSB7IC8vIHMtPmd6aGVhZCA9PSBaX05VTExcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIE9TX0NPREUpO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRleHQgPyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAocy5nemhlYWQuaGNyYyA/IDIgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuZXh0cmEgPyAwIDogNCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLm5hbWUgPyAwIDogOCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmNvbW1lbnQgPyAwIDogMTYpXG4gICAgICAgICk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMTYpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDI0KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLm9zICYgMHhmZik7XG4gICAgICAgIGlmIChzLmd6aGVhZC5leHRyYSAmJiBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmKTtcbiAgICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQuZXh0cmEubGVuZ3RoID4+IDgpICYgMHhmZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IEVYVFJBX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIC8vIERFRkxBVEUgaGVhZGVyXG4gICAge1xuICAgICAgbGV0IGhlYWRlciA9IChaX0RFRkxBVEVEICsgKChzLndfYml0cyAtIDgpIDw8IDQpKSA8PCA4O1xuICAgICAgbGV0IGxldmVsX2ZsYWdzID0gLTE7XG5cbiAgICAgIGlmIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyKSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA8IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsID09PSA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMztcbiAgICAgIH1cbiAgICAgIGhlYWRlciB8PSAobGV2ZWxfZmxhZ3MgPDwgNik7XG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkgeyBoZWFkZXIgfD0gUFJFU0VUX0RJQ1Q7IH1cbiAgICAgIGhlYWRlciArPSAzMSAtIChoZWFkZXIgJSAzMSk7XG5cbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIHB1dFNob3J0TVNCKHMsIGhlYWRlcik7XG5cbiAgICAgIC8qIFNhdmUgdGhlIGFkbGVyMzIgb2YgdGhlIHByZXNldCBkaWN0aW9uYXJ5OiAqL1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSAxOyAvLyBhZGxlcjMyKDBMLCBaX05VTEwsIDApO1xuICAgIH1cbiAgfVxuXG4vLyNpZmRlZiBHWklQXG4gIGlmIChzLnN0YXR1cyA9PT0gRVhUUkFfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuZXh0cmEvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuXG4gICAgICB3aGlsZSAocy5nemluZGV4IDwgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmZmZikpIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYVtzLmd6aW5kZXhdICYgMHhmZik7XG4gICAgICAgIHMuZ3ppbmRleCsrO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAocy5nemluZGV4ID09PSBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBOQU1FX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLm5hbWUvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5uYW1lLmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IENPTU1FTlRfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuY29tbWVudC8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLmNvbW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQuY29tbWVudC5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gSENSQ19TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA+IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgfVxuICAgICAgaWYgKHMucGVuZGluZyArIDIgPD0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgc3RybS5hZGxlciA9IDA7IC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgfVxuICB9XG4vLyNlbmRpZlxuXG4gIC8qIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUgKi9cbiAgaWYgKHMucGVuZGluZyAhPT0gMCkge1xuICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAvKiBTaW5jZSBhdmFpbF9vdXQgaXMgMCwgZGVmbGF0ZSB3aWxsIGJlIGNhbGxlZCBhZ2FpbiB3aXRoXG4gICAgICAgKiBtb3JlIG91dHB1dCBzcGFjZSwgYnV0IHBvc3NpYmx5IHdpdGggYm90aCBwZW5kaW5nIGFuZFxuICAgICAgICogYXZhaWxfaW4gZXF1YWwgdG8gemVyby4gVGhlcmUgd29uJ3QgYmUgYW55dGhpbmcgdG8gZG8sXG4gICAgICAgKiBidXQgdGhpcyBpcyBub3QgYW4gZXJyb3Igc2l0dWF0aW9uIHNvIG1ha2Ugc3VyZSB3ZVxuICAgICAgICogcmV0dXJuIE9LIGluc3RlYWQgb2YgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCBvZiBkZWZsYXRlOlxuICAgICAgICovXG4gICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgIHJldHVybiBaX09LO1xuICAgIH1cblxuICAgIC8qIE1ha2Ugc3VyZSB0aGVyZSBpcyBzb21ldGhpbmcgdG8gZG8gYW5kIGF2b2lkIGR1cGxpY2F0ZSBjb25zZWN1dGl2ZVxuICAgICAqIGZsdXNoZXMuIEZvciByZXBlYXRlZCBhbmQgdXNlbGVzcyBjYWxscyB3aXRoIFpfRklOSVNILCB3ZSBrZWVwXG4gICAgICogcmV0dXJuaW5nIFpfU1RSRUFNX0VORCBpbnN0ZWFkIG9mIFpfQlVGX0VSUk9SLlxuICAgICAqL1xuICB9IGVsc2UgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgcmFuayhmbHVzaCkgPD0gcmFuayhvbGRfZmx1c2gpICYmXG4gICAgZmx1c2ggIT09IFpfRklOSVNIKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBVc2VyIG11c3Qgbm90IHByb3ZpZGUgbW9yZSBpbnB1dCBhZnRlciB0aGUgZmlyc3QgRklOSVNIOiAqL1xuICBpZiAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBTdGFydCBhIG5ldyBibG9jayBvciBjb250aW51ZSB0aGUgY3VycmVudCBvbmUuXG4gICAqL1xuICBpZiAoc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBzLmxvb2thaGVhZCAhPT0gMCB8fFxuICAgIChmbHVzaCAhPT0gWl9OT19GTFVTSCAmJiBzLnN0YXR1cyAhPT0gRklOSVNIX1NUQVRFKSkge1xuICAgIGxldCBic3RhdGUgPSAocy5zdHJhdGVneSA9PT0gWl9IVUZGTUFOX09OTFkpID8gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSA6XG4gICAgICAocy5zdHJhdGVneSA9PT0gWl9STEUgPyBkZWZsYXRlX3JsZShzLCBmbHVzaCkgOlxuICAgICAgICBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmZ1bmMocywgZmx1c2gpKTtcblxuICAgIGlmIChic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX0RPTkUpIHtcbiAgICAgIHMuc3RhdHVzID0gRklOSVNIX1NUQVRFO1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19ORUVEX01PUkUgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgICAvKiBhdm9pZCBCVUZfRVJST1IgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgIH1cbiAgICAgIHJldHVybiBaX09LO1xuICAgICAgLyogSWYgZmx1c2ggIT0gWl9OT19GTFVTSCAmJiBhdmFpbF9vdXQgPT0gMCwgdGhlIG5leHQgY2FsbFxuICAgICAgICogb2YgZGVmbGF0ZSBzaG91bGQgdXNlIHRoZSBzYW1lIGZsdXNoIHBhcmFtZXRlciB0byBtYWtlIHN1cmVcbiAgICAgICAqIHRoYXQgdGhlIGZsdXNoIGlzIGNvbXBsZXRlLiBTbyB3ZSBkb24ndCBoYXZlIHRvIG91dHB1dCBhblxuICAgICAgICogZW1wdHkgYmxvY2sgaGVyZSwgdGhpcyB3aWxsIGJlIGRvbmUgYXQgbmV4dCBjYWxsLiBUaGlzIGFsc29cbiAgICAgICAqIGVuc3VyZXMgdGhhdCBmb3IgYSB2ZXJ5IHNtYWxsIG91dHB1dCBidWZmZXIsIHdlIGVtaXQgYXQgbW9zdFxuICAgICAgICogb25lIGVtcHR5IGJsb2NrLlxuICAgICAgICovXG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX0JMT0NLX0RPTkUpIHtcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9QQVJUSUFMX0ZMVVNIKSB7XG4gICAgICAgIF90cl9hbGlnbihzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGZsdXNoICE9PSBaX0JMT0NLKSB7IC8qIEZVTExfRkxVU0ggb3IgU1lOQ19GTFVTSCAqL1xuXG4gICAgICAgIF90cl9zdG9yZWRfYmxvY2socywgMCwgMCwgZmFsc2UpO1xuICAgICAgICAvKiBGb3IgYSBmdWxsIGZsdXNoLCB0aGlzIGVtcHR5IGJsb2NrIHdpbGwgYmUgcmVjb2duaXplZFxuICAgICAgICAgKiBhcyBhIHNwZWNpYWwgbWFya2VyIGJ5IGluZmxhdGVfc3luYygpLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZVTExfRkxVU0gpIHtcbiAgICAgICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi8gICAgICAgICAgICAgLyogZm9yZ2V0IGhpc3RvcnkgKi9cbiAgICAgICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICAgICAgICBzLmluc2VydCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xOyAvKiBhdm9pZCBCVUZfRVJST1IgYXQgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0KHN0cm0tPmF2YWlsX291dCA+IDAsIFwiYnVnMlwiKTtcbiAgLy9pZiAoc3RybS5hdmFpbF9vdXQgPD0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJidWcyXCIpO31cblxuICBpZiAoZmx1c2ggIT09IFpfRklOSVNIKSB7IHJldHVybiBaX09LOyB9XG4gIGlmIChzLndyYXAgPD0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRU5EOyB9XG5cbiAgLyogV3JpdGUgdGhlIHRyYWlsZXIgKi9cbiAgaWYgKHMud3JhcCA9PT0gMikge1xuICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDI0KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDI0KSAmIDB4ZmYpO1xuICB9XG4gIGVsc2VcbiAge1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgfVxuXG4gIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gIC8qIElmIGF2YWlsX291dCBpcyB6ZXJvLCB0aGUgYXBwbGljYXRpb24gd2lsbCBjYWxsIGRlZmxhdGUgYWdhaW5cbiAgICogdG8gZmx1c2ggdGhlIHJlc3QuXG4gICAqL1xuICBpZiAocy53cmFwID4gMCkgeyBzLndyYXAgPSAtcy53cmFwOyB9XG4gIC8qIHdyaXRlIHRoZSB0cmFpbGVyIG9ubHkgb25jZSEgKi9cbiAgcmV0dXJuIHMucGVuZGluZyAhPT0gMCA/IFpfT0sgOiBaX1NUUkVBTV9FTkQ7XG59O1xuXG5cbmNvbnN0IGRlZmxhdGVFbmQgPSAoc3RybSkgPT4ge1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgY29uc3Qgc3RhdHVzID0gc3RybS5zdGF0ZS5zdGF0dXM7XG4gIGlmIChzdGF0dXMgIT09IElOSVRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEVYVFJBX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBOQU1FX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBDT01NRU5UX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBIQ1JDX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBCVVNZX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBGSU5JU0hfU1RBVEVcbiAgKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnN0YXRlID0gbnVsbDtcblxuICByZXR1cm4gc3RhdHVzID09PSBCVVNZX1NUQVRFID8gZXJyKHN0cm0sIFpfREFUQV9FUlJPUikgOiBaX09LO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplcyB0aGUgY29tcHJlc3Npb24gZGljdGlvbmFyeSBmcm9tIHRoZSBnaXZlbiBieXRlXG4gKiBzZXF1ZW5jZSB3aXRob3V0IHByb2R1Y2luZyBhbnkgY29tcHJlc3NlZCBvdXRwdXQuXG4gKi9cbmNvbnN0IGRlZmxhdGVTZXREaWN0aW9uYXJ5ID0gKHN0cm0sIGRpY3Rpb25hcnkpID0+IHtcblxuICBsZXQgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgY29uc3QgcyA9IHN0cm0uc3RhdGU7XG4gIGNvbnN0IHdyYXAgPSBzLndyYXA7XG5cbiAgaWYgKHdyYXAgPT09IDIgfHwgKHdyYXAgPT09IDEgJiYgcy5zdGF0dXMgIT09IElOSVRfU1RBVEUpIHx8IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogd2hlbiB1c2luZyB6bGliIHdyYXBwZXJzLCBjb21wdXRlIEFkbGVyLTMyIGZvciBwcm92aWRlZCBkaWN0aW9uYXJ5ICovXG4gIGlmICh3cmFwID09PSAxKSB7XG4gICAgLyogYWRsZXIzMihzdHJtLT5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gIH1cblxuICBzLndyYXAgPSAwOyAgIC8qIGF2b2lkIGNvbXB1dGluZyBBZGxlci0zMiBpbiByZWFkX2J1ZiAqL1xuXG4gIC8qIGlmIGRpY3Rpb25hcnkgd291bGQgZmlsbCB3aW5kb3csIGp1c3QgcmVwbGFjZSB0aGUgaGlzdG9yeSAqL1xuICBpZiAoZGljdExlbmd0aCA+PSBzLndfc2l6ZSkge1xuICAgIGlmICh3cmFwID09PSAwKSB7ICAgICAgICAgICAgLyogYWxyZWFkeSBlbXB0eSBvdGhlcndpc2UgKi9cbiAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICB9XG4gICAgLyogdXNlIHRoZSB0YWlsICovXG4gICAgLy8gZGljdGlvbmFyeSA9IGRpY3Rpb25hcnkuc2xpY2UoZGljdExlbmd0aCAtIHMud19zaXplKTtcbiAgICBsZXQgdG1wRGljdCA9IG5ldyBVaW50OEFycmF5KHMud19zaXplKTtcbiAgICB0bXBEaWN0LnNldChkaWN0aW9uYXJ5LnN1YmFycmF5KGRpY3RMZW5ndGggLSBzLndfc2l6ZSwgZGljdExlbmd0aCksIDApO1xuICAgIGRpY3Rpb25hcnkgPSB0bXBEaWN0O1xuICAgIGRpY3RMZW5ndGggPSBzLndfc2l6ZTtcbiAgfVxuICAvKiBpbnNlcnQgZGljdGlvbmFyeSBpbnRvIHdpbmRvdyBhbmQgaGFzaCAqL1xuICBjb25zdCBhdmFpbCA9IHN0cm0uYXZhaWxfaW47XG4gIGNvbnN0IG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGNvbnN0IGlucHV0ID0gc3RybS5pbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGRpY3RMZW5ndGg7XG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uaW5wdXQgPSBkaWN0aW9uYXJ5O1xuICBmaWxsX3dpbmRvdyhzKTtcbiAgd2hpbGUgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgIGxldCBzdHIgPSBzLnN0cnN0YXJ0O1xuICAgIGxldCBuID0gcy5sb29rYWhlYWQgLSAoTUlOX01BVENIIC0gMSk7XG4gICAgZG8ge1xuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pO1xuXG4gICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuXG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICBzdHIrKztcbiAgICB9IHdoaWxlICgtLW4pO1xuICAgIHMuc3Ryc3RhcnQgPSBzdHI7XG4gICAgcy5sb29rYWhlYWQgPSBNSU5fTUFUQ0ggLSAxO1xuICAgIGZpbGxfd2luZG93KHMpO1xuICB9XG4gIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBzLmluc2VydCA9IHMubG9va2FoZWFkO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5pbnB1dCA9IGlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gYXZhaWw7XG4gIHMud3JhcCA9IHdyYXA7XG4gIHJldHVybiBaX09LO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlSW5pdCA9IGRlZmxhdGVJbml0O1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZUluaXQyID0gZGVmbGF0ZUluaXQyO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZVJlc2V0ID0gZGVmbGF0ZVJlc2V0O1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZVJlc2V0S2VlcCA9IGRlZmxhdGVSZXNldEtlZXA7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlU2V0SGVhZGVyID0gZGVmbGF0ZVNldEhlYWRlcjtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZUVuZCA9IGRlZmxhdGVFbmQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlU2V0RGljdGlvbmFyeSA9IGRlZmxhdGVTZXREaWN0aW9uYXJ5O1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZUluZm8gPSAncGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZUJvdW5kID0gZGVmbGF0ZUJvdW5kO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZUNvcHkgPSBkZWZsYXRlQ29weTtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVQYXJhbXMgPSBkZWZsYXRlUGFyYW1zO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZVBlbmRpbmcgPSBkZWZsYXRlUGVuZGluZztcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVQcmltZSA9IGRlZmxhdGVQcmltZTtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVUdW5lID0gZGVmbGF0ZVR1bmU7XG4qL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIEdaaGVhZGVyKCkge1xuICAvKiB0cnVlIGlmIGNvbXByZXNzZWQgZGF0YSBiZWxpZXZlZCB0byBiZSB0ZXh0ICovXG4gIHRoaXMudGV4dCAgICAgICA9IDA7XG4gIC8qIG1vZGlmaWNhdGlvbiB0aW1lICovXG4gIHRoaXMudGltZSAgICAgICA9IDA7XG4gIC8qIGV4dHJhIGZsYWdzIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMueGZsYWdzICAgICA9IDA7XG4gIC8qIG9wZXJhdGluZyBzeXN0ZW0gKi9cbiAgdGhpcy5vcyAgICAgICAgID0gMDtcbiAgLyogcG9pbnRlciB0byBleHRyYSBmaWVsZCBvciBaX05VTEwgaWYgbm9uZSAqL1xuICB0aGlzLmV4dHJhICAgICAgPSBudWxsO1xuICAvKiBleHRyYSBmaWVsZCBsZW5ndGggKHZhbGlkIGlmIGV4dHJhICE9IFpfTlVMTCkgKi9cbiAgdGhpcy5leHRyYV9sZW4gID0gMDsgLy8gQWN0dWFsbHksIHdlIGRvbid0IG5lZWQgaXQgaW4gSlMsXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBsZWF2ZSBmb3IgZmV3IGNvZGUgbW9kaWZpY2F0aW9uc1xuXG4gIC8vXG4gIC8vIFNldHVwIGxpbWl0cyBpcyBub3QgbmVjZXNzYXJ5IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnlcbiAgLy8gZm9yIGluZmxhdGUgdXNlIGNvbnN0YW50IGxpbWl0IGluIDY1NTM2IGJ5dGVzXG4gIC8vXG5cbiAgLyogc3BhY2UgYXQgZXh0cmEgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5leHRyYV9tYXggID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgZmlsZSBuYW1lIG9yIFpfTlVMTCAqL1xuICB0aGlzLm5hbWUgICAgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgbmFtZSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLm5hbWVfbWF4ICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBjb21tZW50IG9yIFpfTlVMTCAqL1xuICB0aGlzLmNvbW1lbnQgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgY29tbWVudCAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmNvbW1fbWF4ICAgPSAwO1xuICAvKiB0cnVlIGlmIHRoZXJlIHdhcyBvciB3aWxsIGJlIGEgaGVhZGVyIGNyYyAqL1xuICB0aGlzLmhjcmMgICAgICAgPSAwO1xuICAvKiB0cnVlIHdoZW4gZG9uZSByZWFkaW5nIGd6aXAgaGVhZGVyIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMuZG9uZSAgICAgICA9IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdaaGVhZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8vIFNlZSBzdGF0ZSBkZWZzIGZyb20gaW5mbGF0ZS5qc1xuY29uc3QgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbmNvbnN0IFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG5cbi8qXG4gICBEZWNvZGUgbGl0ZXJhbCwgbGVuZ3RoLCBhbmQgZGlzdGFuY2UgY29kZXMgYW5kIHdyaXRlIG91dCB0aGUgcmVzdWx0aW5nXG4gICBsaXRlcmFsIGFuZCBtYXRjaCBieXRlcyB1bnRpbCBlaXRoZXIgbm90IGVub3VnaCBpbnB1dCBvciBvdXRwdXQgaXNcbiAgIGF2YWlsYWJsZSwgYW4gZW5kLW9mLWJsb2NrIGlzIGVuY291bnRlcmVkLCBvciBhIGRhdGEgZXJyb3IgaXMgZW5jb3VudGVyZWQuXG4gICBXaGVuIGxhcmdlIGVub3VnaCBpbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgYXJlIHN1cHBsaWVkIHRvIGluZmxhdGUoKSwgZm9yXG4gICBleGFtcGxlLCBhIDE2SyBpbnB1dCBidWZmZXIgYW5kIGEgNjRLIG91dHB1dCBidWZmZXIsIG1vcmUgdGhhbiA5NSUgb2YgdGhlXG4gICBpbmZsYXRlIGV4ZWN1dGlvbiB0aW1lIGlzIHNwZW50IGluIHRoaXMgcm91dGluZS5cblxuICAgRW50cnkgYXNzdW1wdGlvbnM6XG5cbiAgICAgICAgc3RhdGUubW9kZSA9PT0gTEVOXG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPj0gNlxuICAgICAgICBzdHJtLmF2YWlsX291dCA+PSAyNThcbiAgICAgICAgc3RhcnQgPj0gc3RybS5hdmFpbF9vdXRcbiAgICAgICAgc3RhdGUuYml0cyA8IDhcblxuICAgT24gcmV0dXJuLCBzdGF0ZS5tb2RlIGlzIG9uZSBvZjpcblxuICAgICAgICBMRU4gLS0gcmFuIG91dCBvZiBlbm91Z2ggb3V0cHV0IHNwYWNlIG9yIGVub3VnaCBhdmFpbGFibGUgaW5wdXRcbiAgICAgICAgVFlQRSAtLSByZWFjaGVkIGVuZCBvZiBibG9jayBjb2RlLCBpbmZsYXRlKCkgdG8gaW50ZXJwcmV0IG5leHQgYmxvY2tcbiAgICAgICAgQkFEIC0tIGVycm9yIGluIGJsb2NrIGRhdGFcblxuICAgTm90ZXM6XG5cbiAgICAtIFRoZSBtYXhpbXVtIGlucHV0IGJpdHMgdXNlZCBieSBhIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGlzIDE1IGJpdHMgZm9yIHRoZVxuICAgICAgbGVuZ3RoIGNvZGUsIDUgYml0cyBmb3IgdGhlIGxlbmd0aCBleHRyYSwgMTUgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGNvZGUsXG4gICAgICBhbmQgMTMgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGV4dHJhLiAgVGhpcyB0b3RhbHMgNDggYml0cywgb3Igc2l4IGJ5dGVzLlxuICAgICAgVGhlcmVmb3JlIGlmIHN0cm0uYXZhaWxfaW4gPj0gNiwgdGhlbiB0aGVyZSBpcyBlbm91Z2ggaW5wdXQgdG8gYXZvaWRcbiAgICAgIGNoZWNraW5nIGZvciBhdmFpbGFibGUgaW5wdXQgd2hpbGUgZGVjb2RpbmcuXG5cbiAgICAtIFRoZSBtYXhpbXVtIGJ5dGVzIHRoYXQgYSBzaW5nbGUgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgY2FuIG91dHB1dCBpcyAyNThcbiAgICAgIGJ5dGVzLCB3aGljaCBpcyB0aGUgbWF4aW11bSBsZW5ndGggdGhhdCBjYW4gYmUgY29kZWQuICBpbmZsYXRlX2Zhc3QoKVxuICAgICAgcmVxdWlyZXMgc3RybS5hdmFpbF9vdXQgPj0gMjU4IGZvciBlYWNoIGxvb3AgdG8gYXZvaWQgY2hlY2tpbmcgZm9yXG4gICAgICBvdXRwdXQgc3BhY2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV9mYXN0KHN0cm0sIHN0YXJ0KSB7XG4gIGxldCBfaW47ICAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmlucHV0ICovXG4gIGxldCBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBoYXZlIGVub3VnaCBpbnB1dCB3aGlsZSBpbiA8IGxhc3QgKi9cbiAgbGV0IF9vdXQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ub3V0cHV0ICovXG4gIGxldCBiZWc7ICAgICAgICAgICAgICAgICAgICAvKiBpbmZsYXRlKCkncyBpbml0aWFsIHN0cm0ub3V0cHV0ICovXG4gIGxldCBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB3aGlsZSBvdXQgPCBlbmQsIGVub3VnaCBzcGFjZSBhdmFpbGFibGUgKi9cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIGxldCBkbWF4OyAgICAgICAgICAgICAgICAgICAvKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gemxpYiBoZWFkZXIgKi9cbi8vI2VuZGlmXG4gIGxldCB3c2l6ZTsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgbGV0IHdoYXZlOyAgICAgICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgbGV0IHduZXh0OyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICAvLyBVc2UgYHNfd2luZG93YCBpbnN0ZWFkIGB3aW5kb3dgLCBhdm9pZCBjb25mbGljdCB3aXRoIGluc3RydW1lbnRhdGlvbiB0b29sc1xuICBsZXQgc193aW5kb3c7ICAgICAgICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiB3c2l6ZSAhPSAwICovXG4gIGxldCBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmhvbGQgKi9cbiAgbGV0IGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uYml0cyAqL1xuICBsZXQgbGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5sZW5jb2RlICovXG4gIGxldCBkY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmRpc3Rjb2RlICovXG4gIGxldCBsbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBsZW5ndGggY29kZXMgKi9cbiAgbGV0IGRtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGRpc3RhbmNlIGNvZGVzICovXG4gIGxldCBoZXJlOyAgICAgICAgICAgICAgICAgICAvKiByZXRyaWV2ZWQgdGFibGUgZW50cnkgKi9cbiAgbGV0IG9wOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgYml0cywgb3BlcmF0aW9uLCBleHRyYSBiaXRzLCBvciAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIHdpbmRvdyBwb3NpdGlvbiwgd2luZG93IGJ5dGVzIHRvIGNvcHkgKi9cbiAgbGV0IGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCwgdW51c2VkIGJ5dGVzICovXG4gIGxldCBkaXN0OyAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBkaXN0YW5jZSAqL1xuICBsZXQgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBmcm9tICovXG4gIGxldCBmcm9tX3NvdXJjZTtcblxuXG4gIGxldCBpbnB1dCwgb3V0cHV0OyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG5cbiAgLyogY29weSBzdGF0ZSB0byBsb2NhbCB2YXJpYWJsZXMgKi9cbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICAvL2hlcmUgPSBzdGF0ZS5oZXJlO1xuICBfaW4gPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgbGFzdCA9IF9pbiArIChzdHJtLmF2YWlsX2luIC0gNSk7XG4gIF9vdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgYmVnID0gX291dCAtIChzdGFydCAtIHN0cm0uYXZhaWxfb3V0KTtcbiAgZW5kID0gX291dCArIChzdHJtLmF2YWlsX291dCAtIDI1Nyk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICBkbWF4ID0gc3RhdGUuZG1heDtcbi8vI2VuZGlmXG4gIHdzaXplID0gc3RhdGUud3NpemU7XG4gIHdoYXZlID0gc3RhdGUud2hhdmU7XG4gIHduZXh0ID0gc3RhdGUud25leHQ7XG4gIHNfd2luZG93ID0gc3RhdGUud2luZG93O1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIGxjb2RlID0gc3RhdGUubGVuY29kZTtcbiAgZGNvZGUgPSBzdGF0ZS5kaXN0Y29kZTtcbiAgbG1hc2sgPSAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDE7XG4gIGRtYXNrID0gKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMTtcblxuXG4gIC8qIGRlY29kZSBsaXRlcmFscyBhbmQgbGVuZ3RoL2Rpc3RhbmNlcyB1bnRpbCBlbmQtb2YtYmxvY2sgb3Igbm90IGVub3VnaFxuICAgICBpbnB1dCBkYXRhIG9yIG91dHB1dCBzcGFjZSAqL1xuXG4gIHRvcDpcbiAgZG8ge1xuICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgIH1cblxuICAgIGhlcmUgPSBsY29kZVtob2xkICYgbG1hc2tdO1xuXG4gICAgZG9sZW46XG4gICAgZm9yICg7OykgeyAvLyBHb3RvIGVtdWxhdGlvblxuICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICBob2xkID4+Pj0gb3A7XG4gICAgICBiaXRzIC09IG9wO1xuICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuICAgICAgaWYgKG9wID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsaXRlcmFsICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIG91dHB1dFtfb3V0KytdID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggYmFzZSAqL1xuICAgICAgICBsZW4gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICBpZiAob3ApIHtcbiAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW4gKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBsZW4pKTtcbiAgICAgICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIGhlcmUgPSBkY29kZVtob2xkICYgZG1hc2tdO1xuXG4gICAgICAgIGRvZGlzdDpcbiAgICAgICAgZm9yICg7OykgeyAvLyBnb3RvIGVtdWxhdGlvblxuICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcblxuICAgICAgICAgIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhc2UgKi9cbiAgICAgICAgICAgIGRpc3QgPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzdCArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgICAgIGlmIChkaXN0ID4gZG1heCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBkaXN0KSk7XG4gICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7ICAgICAgICAgICAgICAgIC8qIG1heCBkaXN0YW5jZSBpbiBvdXRwdXQgKi9cbiAgICAgICAgICAgIGlmIChkaXN0ID4gb3ApIHsgICAgICAgICAgICAgICAgLyogc2VlIGlmIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgb3AgPSBkaXN0IC0gb3A7ICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgICAgICAgIGlmIChsZW4gPD0gb3AgLSB3aGF2ZSkge1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIGxlbiAtPSBvcCAtIHdoYXZlO1xuLy8gICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wID4gd2hhdmUpO1xuLy8gICAgICAgICAgICAgICAgaWYgKG9wID09PSAwKSB7XG4vLyAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmcm9tID0gMDsgLy8gd2luZG93IGluZGV4XG4gICAgICAgICAgICAgIGZyb21fc291cmNlID0gc193aW5kb3c7XG4gICAgICAgICAgICAgIGlmICh3bmV4dCA9PT0gMCkgeyAgICAgICAgICAgLyogdmVyeSBjb21tb24gY2FzZSAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHduZXh0IDwgb3ApIHsgICAgICAvKiB3cmFwIGFyb3VuZCB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplICsgd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBvcCAtPSB3bmV4dDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gZW5kIG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7ICAvKiBzb21lIGZyb20gc3RhcnQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICAgIG9wID0gd25leHQ7XG4gICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgLyogY29udGlndW91cyBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3aGlsZSAobGVuID4gMikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgICAgIC8qIGNvcHkgZGlyZWN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAvKiBtaW5pbXVtIGxlbmd0aCBpcyB0aHJlZSAqL1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gPiAyKTtcbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAvKiAybmQgbGV2ZWwgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICAgICAgaGVyZSA9IGRjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgICAgICBjb250aW51ZSBkb2Rpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgICAgICAvKiAybmQgbGV2ZWwgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgaGVyZSA9IGxjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgIGNvbnRpbnVlIGRvbGVuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAzMikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGVuZC1vZi1ibG9jayAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuXG4gICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgIH1cbiAgfSB3aGlsZSAoX2luIDwgbGFzdCAmJiBfb3V0IDwgZW5kKTtcblxuICAvKiByZXR1cm4gdW51c2VkIGJ5dGVzIChvbiBlbnRyeSwgYml0cyA8IDgsIHNvIGluIHdvbid0IGdvIHRvbyBmYXIgYmFjaykgKi9cbiAgbGVuID0gYml0cyA+PiAzO1xuICBfaW4gLT0gbGVuO1xuICBiaXRzIC09IGxlbiA8PCAzO1xuICBob2xkICY9ICgxIDw8IGJpdHMpIC0gMTtcblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJldHVybiAqL1xuICBzdHJtLm5leHRfaW4gPSBfaW47XG4gIHN0cm0ubmV4dF9vdXQgPSBfb3V0O1xuICBzdHJtLmF2YWlsX2luID0gKF9pbiA8IGxhc3QgPyA1ICsgKGxhc3QgLSBfaW4pIDogNSAtIChfaW4gLSBsYXN0KSk7XG4gIHN0cm0uYXZhaWxfb3V0ID0gKF9vdXQgPCBlbmQgPyAyNTcgKyAoZW5kIC0gX291dCkgOiAyNTcgLSAoX291dCAtIGVuZCkpO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIHJldHVybjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuY29uc3QgYWRsZXIzMiAgICAgICA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xuY29uc3QgY3JjMzIgICAgICAgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbmNvbnN0IGluZmxhdGVfZmFzdCAgPSByZXF1aXJlKCcuL2luZmZhc3QnKTtcbmNvbnN0IGluZmxhdGVfdGFibGUgPSByZXF1aXJlKCcuL2luZnRyZWVzJyk7XG5cbmNvbnN0IENPREVTID0gMDtcbmNvbnN0IExFTlMgPSAxO1xuY29uc3QgRElTVFMgPSAyO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuY29uc3Qge1xuICBaX0ZJTklTSCwgWl9CTE9DSywgWl9UUkVFUyxcbiAgWl9PSywgWl9TVFJFQU1fRU5ELCBaX05FRURfRElDVCwgWl9TVFJFQU1fRVJST1IsIFpfREFUQV9FUlJPUiwgWl9NRU1fRVJST1IsIFpfQlVGX0VSUk9SLFxuICBaX0RFRkxBVEVEXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuXG4vKiBTVEFURVMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5jb25zdCAgICBIRUFEID0gMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbWFnaWMgaGVhZGVyICovXG5jb25zdCAgICBGTEFHUyA9IDI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgbWV0aG9kIGFuZCBmbGFncyAoZ3ppcCkgKi9cbmNvbnN0ICAgIFRJTUUgPSAzOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtb2RpZmljYXRpb24gdGltZSAoZ3ppcCkgKi9cbmNvbnN0ICAgIE9TID0gNDsgICAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBmbGFncyBhbmQgb3BlcmF0aW5nIHN5c3RlbSAoZ3ppcCkgKi9cbmNvbnN0ICAgIEVYTEVOID0gNTsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBsZW5ndGggKGd6aXApICovXG5jb25zdCAgICBFWFRSQSA9IDY7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgYnl0ZXMgKGd6aXApICovXG5jb25zdCAgICBOQU1FID0gNzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGZpbGUgbmFtZSAoZ3ppcCkgKi9cbmNvbnN0ICAgIENPTU1FTlQgPSA4OyAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgY29tbWVudCAoZ3ppcCkgKi9cbmNvbnN0ICAgIEhDUkMgPSA5OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBoZWFkZXIgY3JjIChnemlwKSAqL1xuY29uc3QgICAgRElDVElEID0gMTA7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpY3Rpb25hcnkgY2hlY2sgdmFsdWUgKi9cbmNvbnN0ICAgIERJQ1QgPSAxMTsgICAgICAvKiB3YWl0aW5nIGZvciBpbmZsYXRlU2V0RGljdGlvbmFyeSgpIGNhbGwgKi9cbmNvbnN0ICAgICAgICBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xuY29uc3QgICAgICAgIFRZUEVETyA9IDEzOyAgICAvKiBpOiBzYW1lLCBidXQgc2tpcCBjaGVjayB0byBleGl0IGluZmxhdGUgb24gbmV3IGJsb2NrICovXG5jb25zdCAgICAgICAgU1RPUkVEID0gMTQ7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIHN0b3JlZCBzaXplIChsZW5ndGggYW5kIGNvbXBsZW1lbnQpICovXG5jb25zdCAgICAgICAgQ09QWV8gPSAxNTsgICAgIC8qIGkvbzogc2FtZSBhcyBDT1BZIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG5jb25zdCAgICAgICAgQ09QWSA9IDE2OyAgICAgIC8qIGkvbzogd2FpdGluZyBmb3IgaW5wdXQgb3Igb3V0cHV0IHRvIGNvcHkgc3RvcmVkIGJsb2NrICovXG5jb25zdCAgICAgICAgVEFCTEUgPSAxNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGR5bmFtaWMgYmxvY2sgdGFibGUgbGVuZ3RocyAqL1xuY29uc3QgICAgICAgIExFTkxFTlMgPSAxODsgICAvKiBpOiB3YWl0aW5nIGZvciBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbmNvbnN0ICAgICAgICBDT0RFTEVOUyA9IDE5OyAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdCBhbmQgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG5jb25zdCAgICAgICAgICAgIExFTl8gPSAyMDsgICAgICAvKiBpOiBzYW1lIGFzIExFTiBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xuY29uc3QgICAgICAgICAgICBMRU4gPSAyMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdC9lb2IgY29kZSAqL1xuY29uc3QgICAgICAgICAgICBMRU5FWFQgPSAyMjsgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoIGV4dHJhIGJpdHMgKi9cbmNvbnN0ICAgICAgICAgICAgRElTVCA9IDIzOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGNvZGUgKi9cbmNvbnN0ICAgICAgICAgICAgRElTVEVYVCA9IDI0OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGV4dHJhIGJpdHMgKi9cbmNvbnN0ICAgICAgICAgICAgTUFUQ0ggPSAyNTsgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byBjb3B5IHN0cmluZyAqL1xuY29uc3QgICAgICAgICAgICBMSVQgPSAyNjsgICAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIHdyaXRlIGxpdGVyYWwgKi9cbmNvbnN0ICAgIENIRUNLID0gMjc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgY2hlY2sgdmFsdWUgKi9cbmNvbnN0ICAgIExFTkdUSCA9IDI4OyAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgbGVuZ3RoIChnemlwKSAqL1xuY29uc3QgICAgRE9ORSA9IDI5OyAgICAgIC8qIGZpbmlzaGVkIGNoZWNrLCBkb25lIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG5jb25zdCAgICBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xuY29uc3QgICAgTUVNID0gMzE7ICAgICAgIC8qIGdvdCBhbiBpbmZsYXRlKCkgbWVtb3J5IGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG5jb25zdCAgICBTWU5DID0gMzI7ICAgICAgLyogbG9va2luZyBmb3Igc3luY2hyb25pemF0aW9uIGJ5dGVzIHRvIHJlc3RhcnQgaW5mbGF0ZSgpICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuXG5jb25zdCBFTk9VR0hfTEVOUyA9IDg1MjtcbmNvbnN0IEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vY29uc3QgRU5PVUdIID0gIChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG5jb25zdCBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xuY29uc3QgREVGX1dCSVRTID0gTUFYX1dCSVRTO1xuXG5cbmNvbnN0IHpzd2FwMzIgPSAocSkgPT4ge1xuXG4gIHJldHVybiAgKCgocSA+Pj4gMjQpICYgMHhmZikgK1xuICAgICAgICAgICgocSA+Pj4gOCkgJiAweGZmMDApICtcbiAgICAgICAgICAoKHEgJiAweGZmMDApIDw8IDgpICtcbiAgICAgICAgICAoKHEgJiAweGZmKSA8PCAyNCkpO1xufTtcblxuXG5mdW5jdGlvbiBJbmZsYXRlU3RhdGUoKSB7XG4gIHRoaXMubW9kZSA9IDA7ICAgICAgICAgICAgIC8qIGN1cnJlbnQgaW5mbGF0ZSBtb2RlICovXG4gIHRoaXMubGFzdCA9IGZhbHNlOyAgICAgICAgICAvKiB0cnVlIGlmIHByb2Nlc3NpbmcgbGFzdCBibG9jayAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmhhdmVkaWN0ID0gZmFsc2U7ICAgICAgLyogdHJ1ZSBpZiBkaWN0aW9uYXJ5IHByb3ZpZGVkICovXG4gIHRoaXMuZmxhZ3MgPSAwOyAgICAgICAgICAgICAvKiBnemlwIGhlYWRlciBtZXRob2QgYW5kIGZsYWdzICgwIGlmIHpsaWIpICovXG4gIHRoaXMuZG1heCA9IDA7ICAgICAgICAgICAgICAvKiB6bGliIGhlYWRlciBtYXggZGlzdGFuY2UgKElORkxBVEVfU1RSSUNUKSAqL1xuICB0aGlzLmNoZWNrID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2YgY2hlY2sgdmFsdWUgKi9cbiAgdGhpcy50b3RhbCA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIG91dHB1dCBjb3VudCAqL1xuICAvLyBUT0RPOiBtYXkgYmUge31cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAgICAgICAgIC8qIHdoZXJlIHRvIHNhdmUgZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gKi9cblxuICAvKiBzbGlkaW5nIHdpbmRvdyAqL1xuICB0aGlzLndiaXRzID0gMDsgICAgICAgICAgICAgLyogbG9nIGJhc2UgMiBvZiByZXF1ZXN0ZWQgd2luZG93IHNpemUgKi9cbiAgdGhpcy53c2l6ZSA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB0aGlzLndoYXZlID0gMDsgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB0aGlzLnduZXh0ID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIHRoaXMud2luZG93ID0gbnVsbDsgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIG5lZWRlZCAqL1xuXG4gIC8qIGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmhvbGQgPSAwOyAgICAgICAgICAgICAgLyogaW5wdXQgYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuYml0cyA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgYml0cyBpbiBcImluXCIgKi9cblxuICAvKiBmb3Igc3RyaW5nIGFuZCBzdG9yZWQgYmxvY2sgY29weWluZyAqL1xuICB0aGlzLmxlbmd0aCA9IDA7ICAgICAgICAgICAgLyogbGl0ZXJhbCBvciBsZW5ndGggb2YgZGF0YSB0byBjb3B5ICovXG4gIHRoaXMub2Zmc2V0ID0gMDsgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIHRvIGNvcHkgc3RyaW5nIGZyb20gKi9cblxuICAvKiBmb3IgdGFibGUgYW5kIGNvZGUgZGVjb2RpbmcgKi9cbiAgdGhpcy5leHRyYSA9IDA7ICAgICAgICAgICAgIC8qIGV4dHJhIGJpdHMgbmVlZGVkICovXG5cbiAgLyogZml4ZWQgYW5kIGR5bmFtaWMgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5jb2RlID0gbnVsbDsgICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzICovXG4gIHRoaXMuZGlzdGNvZGUgPSBudWxsOyAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAqL1xuICB0aGlzLmxlbmJpdHMgPSAwOyAgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgbGVuY29kZSAqL1xuICB0aGlzLmRpc3RiaXRzID0gMDsgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgZGlzdGNvZGUgKi9cblxuICAvKiBkeW5hbWljIHRhYmxlIGJ1aWxkaW5nICovXG4gIHRoaXMubmNvZGUgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmxlbiA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5kaXN0ID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLmhhdmUgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RocyBpbiBsZW5zW10gKi9cbiAgdGhpcy5uZXh0ID0gbnVsbDsgICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIGNvZGVzW10gKi9cblxuICB0aGlzLmxlbnMgPSBuZXcgVWludDE2QXJyYXkoMzIwKTsgLyogdGVtcG9yYXJ5IHN0b3JhZ2UgZm9yIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLndvcmsgPSBuZXcgVWludDE2QXJyYXkoMjg4KTsgLyogd29yayBhcmVhIGZvciBjb2RlIHRhYmxlIGJ1aWxkaW5nICovXG5cbiAgLypcbiAgIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBwb2ludGVycyBpbiBqcywgd2UgdXNlIGxlbmNvZGUgYW5kIGRpc3Rjb2RlIGRpcmVjdGx5XG4gICBhcyBidWZmZXJzIHNvIHdlIGRvbid0IG5lZWQgY29kZXNcbiAgKi9cbiAgLy90aGlzLmNvZGVzID0gbmV3IEludDMyQXJyYXkoRU5PVUdIKTsgICAgICAgLyogc3BhY2UgZm9yIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuZHluID0gbnVsbDsgICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5kaXN0ZHluID0gbnVsbDsgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLnNhbmUgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBpZiBmYWxzZSwgYWxsb3cgaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyICovXG4gIHRoaXMuYmFjayA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgYmFjayBvZiBsYXN0IHVucHJvY2Vzc2VkIGxlbmd0aC9saXQgKi9cbiAgdGhpcy53YXMgPSAwOyAgICAgICAgICAgICAgICAgICAgLyogaW5pdGlhbCBsZW5ndGggb2YgbWF0Y2ggKi9cbn1cblxuXG5jb25zdCBpbmZsYXRlUmVzZXRLZWVwID0gKHN0cm0pID0+IHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIGNvbnN0IHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gc3RhdGUudG90YWwgPSAwO1xuICBzdHJtLm1zZyA9ICcnOyAvKlpfTlVMTCovXG4gIGlmIChzdGF0ZS53cmFwKSB7ICAgICAgIC8qIHRvIHN1cHBvcnQgaWxsLWNvbmNlaXZlZCBKYXZhIHRlc3Qgc3VpdGUgKi9cbiAgICBzdHJtLmFkbGVyID0gc3RhdGUud3JhcCAmIDE7XG4gIH1cbiAgc3RhdGUubW9kZSA9IEhFQUQ7XG4gIHN0YXRlLmxhc3QgPSAwO1xuICBzdGF0ZS5oYXZlZGljdCA9IDA7XG4gIHN0YXRlLmRtYXggPSAzMjc2ODtcbiAgc3RhdGUuaGVhZCA9IG51bGwvKlpfTlVMTCovO1xuICBzdGF0ZS5ob2xkID0gMDtcbiAgc3RhdGUuYml0cyA9IDA7XG4gIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluID0gbmV3IEludDMyQXJyYXkoRU5PVUdIX0xFTlMpO1xuICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW4gPSBuZXcgSW50MzJBcnJheShFTk9VR0hfRElTVFMpO1xuXG4gIHN0YXRlLnNhbmUgPSAxO1xuICBzdGF0ZS5iYWNrID0gLTE7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogcmVzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSztcbn07XG5cblxuY29uc3QgaW5mbGF0ZVJlc2V0ID0gKHN0cm0pID0+IHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIGNvbnN0IHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RhdGUud3NpemUgPSAwO1xuICBzdGF0ZS53aGF2ZSA9IDA7XG4gIHN0YXRlLnduZXh0ID0gMDtcbiAgcmV0dXJuIGluZmxhdGVSZXNldEtlZXAoc3RybSk7XG5cbn07XG5cblxuY29uc3QgaW5mbGF0ZVJlc2V0MiA9IChzdHJtLCB3aW5kb3dCaXRzKSA9PiB7XG4gIGxldCB3cmFwO1xuXG4gIC8qIGdldCB0aGUgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogZXh0cmFjdCB3cmFwIHJlcXVlc3QgZnJvbSB3aW5kb3dCaXRzIHBhcmFtZXRlciAqL1xuICBpZiAod2luZG93Qml0cyA8IDApIHtcbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cbiAgZWxzZSB7XG4gICAgd3JhcCA9ICh3aW5kb3dCaXRzID4+IDQpICsgMTtcbiAgICBpZiAod2luZG93Qml0cyA8IDQ4KSB7XG4gICAgICB3aW5kb3dCaXRzICY9IDE1O1xuICAgIH1cbiAgfVxuXG4gIC8qIHNldCBudW1iZXIgb2Ygd2luZG93IGJpdHMsIGZyZWUgd2luZG93IGlmIGRpZmZlcmVudCAqL1xuICBpZiAod2luZG93Qml0cyAmJiAod2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1KSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICBpZiAoc3RhdGUud2luZG93ICE9PSBudWxsICYmIHN0YXRlLndiaXRzICE9PSB3aW5kb3dCaXRzKSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmVzZXQgdGhlIHJlc3Qgb2YgaXQgKi9cbiAgc3RhdGUud3JhcCA9IHdyYXA7XG4gIHN0YXRlLndiaXRzID0gd2luZG93Qml0cztcbiAgcmV0dXJuIGluZmxhdGVSZXNldChzdHJtKTtcbn07XG5cblxuY29uc3QgaW5mbGF0ZUluaXQyID0gKHN0cm0sIHdpbmRvd0JpdHMpID0+IHtcblxuICBpZiAoIXN0cm0pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIC8vc3RybS5tc2cgPSBaX05VTEw7ICAgICAgICAgICAgICAgICAvKiBpbiBjYXNlIHdlIHJldHVybiBhbiBlcnJvciAqL1xuXG4gIGNvbnN0IHN0YXRlID0gbmV3IEluZmxhdGVTdGF0ZSgpO1xuXG4gIC8vaWYgKHN0YXRlID09PSBaX05VTEwpIHJldHVybiBaX01FTV9FUlJPUjtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiBhbGxvY2F0ZWRcXG5cIikpO1xuICBzdHJtLnN0YXRlID0gc3RhdGU7XG4gIHN0YXRlLndpbmRvdyA9IG51bGwvKlpfTlVMTCovO1xuICBjb25zdCByZXQgPSBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpO1xuICBpZiAocmV0ICE9PSBaX09LKSB7XG4gICAgc3RybS5zdGF0ZSA9IG51bGwvKlpfTlVMTCovO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVJbml0ID0gKHN0cm0pID0+IHtcblxuICByZXR1cm4gaW5mbGF0ZUluaXQyKHN0cm0sIERFRl9XQklUUyk7XG59O1xuXG5cbi8qXG4gUmV0dXJuIHN0YXRlIHdpdGggbGVuZ3RoIGFuZCBkaXN0YW5jZSBkZWNvZGluZyB0YWJsZXMgYW5kIGluZGV4IHNpemVzIHNldCB0b1xuIGZpeGVkIGNvZGUgZGVjb2RpbmcuICBOb3JtYWxseSB0aGlzIHJldHVybnMgZml4ZWQgdGFibGVzIGZyb20gaW5mZml4ZWQuaC5cbiBJZiBCVUlMREZJWEVEIGlzIGRlZmluZWQsIHRoZW4gaW5zdGVhZCB0aGlzIHJvdXRpbmUgYnVpbGRzIHRoZSB0YWJsZXMgdGhlXG4gZmlyc3QgdGltZSBpdCdzIGNhbGxlZCwgYW5kIHJldHVybnMgdGhvc2UgdGFibGVzIHRoZSBmaXJzdCB0aW1lIGFuZFxuIHRoZXJlYWZ0ZXIuICBUaGlzIHJlZHVjZXMgdGhlIHNpemUgb2YgdGhlIGNvZGUgYnkgYWJvdXQgMksgYnl0ZXMsIGluXG4gZXhjaGFuZ2UgZm9yIGEgbGl0dGxlIGV4ZWN1dGlvbiB0aW1lLiAgSG93ZXZlciwgQlVJTERGSVhFRCBzaG91bGQgbm90IGJlXG4gdXNlZCBmb3IgdGhyZWFkZWQgYXBwbGljYXRpb25zLCBzaW5jZSB0aGUgcmV3cml0aW5nIG9mIHRoZSB0YWJsZXMgYW5kIHZpcmdpblxuIG1heSBub3QgYmUgdGhyZWFkLXNhZmUuXG4gKi9cbmxldCB2aXJnaW4gPSB0cnVlO1xuXG5sZXQgbGVuZml4LCBkaXN0Zml4OyAvLyBXZSBoYXZlIG5vIHBvaW50ZXJzIGluIEpTLCBzbyBrZWVwIHRhYmxlcyBzZXBhcmF0ZVxuXG5cbmNvbnN0IGZpeGVkdGFibGVzID0gKHN0YXRlKSA9PiB7XG5cbiAgLyogYnVpbGQgZml4ZWQgaHVmZm1hbiB0YWJsZXMgaWYgZmlyc3QgY2FsbCAobWF5IG5vdCBiZSB0aHJlYWQgc2FmZSkgKi9cbiAgaWYgKHZpcmdpbikge1xuICAgIGxlbmZpeCA9IG5ldyBJbnQzMkFycmF5KDUxMik7XG4gICAgZGlzdGZpeCA9IG5ldyBJbnQzMkFycmF5KDMyKTtcblxuICAgIC8qIGxpdGVyYWwvbGVuZ3RoIHRhYmxlICovXG4gICAgbGV0IHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDE0NCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjU2KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gOTsgfVxuICAgIHdoaWxlIChzeW0gPCAyODApIHsgc3RhdGUubGVuc1tzeW0rK10gPSA3OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4OCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cblxuICAgIGluZmxhdGVfdGFibGUoTEVOUywgIHN0YXRlLmxlbnMsIDAsIDI4OCwgbGVuZml4LCAgIDAsIHN0YXRlLndvcmssIHsgYml0czogOSB9KTtcblxuICAgIC8qIGRpc3RhbmNlIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMzIpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA1OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCAwLCAzMiwgICBkaXN0Zml4LCAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDUgfSk7XG5cbiAgICAvKiBkbyB0aGlzIGp1c3Qgb25jZSAqL1xuICAgIHZpcmdpbiA9IGZhbHNlO1xuICB9XG5cbiAgc3RhdGUubGVuY29kZSA9IGxlbmZpeDtcbiAgc3RhdGUubGVuYml0cyA9IDk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gZGlzdGZpeDtcbiAgc3RhdGUuZGlzdGJpdHMgPSA1O1xufTtcblxuXG4vKlxuIFVwZGF0ZSB0aGUgd2luZG93IHdpdGggdGhlIGxhc3Qgd3NpemUgKG5vcm1hbGx5IDMySykgYnl0ZXMgd3JpdHRlbiBiZWZvcmVcbiByZXR1cm5pbmcuICBJZiB3aW5kb3cgZG9lcyBub3QgZXhpc3QgeWV0LCBjcmVhdGUgaXQuICBUaGlzIGlzIG9ubHkgY2FsbGVkXG4gd2hlbiBhIHdpbmRvdyBpcyBhbHJlYWR5IGluIHVzZSwgb3Igd2hlbiBvdXRwdXQgaGFzIGJlZW4gd3JpdHRlbiBkdXJpbmcgdGhpc1xuIGluZmxhdGUgY2FsbCwgYnV0IHRoZSBlbmQgb2YgdGhlIGRlZmxhdGUgc3RyZWFtIGhhcyBub3QgYmVlbiByZWFjaGVkIHlldC5cbiBJdCBpcyBhbHNvIGNhbGxlZCB0byBjcmVhdGUgYSB3aW5kb3cgZm9yIGRpY3Rpb25hcnkgZGF0YSB3aGVuIGEgZGljdGlvbmFyeVxuIGlzIGxvYWRlZC5cblxuIFByb3ZpZGluZyBvdXRwdXQgYnVmZmVycyBsYXJnZXIgdGhhbiAzMksgdG8gaW5mbGF0ZSgpIHNob3VsZCBwcm92aWRlIGEgc3BlZWRcbiBhZHZhbnRhZ2UsIHNpbmNlIG9ubHkgdGhlIGxhc3QgMzJLIG9mIG91dHB1dCBpcyBjb3BpZWQgdG8gdGhlIHNsaWRpbmcgd2luZG93XG4gdXBvbiByZXR1cm4gZnJvbSBpbmZsYXRlKCksIGFuZCBzaW5jZSBhbGwgZGlzdGFuY2VzIGFmdGVyIHRoZSBmaXJzdCAzMksgb2ZcbiBvdXRwdXQgd2lsbCBmYWxsIGluIHRoZSBvdXRwdXQgZGF0YSwgbWFraW5nIG1hdGNoIGNvcGllcyBzaW1wbGVyIGFuZCBmYXN0ZXIuXG4gVGhlIGFkdmFudGFnZSBtYXkgYmUgZGVwZW5kZW50IG9uIHRoZSBzaXplIG9mIHRoZSBwcm9jZXNzb3IncyBkYXRhIGNhY2hlcy5cbiAqL1xuY29uc3QgdXBkYXRld2luZG93ID0gKHN0cm0sIHNyYywgZW5kLCBjb3B5KSA9PiB7XG5cbiAgbGV0IGRpc3Q7XG4gIGNvbnN0IHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBpZiBpdCBoYXNuJ3QgYmVlbiBkb25lIGFscmVhZHksIGFsbG9jYXRlIHNwYWNlIGZvciB0aGUgd2luZG93ICovXG4gIGlmIChzdGF0ZS53aW5kb3cgPT09IG51bGwpIHtcbiAgICBzdGF0ZS53c2l6ZSA9IDEgPDwgc3RhdGUud2JpdHM7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gMDtcblxuICAgIHN0YXRlLndpbmRvdyA9IG5ldyBVaW50OEFycmF5KHN0YXRlLndzaXplKTtcbiAgfVxuXG4gIC8qIGNvcHkgc3RhdGUtPndzaXplIG9yIGxlc3Mgb3V0cHV0IGJ5dGVzIGludG8gdGhlIGNpcmN1bGFyIHdpbmRvdyAqL1xuICBpZiAoY29weSA+PSBzdGF0ZS53c2l6ZSkge1xuICAgIHN0YXRlLndpbmRvdy5zZXQoc3JjLnN1YmFycmF5KGVuZCAtIHN0YXRlLndzaXplLCBlbmQpLCAwKTtcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgfVxuICBlbHNlIHtcbiAgICBkaXN0ID0gc3RhdGUud3NpemUgLSBzdGF0ZS53bmV4dDtcbiAgICBpZiAoZGlzdCA+IGNvcHkpIHtcbiAgICAgIGRpc3QgPSBjb3B5O1xuICAgIH1cbiAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdyArIHN0YXRlLT53bmV4dCwgZW5kIC0gY29weSwgZGlzdCk7XG4gICAgc3RhdGUud2luZG93LnNldChzcmMuc3ViYXJyYXkoZW5kIC0gY29weSwgZW5kIC0gY29weSArIGRpc3QpLCBzdGF0ZS53bmV4dCk7XG4gICAgY29weSAtPSBkaXN0O1xuICAgIGlmIChjb3B5KSB7XG4gICAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdywgZW5kIC0gY29weSwgY29weSk7XG4gICAgICBzdGF0ZS53aW5kb3cuc2V0KHNyYy5zdWJhcnJheShlbmQgLSBjb3B5LCBlbmQpLCAwKTtcbiAgICAgIHN0YXRlLnduZXh0ID0gY29weTtcbiAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RhdGUud25leHQgKz0gZGlzdDtcbiAgICAgIGlmIChzdGF0ZS53bmV4dCA9PT0gc3RhdGUud3NpemUpIHsgc3RhdGUud25leHQgPSAwOyB9XG4gICAgICBpZiAoc3RhdGUud2hhdmUgPCBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53aGF2ZSArPSBkaXN0OyB9XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufTtcblxuXG5jb25zdCBpbmZsYXRlID0gKHN0cm0sIGZsdXNoKSA9PiB7XG5cbiAgbGV0IHN0YXRlO1xuICBsZXQgaW5wdXQsIG91dHB1dDsgICAgICAgICAgLy8gaW5wdXQvb3V0cHV0IGJ1ZmZlcnNcbiAgbGV0IG5leHQ7ICAgICAgICAgICAgICAgICAgIC8qIG5leHQgaW5wdXQgSU5ERVggKi9cbiAgbGV0IHB1dDsgICAgICAgICAgICAgICAgICAgIC8qIG5leHQgb3V0cHV0IElOREVYICovXG4gIGxldCBoYXZlLCBsZWZ0OyAgICAgICAgICAgICAvKiBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICBsZXQgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogYml0IGJ1ZmZlciAqL1xuICBsZXQgYml0czsgICAgICAgICAgICAgICAgICAgLyogYml0cyBpbiBiaXQgYnVmZmVyICovXG4gIGxldCBfaW4sIF9vdXQ7ICAgICAgICAgICAgICAvKiBzYXZlIHN0YXJ0aW5nIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIGxldCBjb3B5OyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2Ygc3RvcmVkIG9yIG1hdGNoIGJ5dGVzIHRvIGNvcHkgKi9cbiAgbGV0IGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggYnl0ZXMgZnJvbSAqL1xuICBsZXQgZnJvbV9zb3VyY2U7XG4gIGxldCBoZXJlID0gMDsgICAgICAgICAgICAgICAvKiBjdXJyZW50IGRlY29kaW5nIHRhYmxlIGVudHJ5ICovXG4gIGxldCBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsOyAvLyBwYWtlZCBcImhlcmVcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICAvL2xldCBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBwYXJlbnQgdGFibGUgZW50cnkgKi9cbiAgbGV0IGxhc3RfYml0cywgbGFzdF9vcCwgbGFzdF92YWw7IC8vIHBha2VkIFwibGFzdFwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIGxldCBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggdG8gY29weSBmb3IgcmVwZWF0cywgYml0cyB0byBkcm9wICovXG4gIGxldCByZXQ7ICAgICAgICAgICAgICAgICAgICAvKiByZXR1cm4gY29kZSAqL1xuICBjb25zdCBoYnVmID0gbmV3IFVpbnQ4QXJyYXkoNCk7ICAgIC8qIGJ1ZmZlciBmb3IgZ3ppcCBoZWFkZXIgY3JjIGNhbGN1bGF0aW9uICovXG4gIGxldCBvcHRzO1xuXG4gIGxldCBuOyAvLyB0ZW1wb3JhcnkgdmFyaWFibGUgZm9yIE5FRURfQklUU1xuXG4gIGNvbnN0IG9yZGVyID0gLyogcGVybXV0YXRpb24gb2YgY29kZSBsZW5ndGhzICovXG4gICAgbmV3IFVpbnQ4QXJyYXkoWyAxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1IF0pO1xuXG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8ICFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkgeyBzdGF0ZS5tb2RlID0gVFlQRURPOyB9ICAgIC8qIHNraXAgY2hlY2sgKi9cblxuXG4gIC8vLS0tIExPQUQoKSAtLS1cbiAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAvLy0tLVxuXG4gIF9pbiA9IGhhdmU7XG4gIF9vdXQgPSBsZWZ0O1xuICByZXQgPSBaX09LO1xuXG4gIGluZl9sZWF2ZTogLy8gZ290byBlbXVsYXRpb25cbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoc3RhdGUubW9kZSkge1xuICAgICAgY2FzZSBIRUFEOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCA9PT0gMCkge1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFRE87XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmICgoc3RhdGUud3JhcCAmIDIpICYmIGhvbGQgPT09IDB4OGIxZikgeyAgLyogZ3ppcCBoZWFkZXIgKi9cbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IDAvKmNyYzMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cblxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBGTEFHUztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5mbGFncyA9IDA7ICAgICAgICAgICAvKiBleHBlY3QgemxpYiBoZWFkZXIgKi9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzdGF0ZS53cmFwICYgMSkgfHwgICAvKiBjaGVjayBpZiB6bGliIGhlYWRlciBhbGxvd2VkICovXG4gICAgICAgICAgKCgoaG9sZCAmIDB4ZmYpLypCSVRTKDgpKi8gPDwgOCkgKyAoaG9sZCA+PiA4KSkgJSAzMSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBoZWFkZXIgY2hlY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChob2xkICYgMHgwZikvKkJJVFMoNCkqLyAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgICBiaXRzIC09IDQ7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgbGVuID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgODtcbiAgICAgICAgaWYgKHN0YXRlLndiaXRzID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUud2JpdHMgPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuID4gc3RhdGUud2JpdHMpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHdpbmRvdyBzaXplJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gISEhIHBha28gcGF0Y2guIEZvcmNlIHVzZSBgb3B0aW9ucy53aW5kb3dCaXRzYCBpZiBwYXNzZWQuXG4gICAgICAgIC8vIFJlcXVpcmVkIHRvIGFsd2F5cyB1c2UgbWF4IHdpbmRvdyBzaXplIGJ5IGRlZmF1bHQuXG4gICAgICAgIHN0YXRlLmRtYXggPSAxIDw8IHN0YXRlLndiaXRzO1xuICAgICAgICAvL3N0YXRlLmRtYXggPSAxIDw8IGxlbjtcblxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgemxpYiBoZWFkZXIgb2tcXG5cIikpO1xuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIHN0YXRlLm1vZGUgPSBob2xkICYgMHgyMDAgPyBESUNUSUQgOiBUWVBFO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZMQUdTOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUuZmxhZ3MgPSBob2xkO1xuICAgICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMHhmZikgIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweGUwMDApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGhlYWRlciBmbGFncyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnRleHQgPSAoKGhvbGQgPj4gOCkgJiAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gVElNRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUSU1FOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnRpbWUgPSBob2xkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzQoc3RhdGUuY2hlY2ssIGhvbGQpXG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIGhidWZbMl0gPSAoaG9sZCA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzNdID0gKGhvbGQgPj4+IDI0KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgNCwgMCk7XG4gICAgICAgICAgLy89PT1cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IE9TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE9TOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnhmbGFncyA9IChob2xkICYgMHhmZik7XG4gICAgICAgICAgc3RhdGUuaGVhZC5vcyA9IChob2xkID4+IDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBFWExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBFWExFTjpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkO1xuICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX2xlbiA9IGhvbGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG51bGwvKlpfTlVMTCovO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBFWFRSQTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBFWFRSQTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUuaGVhZC5leHRyYV9sZW4gLSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgICAgIGlmICghc3RhdGUuaGVhZC5leHRyYSkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB1bnR5cGVkIGFycmF5IGZvciBtb3JlIGNvbnZlbmllbnQgcHJvY2Vzc2luZyBsYXRlclxuICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBuZXcgVWludDhBcnJheShzdGF0ZS5oZWFkLmV4dHJhX2xlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYS5zZXQoXG4gICAgICAgICAgICAgICAgaW5wdXQuc3ViYXJyYXkoXG4gICAgICAgICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgICAgICAgLy8gZXh0cmEgZmllbGQgaXMgbGltaXRlZCB0byA2NTUzNiBieXRlc1xuICAgICAgICAgICAgICAgICAgLy8gLSBubyBuZWVkIGZvciBhZGRpdGlvbmFsIHNpemUgY2hlY2tcbiAgICAgICAgICAgICAgICAgIG5leHQgKyBjb3B5XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAvKmxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA/IHN0YXRlLmhlYWQuZXh0cmFfbWF4IDogY29weSwqL1xuICAgICAgICAgICAgICAgIGxlblxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAvL3ptZW1jcHkoc3RhdGUuaGVhZC5leHRyYSArIGxlbiwgbmV4dCxcbiAgICAgICAgICAgICAgLy8gICAgICAgIGxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCA/XG4gICAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA6IGNvcHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBOQU1FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE5BTUU6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDgwMCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGNvcHkgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIFRPRE86IDIgb3IgMSBieXRlcz9cbiAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQubmFtZV9tYXgqLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5uYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5uYW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09NTUVOVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT01NRU5UOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDEwMDApIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLmNvbW1fbWF4Ki8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBIQ1JDO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEhDUkM6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDB4ZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2hlYWRlciBjcmMgbWlzbWF0Y2gnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuaGNyYyA9ICgoc3RhdGUuZmxhZ3MgPj4gOSkgJiAxKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElDVElEOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0genN3YXAzMihob2xkKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBESUNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJQ1Q6XG4gICAgICAgIGlmIChzdGF0ZS5oYXZlZGljdCA9PT0gMCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgcmV0dXJuIFpfTkVFRF9ESUNUO1xuICAgICAgICB9XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVFlQRTpcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0JMT0NLIHx8IGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRZUEVETzpcbiAgICAgICAgaWYgKHN0YXRlLmxhc3QpIHtcbiAgICAgICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBDSEVDSztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBORUVEQklUUygzKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmxhc3QgPSAoaG9sZCAmIDB4MDEpLypCSVRTKDEpKi87XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDEpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAxO1xuICAgICAgICBiaXRzIC09IDE7XG4gICAgICAgIC8vLS0tLy9cblxuICAgICAgICBzd2l0Y2ggKChob2xkICYgMHgwMykvKkJJVFMoMikqLykge1xuICAgICAgICAgIGNhc2UgMDogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIHN0b3JlZCBibG9jayAqL1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgc3RvcmVkIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gU1RPUkVEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZml4ZWQgYmxvY2sgKi9cbiAgICAgICAgICAgIGZpeGVkdGFibGVzKHN0YXRlKTtcbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGZpeGVkIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXzsgICAgICAgICAgICAgLyogZGVjb2RlIGNvZGVzICovXG4gICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBkeW5hbWljIGJsb2NrICovXG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBkeW5hbWljIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gVEFCTEU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJsb2NrIHR5cGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTVE9SRUQ6XG4gICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy8gLyogZ28gdG8gYnl0ZSBib3VuZGFyeSAqL1xuICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmICgoaG9sZCAmIDB4ZmZmZikgIT09ICgoaG9sZCA+Pj4gMTYpIF4gMHhmZmZmKSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgc3RvcmVkIGJsb2NrIGxlbmd0aHMnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZCAmIDB4ZmZmZjtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgbGVuZ3RoICV1XFxuXCIsXG4gICAgICAgIC8vICAgICAgICBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZXztcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPUFlfOlxuICAgICAgICBzdGF0ZS5tb2RlID0gQ09QWTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT1BZOlxuICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgICAgIGlmIChjb3B5ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIC8vLS0tIHptZW1jcHkocHV0LCBuZXh0LCBjb3B5KTsgLS0tXG4gICAgICAgICAgb3V0cHV0LnNldChpbnB1dC5zdWJhcnJheShuZXh0LCBuZXh0ICsgY29weSksIHB1dCk7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgICAgIHB1dCArPSBjb3B5O1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGVuZFxcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVEFCTEU6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE0KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5ubGVuID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMjU3O1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNTtcbiAgICAgICAgYml0cyAtPSA1O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm5kaXN0ID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMTtcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICAgIGJpdHMgLT0gNTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5uY29kZSA9IChob2xkICYgMHgwZikvKkJJVFMoNCkqLyArIDQ7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgICBiaXRzIC09IDQ7XG4gICAgICAgIC8vLS0tLy9cbi8vI2lmbmRlZiBQS1pJUF9CVUdfV09SS0FST1VORFxuICAgICAgICBpZiAoc3RhdGUubmxlbiA+IDI4NiB8fCBzdGF0ZS5uZGlzdCA+IDMwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndG9vIG1hbnkgbGVuZ3RoIG9yIGRpc3RhbmNlIHN5bWJvbHMnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgdGFibGUgc2l6ZXMgb2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkxFTlM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOTEVOUzpcbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5uY29kZSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCAxOSkge1xuICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICAgICAgICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgICAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5bjtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IDc7XG5cbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKENPREVTLCBzdGF0ZS5sZW5zLCAwLCAxOSwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSBsZW5ndGhzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIGNvZGUgbGVuZ3RocyBva1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09ERUxFTlM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09ERUxFTlM6XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGVyZV92YWwgPCAxNikge1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gaGVyZV92YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhlcmVfdmFsID09PSAxNikge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAyKTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDI7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUgLSAxXTtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDMpOy8vQklUUygyKTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDMpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDcpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgNztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDExICsgKGhvbGQgJiAweDdmKTsvL0JJVFMoNyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDcpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSA3O1xuICAgICAgICAgICAgICBiaXRzIC09IDc7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlICsgY29weSA+IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY29weS0tKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBoYW5kbGUgZXJyb3IgYnJlYWtzIGluIHdoaWxlICovXG4gICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBCQUQpIHsgYnJlYWs7IH1cblxuICAgICAgICAvKiBjaGVjayBmb3IgZW5kLW9mLWJsb2NrIGNvZGUgKGJldHRlciBoYXZlIG9uZSkgKi9cbiAgICAgICAgaWYgKHN0YXRlLmxlbnNbMjU2XSA9PT0gMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSAtLSBtaXNzaW5nIGVuZC1vZi1ibG9jayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGJ1aWxkIGNvZGUgdGFibGVzIC0tIG5vdGU6IGRvIG5vdCBjaGFuZ2UgdGhlIGxlbmJpdHMgb3IgZGlzdGJpdHNcbiAgICAgICAgICAgdmFsdWVzIGhlcmUgKDkgYW5kIDYpIHdpdGhvdXQgcmVhZGluZyB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgICAgICAgICBjb25jZXJuaW5nIHRoZSBFTk9VR0ggY29uc3RhbnRzLCB3aGljaCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzICovXG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSA5O1xuXG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShMRU5TLCBzdGF0ZS5sZW5zLCAwLCBzdGF0ZS5ubGVuLCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAgIC8vIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RocyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IDY7XG4gICAgICAgIC8vc3RhdGUuZGlzdGNvZGUuY29weShzdGF0ZS5jb2Rlcyk7XG4gICAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW47XG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmRpc3RiaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIHN0YXRlLm5sZW4sIHN0YXRlLm5kaXN0LCBzdGF0ZS5kaXN0Y29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IG9wdHMuYml0cztcbiAgICAgICAgLy8gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlcyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgJ2luZmxhdGU6ICAgICAgIGNvZGVzIG9rXFxuJykpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXztcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTl86XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOOlxuICAgICAgICBpZiAoaGF2ZSA+PSA2ICYmIGxlZnQgPj0gMjU4KSB7XG4gICAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gICAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgICAgLy8tLS1cbiAgICAgICAgICBpbmZsYXRlX2Zhc3Qoc3RybSwgX291dCk7XG4gICAgICAgICAgLy8tLS0gTE9BRCgpIC0tLVxuICAgICAgICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gICAgICAgICAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gICAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICAgICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47XG4gICAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICAgICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICAgICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICAgICAgICAgIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAgICAgICAgIC8vLS0tXG5cbiAgICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkge1xuICAgICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5iYWNrID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07ICAvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiYgKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IGhlcmVfdmFsO1xuICAgICAgICBpZiAoaGVyZV9vcCA9PT0gMCkge1xuICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBMSVQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiAzMikge1xuICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5leHRyYSA9IGhlcmVfb3AgJiAxNTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5FWFQ6XG4gICAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAgIHN0YXRlLndhcyA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgc3RhdGUubW9kZSA9IERJU1Q7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElTVDpcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUuZGlzdGJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5vZmZzZXQgPSBoZXJlX3ZhbDtcbiAgICAgICAgc3RhdGUuZXh0cmEgPSAoaGVyZV9vcCkgJiAxNTtcbiAgICAgICAgc3RhdGUubW9kZSA9IERJU1RFWFQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElTVEVYVDpcbiAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5vZmZzZXQgKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgfVxuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IHN0YXRlLmRtYXgpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBzdGF0ZS5vZmZzZXQpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IE1BVENIO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE1BVENIOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgY29weSA9IF9vdXQgLSBsZWZ0O1xuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gY29weSkgeyAgICAgICAgIC8qIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICBjb3B5ID0gc3RhdGUub2Zmc2V0IC0gY29weTtcbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLndoYXZlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgVHJhY2UoKHN0ZGVyciwgXCJpbmZsYXRlLmMgdG9vIGZhclxcblwiKSk7XG4vLyAgICAgICAgICBjb3B5IC09IHN0YXRlLndoYXZlO1xuLy8gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuLy8gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4vLyAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4vLyAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbi8vICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IDA7XG4vLyAgICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuLy8gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4vLyAgICAgICAgICBicmVhaztcbi8vI2VuZGlmXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud25leHQpIHtcbiAgICAgICAgICAgIGNvcHkgLT0gc3RhdGUud25leHQ7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud3NpemUgLSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53bmV4dCAtIGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbiAgICAgICAgICBmcm9tX3NvdXJjZSA9IHN0YXRlLndpbmRvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBjb3B5IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgZnJvbSA9IHB1dCAtIHN0YXRlLm9mZnNldDtcbiAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4gICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTElUOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgb3V0cHV0W3B1dCsrXSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgbGVmdC0tO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ0hFQ0s6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgLy8gVXNlICd8JyBpbnN0ZWFkIG9mICcrJyB0byBtYWtlIHN1cmUgdGhhdCByZXN1bHQgaXMgc2lnbmVkXG4gICAgICAgICAgICBob2xkIHw9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIF9vdXQgLT0gbGVmdDtcbiAgICAgICAgICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICAgICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gICAgICAgICAgaWYgKF9vdXQpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9XG4gICAgICAgICAgICAgICAgLypVUERBVEUoc3RhdGUuY2hlY2ssIHB1dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAgICAgICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpKTtcblxuICAgICAgICAgIH1cbiAgICAgICAgICBfb3V0ID0gbGVmdDtcbiAgICAgICAgICAvLyBOQjogY3JjMzIgc3RvcmVkIGFzIHNpZ25lZCAzMi1iaXQgaW50LCB6c3dhcDMyIHJldHVybnMgc2lnbmVkIHRvb1xuICAgICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgPyBob2xkIDogenN3YXAzMihob2xkKSkgIT09IHN0YXRlLmNoZWNrKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgZGF0YSBjaGVjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBjaGVjayBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5HVEg7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOR1RIOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCAmJiBzdGF0ZS5mbGFncykge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS50b3RhbCAmIDB4ZmZmZmZmZmYpKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgbGVuZ3RoIGNoZWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGxlbmd0aCBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBET05FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERPTkU6XG4gICAgICAgIHJldCA9IFpfU1RSRUFNX0VORDtcbiAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgY2FzZSBCQUQ6XG4gICAgICAgIHJldCA9IFpfREFUQV9FUlJPUjtcbiAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgY2FzZSBNRU06XG4gICAgICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgICAgIGNhc2UgU1lOQzpcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIH1cbiAgfVxuXG4gIC8vIGluZl9sZWF2ZSA8LSBoZXJlIGlzIHJlYWwgcGxhY2UgZm9yIFwiZ290byBpbmZfbGVhdmVcIiwgZW11bGF0ZWQgdmlhIFwiYnJlYWsgaW5mX2xlYXZlXCJcblxuICAvKlxuICAgICBSZXR1cm4gZnJvbSBpbmZsYXRlKCksIHVwZGF0aW5nIHRoZSB0b3RhbCBjb3VudHMgYW5kIHRoZSBjaGVjayB2YWx1ZS5cbiAgICAgSWYgdGhlcmUgd2FzIG5vIHByb2dyZXNzIGR1cmluZyB0aGUgaW5mbGF0ZSgpIGNhbGwsIHJldHVybiBhIGJ1ZmZlclxuICAgICBlcnJvci4gIENhbGwgdXBkYXRld2luZG93KCkgdG8gY3JlYXRlIGFuZC9vciB1cGRhdGUgdGhlIHdpbmRvdyBzdGF0ZS5cbiAgICAgTm90ZTogYSBtZW1vcnkgZXJyb3IgZnJvbSBpbmZsYXRlKCkgaXMgbm9uLXJlY292ZXJhYmxlLlxuICAgKi9cblxuICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgLy8tLS1cblxuICBpZiAoc3RhdGUud3NpemUgfHwgKF9vdXQgIT09IHN0cm0uYXZhaWxfb3V0ICYmIHN0YXRlLm1vZGUgPCBCQUQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA8IENIRUNLIHx8IGZsdXNoICE9PSBaX0ZJTklTSCkpKSB7XG4gICAgaWYgKHVwZGF0ZXdpbmRvdyhzdHJtLCBzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCwgX291dCAtIHN0cm0uYXZhaWxfb3V0KSkge1xuICAgICAgc3RhdGUubW9kZSA9IE1FTTtcbiAgICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgX2luIC09IHN0cm0uYXZhaWxfaW47XG4gIF9vdXQgLT0gc3RybS5hdmFpbF9vdXQ7XG4gIHN0cm0udG90YWxfaW4gKz0gX2luO1xuICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICBpZiAoc3RhdGUud3JhcCAmJiBfb3V0KSB7XG4gICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gLypVUERBVEUoc3RhdGUuY2hlY2ssIHN0cm0ubmV4dF9vdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkpO1xuICB9XG4gIHN0cm0uZGF0YV90eXBlID0gc3RhdGUuYml0cyArIChzdGF0ZS5sYXN0ID8gNjQgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBUWVBFID8gMTI4IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gTEVOXyB8fCBzdGF0ZS5tb2RlID09PSBDT1BZXyA/IDI1NiA6IDApO1xuICBpZiAoKChfaW4gPT09IDAgJiYgX291dCA9PT0gMCkgfHwgZmx1c2ggPT09IFpfRklOSVNIKSAmJiByZXQgPT09IFpfT0spIHtcbiAgICByZXQgPSBaX0JVRl9FUlJPUjtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuXG5jb25zdCBpbmZsYXRlRW5kID0gKHN0cm0pID0+IHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgLyp8fCBzdHJtLT56ZnJlZSA9PSAoZnJlZV9mdW5jKTAqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIGxldCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS53aW5kb3cpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuICByZXR1cm4gWl9PSztcbn07XG5cblxuY29uc3QgaW5mbGF0ZUdldEhlYWRlciA9IChzdHJtLCBoZWFkKSA9PiB7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmICgoc3RhdGUud3JhcCAmIDIpID09PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuXG4gIC8qIHNhdmUgaGVhZGVyIHN0cnVjdHVyZSAqL1xuICBzdGF0ZS5oZWFkID0gaGVhZDtcbiAgaGVhZC5kb25lID0gZmFsc2U7XG4gIHJldHVybiBaX09LO1xufTtcblxuXG5jb25zdCBpbmZsYXRlU2V0RGljdGlvbmFyeSA9IChzdHJtLCBkaWN0aW9uYXJ5KSA9PiB7XG4gIGNvbnN0IGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICBsZXQgc3RhdGU7XG4gIGxldCBkaWN0aWQ7XG4gIGxldCByZXQ7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIC8qID09IFpfTlVMTCAqLyB8fCAhc3RybS5zdGF0ZSAvKiA9PSBaX05VTEwgKi8pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICBpZiAoc3RhdGUud3JhcCAhPT0gMCAmJiBzdGF0ZS5tb2RlICE9PSBESUNUKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGNvcnJlY3QgZGljdGlvbmFyeSBpZGVudGlmaWVyICovXG4gIGlmIChzdGF0ZS5tb2RlID09PSBESUNUKSB7XG4gICAgZGljdGlkID0gMTsgLyogYWRsZXIzMigwLCBudWxsLCAwKSovXG4gICAgLyogZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgICBpZiAoZGljdGlkICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgLyogY29weSBkaWN0aW9uYXJ5IHRvIHdpbmRvdyB1c2luZyB1cGRhdGV3aW5kb3coKSwgd2hpY2ggd2lsbCBhbWVuZCB0aGVcbiAgIGV4aXN0aW5nIGRpY3Rpb25hcnkgaWYgYXBwcm9wcmlhdGUgKi9cbiAgcmV0ID0gdXBkYXRld2luZG93KHN0cm0sIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIGRpY3RMZW5ndGgpO1xuICBpZiAocmV0KSB7XG4gICAgc3RhdGUubW9kZSA9IE1FTTtcbiAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gIH1cbiAgc3RhdGUuaGF2ZWRpY3QgPSAxO1xuICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGRpY3Rpb25hcnkgc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0s7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzLmluZmxhdGVSZXNldCA9IGluZmxhdGVSZXNldDtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVSZXNldDIgPSBpbmZsYXRlUmVzZXQyO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVJlc2V0S2VlcCA9IGluZmxhdGVSZXNldEtlZXA7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlSW5pdCA9IGluZmxhdGVJbml0O1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZUluaXQyID0gaW5mbGF0ZUluaXQyO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlRW5kID0gaW5mbGF0ZUVuZDtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVHZXRIZWFkZXIgPSBpbmZsYXRlR2V0SGVhZGVyO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVNldERpY3Rpb25hcnkgPSBpbmZsYXRlU2V0RGljdGlvbmFyeTtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVJbmZvID0gJ3Bha28gaW5mbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVDb3B5ID0gaW5mbGF0ZUNvcHk7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlR2V0RGljdGlvbmFyeSA9IGluZmxhdGVHZXREaWN0aW9uYXJ5O1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZU1hcmsgPSBpbmZsYXRlTWFyaztcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVQcmltZSA9IGluZmxhdGVQcmltZTtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVTeW5jID0gaW5mbGF0ZVN5bmM7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlU3luY1BvaW50ID0gaW5mbGF0ZVN5bmNQb2ludDtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVVbmRlcm1pbmUgPSBpbmZsYXRlVW5kZXJtaW5lO1xuKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5jb25zdCBNQVhCSVRTID0gMTU7XG5jb25zdCBFTk9VR0hfTEVOUyA9IDg1MjtcbmNvbnN0IEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vY29uc3QgRU5PVUdIID0gKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbmNvbnN0IENPREVTID0gMDtcbmNvbnN0IExFTlMgPSAxO1xuY29uc3QgRElTVFMgPSAyO1xuXG5jb25zdCBsYmFzZSA9IG5ldyBVaW50MTZBcnJheShbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBiYXNlICovXG4gIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTMsIDE1LCAxNywgMTksIDIzLCAyNywgMzEsXG4gIDM1LCA0MywgNTEsIDU5LCA2NywgODMsIDk5LCAxMTUsIDEzMSwgMTYzLCAxOTUsIDIyNywgMjU4LCAwLCAwXG5dKTtcblxuY29uc3QgbGV4dCA9IG5ldyBVaW50OEFycmF5KFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxNywgMTcsIDE4LCAxOCwgMTgsIDE4LFxuICAxOSwgMTksIDE5LCAxOSwgMjAsIDIwLCAyMCwgMjAsIDIxLCAyMSwgMjEsIDIxLCAxNiwgNzIsIDc4XG5dKTtcblxuY29uc3QgZGJhc2UgPSBuZXcgVWludDE2QXJyYXkoWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBiYXNlICovXG4gIDEsIDIsIDMsIDQsIDUsIDcsIDksIDEzLCAxNywgMjUsIDMzLCA0OSwgNjUsIDk3LCAxMjksIDE5MyxcbiAgMjU3LCAzODUsIDUxMywgNzY5LCAxMDI1LCAxNTM3LCAyMDQ5LCAzMDczLCA0MDk3LCA2MTQ1LFxuICA4MTkzLCAxMjI4OSwgMTYzODUsIDI0NTc3LCAwLCAwXG5dKTtcblxuY29uc3QgZGV4dCA9IG5ldyBVaW50OEFycmF5KFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTgsIDE4LCAxOSwgMTksIDIwLCAyMCwgMjEsIDIxLCAyMiwgMjIsXG4gIDIzLCAyMywgMjQsIDI0LCAyNSwgMjUsIDI2LCAyNiwgMjcsIDI3LFxuICAyOCwgMjgsIDI5LCAyOSwgNjQsIDY0XG5dKTtcblxuY29uc3QgaW5mbGF0ZV90YWJsZSA9ICh0eXBlLCBsZW5zLCBsZW5zX2luZGV4LCBjb2RlcywgdGFibGUsIHRhYmxlX2luZGV4LCB3b3JrLCBvcHRzKSA9Plxue1xuICBjb25zdCBiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgLy9oZXJlID0gb3B0cy5oZXJlOyAvKiB0YWJsZSBlbnRyeSBmb3IgZHVwbGljYXRpb24gKi9cblxuICBsZXQgbGVuID0gMDsgICAgICAgICAgICAgICAvKiBhIGNvZGUncyBsZW5ndGggaW4gYml0cyAqL1xuICBsZXQgc3ltID0gMDsgICAgICAgICAgICAgICAvKiBpbmRleCBvZiBjb2RlIHN5bWJvbHMgKi9cbiAgbGV0IG1pbiA9IDAsIG1heCA9IDA7ICAgICAgICAgIC8qIG1pbmltdW0gYW5kIG1heGltdW0gY29kZSBsZW5ndGhzICovXG4gIGxldCByb290ID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciByb290IHRhYmxlICovXG4gIGxldCBjdXJyID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciBjdXJyZW50IHRhYmxlICovXG4gIGxldCBkcm9wID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgYml0cyB0byBkcm9wIGZvciBzdWItdGFibGUgKi9cbiAgbGV0IGxlZnQgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgcHJlZml4IGNvZGVzIGF2YWlsYWJsZSAqL1xuICBsZXQgdXNlZCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGVudHJpZXMgaW4gdGFibGUgdXNlZCAqL1xuICBsZXQgaHVmZiA9IDA7ICAgICAgICAgICAgICAvKiBIdWZmbWFuIGNvZGUgKi9cbiAgbGV0IGluY3I7ICAgICAgICAgICAgICAvKiBmb3IgaW5jcmVtZW50aW5nIGNvZGUsIGluZGV4ICovXG4gIGxldCBmaWxsOyAgICAgICAgICAgICAgLyogaW5kZXggZm9yIHJlcGxpY2F0aW5nIGVudHJpZXMgKi9cbiAgbGV0IGxvdzsgICAgICAgICAgICAgICAvKiBsb3cgYml0cyBmb3IgY3VycmVudCByb290IGVudHJ5ICovXG4gIGxldCBtYXNrOyAgICAgICAgICAgICAgLyogbWFzayBmb3IgbG93IHJvb3QgYml0cyAqL1xuICBsZXQgbmV4dDsgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gdGFibGUgKi9cbiAgbGV0IGJhc2UgPSBudWxsOyAgICAgLyogYmFzZSB2YWx1ZSB0YWJsZSB0byB1c2UgKi9cbiAgbGV0IGJhc2VfaW5kZXggPSAwO1xuLy8gIGxldCBzaG9leHRyYTsgICAgLyogZXh0cmEgYml0cyB0YWJsZSB0byB1c2UgKi9cbiAgbGV0IGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHVzZSBiYXNlIGFuZCBleHRyYSBmb3Igc3ltYm9sID4gZW5kICovXG4gIGNvbnN0IGNvdW50ID0gbmV3IFVpbnQxNkFycmF5KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgLyogbnVtYmVyIG9mIGNvZGVzIG9mIGVhY2ggbGVuZ3RoICovXG4gIGNvbnN0IG9mZnMgPSBuZXcgVWludDE2QXJyYXkoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAgLyogb2Zmc2V0cyBpbiB0YWJsZSBmb3IgZWFjaCBsZW5ndGggKi9cbiAgbGV0IGV4dHJhID0gbnVsbDtcbiAgbGV0IGV4dHJhX2luZGV4ID0gMDtcblxuICBsZXQgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDtcblxuICAvKlxuICAgUHJvY2VzcyBhIHNldCBvZiBjb2RlIGxlbmd0aHMgdG8gY3JlYXRlIGEgY2Fub25pY2FsIEh1ZmZtYW4gY29kZS4gIFRoZVxuICAgY29kZSBsZW5ndGhzIGFyZSBsZW5zWzAuLmNvZGVzLTFdLiAgRWFjaCBsZW5ndGggY29ycmVzcG9uZHMgdG8gdGhlXG4gICBzeW1ib2xzIDAuLmNvZGVzLTEuICBUaGUgSHVmZm1hbiBjb2RlIGlzIGdlbmVyYXRlZCBieSBmaXJzdCBzb3J0aW5nIHRoZVxuICAgc3ltYm9scyBieSBsZW5ndGggZnJvbSBzaG9ydCB0byBsb25nLCBhbmQgcmV0YWluaW5nIHRoZSBzeW1ib2wgb3JkZXJcbiAgIGZvciBjb2RlcyB3aXRoIGVxdWFsIGxlbmd0aHMuICBUaGVuIHRoZSBjb2RlIHN0YXJ0cyB3aXRoIGFsbCB6ZXJvIGJpdHNcbiAgIGZvciB0aGUgZmlyc3QgY29kZSBvZiB0aGUgc2hvcnRlc3QgbGVuZ3RoLCBhbmQgdGhlIGNvZGVzIGFyZSBpbnRlZ2VyXG4gICBpbmNyZW1lbnRzIGZvciB0aGUgc2FtZSBsZW5ndGgsIGFuZCB6ZXJvcyBhcmUgYXBwZW5kZWQgYXMgdGhlIGxlbmd0aFxuICAgaW5jcmVhc2VzLiAgRm9yIHRoZSBkZWZsYXRlIGZvcm1hdCwgdGhlc2UgYml0cyBhcmUgc3RvcmVkIGJhY2t3YXJkc1xuICAgZnJvbSB0aGVpciBtb3JlIG5hdHVyYWwgaW50ZWdlciBpbmNyZW1lbnQgb3JkZXJpbmcsIGFuZCBzbyB3aGVuIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzIGFyZSBidWlsdCBpbiB0aGUgbGFyZ2UgbG9vcCBiZWxvdywgdGhlIGludGVnZXIgY29kZXNcbiAgIGFyZSBpbmNyZW1lbnRlZCBiYWNrd2FyZHMuXG5cbiAgIFRoaXMgcm91dGluZSBhc3N1bWVzLCBidXQgZG9lcyBub3QgY2hlY2ssIHRoYXQgYWxsIG9mIHRoZSBlbnRyaWVzIGluXG4gICBsZW5zW10gYXJlIGluIHRoZSByYW5nZSAwLi5NQVhCSVRTLiAgVGhlIGNhbGxlciBtdXN0IGFzc3VyZSB0aGlzLlxuICAgMS4uTUFYQklUUyBpcyBpbnRlcnByZXRlZCBhcyB0aGF0IGNvZGUgbGVuZ3RoLiAgemVybyBtZWFucyB0aGF0IHRoYXRcbiAgIHN5bWJvbCBkb2VzIG5vdCBvY2N1ciBpbiB0aGlzIGNvZGUuXG5cbiAgIFRoZSBjb2RlcyBhcmUgc29ydGVkIGJ5IGNvbXB1dGluZyBhIGNvdW50IG9mIGNvZGVzIGZvciBlYWNoIGxlbmd0aCxcbiAgIGNyZWF0aW5nIGZyb20gdGhhdCBhIHRhYmxlIG9mIHN0YXJ0aW5nIGluZGljZXMgZm9yIGVhY2ggbGVuZ3RoIGluIHRoZVxuICAgc29ydGVkIHRhYmxlLCBhbmQgdGhlbiBlbnRlcmluZyB0aGUgc3ltYm9scyBpbiBvcmRlciBpbiB0aGUgc29ydGVkXG4gICB0YWJsZS4gIFRoZSBzb3J0ZWQgdGFibGUgaXMgd29ya1tdLCB3aXRoIHRoYXQgc3BhY2UgYmVpbmcgcHJvdmlkZWQgYnlcbiAgIHRoZSBjYWxsZXIuXG5cbiAgIFRoZSBsZW5ndGggY291bnRzIGFyZSB1c2VkIGZvciBvdGhlciBwdXJwb3NlcyBhcyB3ZWxsLCBpLmUuIGZpbmRpbmdcbiAgIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGxlbmd0aCBjb2RlcywgZGV0ZXJtaW5pbmcgaWYgdGhlcmUgYXJlIGFueVxuICAgY29kZXMgYXQgYWxsLCBjaGVja2luZyBmb3IgYSB2YWxpZCBzZXQgb2YgbGVuZ3RocywgYW5kIGxvb2tpbmcgYWhlYWRcbiAgIGF0IGxlbmd0aCBjb3VudHMgdG8gZGV0ZXJtaW5lIHN1Yi10YWJsZSBzaXplcyB3aGVuIGJ1aWxkaW5nIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzLlxuICAgKi9cblxuICAvKiBhY2N1bXVsYXRlIGxlbmd0aHMgZm9yIGNvZGVzIChhc3N1bWVzIGxlbnNbXSBhbGwgaW4gMC4uTUFYQklUUykgKi9cbiAgZm9yIChsZW4gPSAwOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBjb3VudFtsZW5dID0gMDtcbiAgfVxuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGNvdW50W2xlbnNbbGVuc19pbmRleCArIHN5bV1dKys7XG4gIH1cblxuICAvKiBib3VuZCBjb2RlIGxlbmd0aHMsIGZvcmNlIHJvb3QgdG8gYmUgd2l0aGluIGNvZGUgbGVuZ3RocyAqL1xuICByb290ID0gYml0cztcbiAgZm9yIChtYXggPSBNQVhCSVRTOyBtYXggPj0gMTsgbWF4LS0pIHtcbiAgICBpZiAoY291bnRbbWF4XSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290ID4gbWF4KSB7XG4gICAgcm9vdCA9IG1heDtcbiAgfVxuICBpZiAobWF4ID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgLyogbm8gc3ltYm9scyB0byBjb2RlIGF0IGFsbCAqL1xuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDsgIC8vaGVyZS5vcCA9ICh2YXIgY2hhcik2NDsgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7ICAgLy9oZXJlLmJpdHMgPSAodmFyIGNoYXIpMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDsgICAvL2hlcmUudmFsID0gKHZhciBzaG9ydCkwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cblxuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDtcbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cbiAgICBvcHRzLmJpdHMgPSAxO1xuICAgIHJldHVybiAwOyAgICAgLyogbm8gc3ltYm9scywgYnV0IHdhaXQgZm9yIGRlY29kaW5nIHRvIHJlcG9ydCBlcnJvciAqL1xuICB9XG4gIGZvciAobWluID0gMTsgbWluIDwgbWF4OyBtaW4rKykge1xuICAgIGlmIChjb3VudFttaW5dICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPCBtaW4pIHtcbiAgICByb290ID0gbWluO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGFuIG92ZXItc3Vic2NyaWJlZCBvciBpbmNvbXBsZXRlIHNldCBvZiBsZW5ndGhzICovXG4gIGxlZnQgPSAxO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGxlZnQgPDw9IDE7XG4gICAgbGVmdCAtPSBjb3VudFtsZW5dO1xuICAgIGlmIChsZWZ0IDwgMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gICAgICAgIC8qIG92ZXItc3Vic2NyaWJlZCAqL1xuICB9XG4gIGlmIChsZWZ0ID4gMCAmJiAodHlwZSA9PT0gQ09ERVMgfHwgbWF4ICE9PSAxKSkge1xuICAgIHJldHVybiAtMTsgICAgICAgICAgICAgICAgICAgICAgLyogaW5jb21wbGV0ZSBzZXQgKi9cbiAgfVxuXG4gIC8qIGdlbmVyYXRlIG9mZnNldHMgaW50byBzeW1ib2wgdGFibGUgZm9yIGVhY2ggbGVuZ3RoIGZvciBzb3J0aW5nICovXG4gIG9mZnNbMV0gPSAwO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgb2Zmc1tsZW4gKyAxXSA9IG9mZnNbbGVuXSArIGNvdW50W2xlbl07XG4gIH1cblxuICAvKiBzb3J0IHN5bWJvbHMgYnkgbGVuZ3RoLCBieSBzeW1ib2wgb3JkZXIgd2l0aGluIGVhY2ggbGVuZ3RoICovXG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgaWYgKGxlbnNbbGVuc19pbmRleCArIHN5bV0gIT09IDApIHtcbiAgICAgIHdvcmtbb2Zmc1tsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrXSA9IHN5bTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgQ3JlYXRlIGFuZCBmaWxsIGluIGRlY29kaW5nIHRhYmxlcy4gIEluIHRoaXMgbG9vcCwgdGhlIHRhYmxlIGJlaW5nXG4gICBmaWxsZWQgaXMgYXQgbmV4dCBhbmQgaGFzIGN1cnIgaW5kZXggYml0cy4gIFRoZSBjb2RlIGJlaW5nIHVzZWQgaXMgaHVmZlxuICAgd2l0aCBsZW5ndGggbGVuLiAgVGhhdCBjb2RlIGlzIGNvbnZlcnRlZCB0byBhbiBpbmRleCBieSBkcm9wcGluZyBkcm9wXG4gICBiaXRzIG9mZiBvZiB0aGUgYm90dG9tLiAgRm9yIGNvZGVzIHdoZXJlIGxlbiBpcyBsZXNzIHRoYW4gZHJvcCArIGN1cnIsXG4gICB0aG9zZSB0b3AgZHJvcCArIGN1cnIgLSBsZW4gYml0cyBhcmUgaW5jcmVtZW50ZWQgdGhyb3VnaCBhbGwgdmFsdWVzIHRvXG4gICBmaWxsIHRoZSB0YWJsZSB3aXRoIHJlcGxpY2F0ZWQgZW50cmllcy5cblxuICAgcm9vdCBpcyB0aGUgbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHRoZSByb290IHRhYmxlLiAgV2hlbiBsZW4gZXhjZWVkc1xuICAgcm9vdCwgc3ViLXRhYmxlcyBhcmUgY3JlYXRlZCBwb2ludGVkIHRvIGJ5IHRoZSByb290IGVudHJ5IHdpdGggYW4gaW5kZXhcbiAgIG9mIHRoZSBsb3cgcm9vdCBiaXRzIG9mIGh1ZmYuICBUaGlzIGlzIHNhdmVkIGluIGxvdyB0byBjaGVjayBmb3Igd2hlbiBhXG4gICBuZXcgc3ViLXRhYmxlIHNob3VsZCBiZSBzdGFydGVkLiAgZHJvcCBpcyB6ZXJvIHdoZW4gdGhlIHJvb3QgdGFibGUgaXNcbiAgIGJlaW5nIGZpbGxlZCwgYW5kIGRyb3AgaXMgcm9vdCB3aGVuIHN1Yi10YWJsZXMgYXJlIGJlaW5nIGZpbGxlZC5cblxuICAgV2hlbiBhIG5ldyBzdWItdGFibGUgaXMgbmVlZGVkLCBpdCBpcyBuZWNlc3NhcnkgdG8gbG9vayBhaGVhZCBpbiB0aGVcbiAgIGNvZGUgbGVuZ3RocyB0byBkZXRlcm1pbmUgd2hhdCBzaXplIHN1Yi10YWJsZSBpcyBuZWVkZWQuICBUaGUgbGVuZ3RoXG4gICBjb3VudHMgYXJlIHVzZWQgZm9yIHRoaXMsIGFuZCBzbyBjb3VudFtdIGlzIGRlY3JlbWVudGVkIGFzIGNvZGVzIGFyZVxuICAgZW50ZXJlZCBpbiB0aGUgdGFibGVzLlxuXG4gICB1c2VkIGtlZXBzIHRyYWNrIG9mIGhvdyBtYW55IHRhYmxlIGVudHJpZXMgaGF2ZSBiZWVuIGFsbG9jYXRlZCBmcm9tIHRoZVxuICAgcHJvdmlkZWQgKnRhYmxlIHNwYWNlLiAgSXQgaXMgY2hlY2tlZCBmb3IgTEVOUyBhbmQgRElTVCB0YWJsZXMgYWdhaW5zdFxuICAgdGhlIGNvbnN0YW50cyBFTk9VR0hfTEVOUyBhbmQgRU5PVUdIX0RJU1RTIHRvIGd1YXJkIGFnYWluc3QgY2hhbmdlcyBpblxuICAgdGhlIGluaXRpYWwgcm9vdCB0YWJsZSBzaXplIGNvbnN0YW50cy4gIFNlZSB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cbiAgIHN5bSBpbmNyZW1lbnRzIHRocm91Z2ggYWxsIHN5bWJvbHMsIGFuZCB0aGUgbG9vcCB0ZXJtaW5hdGVzIHdoZW5cbiAgIGFsbCBjb2RlcyBvZiBsZW5ndGggbWF4LCBpLmUuIGFsbCBjb2RlcywgaGF2ZSBiZWVuIHByb2Nlc3NlZC4gIFRoaXNcbiAgIHJvdXRpbmUgcGVybWl0cyBpbmNvbXBsZXRlIGNvZGVzLCBzbyBhbm90aGVyIGxvb3AgYWZ0ZXIgdGhpcyBvbmUgZmlsbHNcbiAgIGluIHRoZSByZXN0IG9mIHRoZSBkZWNvZGluZyB0YWJsZXMgd2l0aCBpbnZhbGlkIGNvZGUgbWFya2Vycy5cbiAgICovXG5cbiAgLyogc2V0IHVwIGZvciBjb2RlIHR5cGUgKi9cbiAgLy8gcG9vciBtYW4gb3B0aW1pemF0aW9uIC0gdXNlIGlmLWVsc2UgaW5zdGVhZCBvZiBzd2l0Y2gsXG4gIC8vIHRvIGF2b2lkIGRlb3B0cyBpbiBvbGQgdjhcbiAgaWYgKHR5cGUgPT09IENPREVTKSB7XG4gICAgYmFzZSA9IGV4dHJhID0gd29yazsgICAgLyogZHVtbXkgdmFsdWUtLW5vdCB1c2VkICovXG4gICAgZW5kID0gMTk7XG5cbiAgfSBlbHNlIGlmICh0eXBlID09PSBMRU5TKSB7XG4gICAgYmFzZSA9IGxiYXNlO1xuICAgIGJhc2VfaW5kZXggLT0gMjU3O1xuICAgIGV4dHJhID0gbGV4dDtcbiAgICBleHRyYV9pbmRleCAtPSAyNTc7XG4gICAgZW5kID0gMjU2O1xuXG4gIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAvKiBESVNUUyAqL1xuICAgIGJhc2UgPSBkYmFzZTtcbiAgICBleHRyYSA9IGRleHQ7XG4gICAgZW5kID0gLTE7XG4gIH1cblxuICAvKiBpbml0aWFsaXplIG9wdHMgZm9yIGxvb3AgKi9cbiAgaHVmZiA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgKi9cbiAgc3ltID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgc3ltYm9sICovXG4gIGxlbiA9IG1pbjsgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIGxlbmd0aCAqL1xuICBuZXh0ID0gdGFibGVfaW5kZXg7ICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIHRvIGZpbGwgaW4gKi9cbiAgY3VyciA9IHJvb3Q7ICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgaW5kZXggYml0cyAqL1xuICBkcm9wID0gMDsgICAgICAgICAgICAgICAgICAgLyogY3VycmVudCBiaXRzIHRvIGRyb3AgZnJvbSBjb2RlIGZvciBpbmRleCAqL1xuICBsb3cgPSAtMTsgICAgICAgICAgICAgICAgICAgLyogdHJpZ2dlciBuZXcgc3ViLXRhYmxlIHdoZW4gbGVuID4gcm9vdCAqL1xuICB1c2VkID0gMSA8PCByb290OyAgICAgICAgICAvKiB1c2Ugcm9vdCB0YWJsZSBlbnRyaWVzICovXG4gIG1hc2sgPSB1c2VkIC0gMTsgICAgICAgICAgICAvKiBtYXNrIGZvciBjb21wYXJpbmcgbG93ICovXG5cbiAgLyogY2hlY2sgYXZhaWxhYmxlIHRhYmxlIHNwYWNlICovXG4gIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvKiBwcm9jZXNzIGFsbCBjb2RlcyBhbmQgbWFrZSB0YWJsZSBlbnRyaWVzICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBjcmVhdGUgdGFibGUgZW50cnkgKi9cbiAgICBoZXJlX2JpdHMgPSBsZW4gLSBkcm9wO1xuICAgIGlmICh3b3JrW3N5bV0gPCBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSAwO1xuICAgICAgaGVyZV92YWwgPSB3b3JrW3N5bV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHdvcmtbc3ltXSA+IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IGV4dHJhW2V4dHJhX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICAgIGhlcmVfdmFsID0gYmFzZVtiYXNlX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBoZXJlX29wID0gMzIgKyA2NDsgICAgICAgICAvKiBlbmQgb2YgYmxvY2sgKi9cbiAgICAgIGhlcmVfdmFsID0gMDtcbiAgICB9XG5cbiAgICAvKiByZXBsaWNhdGUgZm9yIHRob3NlIGluZGljZXMgd2l0aCBsb3cgbGVuIGJpdHMgZXF1YWwgdG8gaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSBkcm9wKTtcbiAgICBmaWxsID0gMSA8PCBjdXJyO1xuICAgIG1pbiA9IGZpbGw7ICAgICAgICAgICAgICAgICAvKiBzYXZlIG9mZnNldCB0byBuZXh0IHRhYmxlICovXG4gICAgZG8ge1xuICAgICAgZmlsbCAtPSBpbmNyO1xuICAgICAgdGFibGVbbmV4dCArIChodWZmID4+IGRyb3ApICsgZmlsbF0gPSAoaGVyZV9iaXRzIDw8IDI0KSB8IChoZXJlX29wIDw8IDE2KSB8IGhlcmVfdmFsIHwwO1xuICAgIH0gd2hpbGUgKGZpbGwgIT09IDApO1xuXG4gICAgLyogYmFja3dhcmRzIGluY3JlbWVudCB0aGUgbGVuLWJpdCBjb2RlIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gMSk7XG4gICAgd2hpbGUgKGh1ZmYgJiBpbmNyKSB7XG4gICAgICBpbmNyID4+PSAxO1xuICAgIH1cbiAgICBpZiAoaW5jciAhPT0gMCkge1xuICAgICAgaHVmZiAmPSBpbmNyIC0gMTtcbiAgICAgIGh1ZmYgKz0gaW5jcjtcbiAgICB9IGVsc2Uge1xuICAgICAgaHVmZiA9IDA7XG4gICAgfVxuXG4gICAgLyogZ28gdG8gbmV4dCBzeW1ib2wsIHVwZGF0ZSBjb3VudCwgbGVuICovXG4gICAgc3ltKys7XG4gICAgaWYgKC0tY291bnRbbGVuXSA9PT0gMCkge1xuICAgICAgaWYgKGxlbiA9PT0gbWF4KSB7IGJyZWFrOyB9XG4gICAgICBsZW4gPSBsZW5zW2xlbnNfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cblxuICAgIC8qIGNyZWF0ZSBuZXcgc3ViLXRhYmxlIGlmIG5lZWRlZCAqL1xuICAgIGlmIChsZW4gPiByb290ICYmIChodWZmICYgbWFzaykgIT09IGxvdykge1xuICAgICAgLyogaWYgZmlyc3QgdGltZSwgdHJhbnNpdGlvbiB0byBzdWItdGFibGVzICovXG4gICAgICBpZiAoZHJvcCA9PT0gMCkge1xuICAgICAgICBkcm9wID0gcm9vdDtcbiAgICAgIH1cblxuICAgICAgLyogaW5jcmVtZW50IHBhc3QgbGFzdCB0YWJsZSAqL1xuICAgICAgbmV4dCArPSBtaW47ICAgICAgICAgICAgLyogaGVyZSBtaW4gaXMgMSA8PCBjdXJyICovXG5cbiAgICAgIC8qIGRldGVybWluZSBsZW5ndGggb2YgbmV4dCB0YWJsZSAqL1xuICAgICAgY3VyciA9IGxlbiAtIGRyb3A7XG4gICAgICBsZWZ0ID0gMSA8PCBjdXJyO1xuICAgICAgd2hpbGUgKGN1cnIgKyBkcm9wIDwgbWF4KSB7XG4gICAgICAgIGxlZnQgLT0gY291bnRbY3VyciArIGRyb3BdO1xuICAgICAgICBpZiAobGVmdCA8PSAwKSB7IGJyZWFrOyB9XG4gICAgICAgIGN1cnIrKztcbiAgICAgICAgbGVmdCA8PD0gMTtcbiAgICAgIH1cblxuICAgICAgLyogY2hlY2sgZm9yIGVub3VnaCBzcGFjZSAqL1xuICAgICAgdXNlZCArPSAxIDw8IGN1cnI7XG4gICAgICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIC8qIHBvaW50IGVudHJ5IGluIHJvb3QgdGFibGUgdG8gc3ViLXRhYmxlICovXG4gICAgICBsb3cgPSBodWZmICYgbWFzaztcbiAgICAgIC8qdGFibGUub3BbbG93XSA9IGN1cnI7XG4gICAgICB0YWJsZS5iaXRzW2xvd10gPSByb290O1xuICAgICAgdGFibGUudmFsW2xvd10gPSBuZXh0IC0gb3B0cy50YWJsZV9pbmRleDsqL1xuICAgICAgdGFibGVbbG93XSA9IChyb290IDw8IDI0KSB8IChjdXJyIDw8IDE2KSB8IChuZXh0IC0gdGFibGVfaW5kZXgpIHwwO1xuICAgIH1cbiAgfVxuXG4gIC8qIGZpbGwgaW4gcmVtYWluaW5nIHRhYmxlIGVudHJ5IGlmIGNvZGUgaXMgaW5jb21wbGV0ZSAoZ3VhcmFudGVlZCB0byBoYXZlXG4gICBhdCBtb3N0IG9uZSByZW1haW5pbmcgZW50cnksIHNpbmNlIGlmIHRoZSBjb2RlIGlzIGluY29tcGxldGUsIHRoZVxuICAgbWF4aW11bSBjb2RlIGxlbmd0aCB0aGF0IHdhcyBhbGxvd2VkIHRvIGdldCB0aGlzIGZhciBpcyBvbmUgYml0KSAqL1xuICBpZiAoaHVmZiAhPT0gMCkge1xuICAgIC8vdGFibGUub3BbbmV4dCArIGh1ZmZdID0gNjQ7ICAgICAgICAgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tuZXh0ICsgaHVmZl0gPSBsZW4gLSBkcm9wO1xuICAgIC8vdGFibGUudmFsW25leHQgKyBodWZmXSA9IDA7XG4gICAgdGFibGVbbmV4dCArIGh1ZmZdID0gKChsZW4gLSBkcm9wKSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwwO1xuICB9XG5cbiAgLyogc2V0IHJldHVybiBwYXJhbWV0ZXJzICovXG4gIC8vb3B0cy50YWJsZV9pbmRleCArPSB1c2VkO1xuICBvcHRzLmJpdHMgPSByb290O1xuICByZXR1cm4gMDtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBpbmZsYXRlX3RhYmxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAyOiAgICAgICduZWVkIGRpY3Rpb25hcnknLCAgICAgLyogWl9ORUVEX0RJQ1QgICAgICAgMiAgKi9cbiAgMTogICAgICAnc3RyZWFtIGVuZCcsICAgICAgICAgIC8qIFpfU1RSRUFNX0VORCAgICAgIDEgICovXG4gIDA6ICAgICAgJycsICAgICAgICAgICAgICAgICAgICAvKiBaX09LICAgICAgICAgICAgICAwICAqL1xuICAnLTEnOiAgICdmaWxlIGVycm9yJywgICAgICAgICAgLyogWl9FUlJOTyAgICAgICAgICgtMSkgKi9cbiAgJy0yJzogICAnc3RyZWFtIGVycm9yJywgICAgICAgIC8qIFpfU1RSRUFNX0VSUk9SICAoLTIpICovXG4gICctMyc6ICAgJ2RhdGEgZXJyb3InLCAgICAgICAgICAvKiBaX0RBVEFfRVJST1IgICAgKC0zKSAqL1xuICAnLTQnOiAgICdpbnN1ZmZpY2llbnQgbWVtb3J5JywgLyogWl9NRU1fRVJST1IgICAgICgtNCkgKi9cbiAgJy01JzogICAnYnVmZmVyIGVycm9yJywgICAgICAgIC8qIFpfQlVGX0VSUk9SICAgICAoLTUpICovXG4gICctNic6ICAgJ2luY29tcGF0aWJsZSB2ZXJzaW9uJyAvKiBaX1ZFUlNJT05fRVJST1IgKC02KSAqL1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vKiBlc2xpbnQtZGlzYWJsZSBzcGFjZS11bmFyeS1vcHMgKi9cblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLy9jb25zdCBaX0ZJTFRFUkVEICAgICAgICAgID0gMTtcbi8vY29uc3QgWl9IVUZGTUFOX09OTFkgICAgICA9IDI7XG4vL2NvbnN0IFpfUkxFICAgICAgICAgICAgICAgPSAzO1xuY29uc3QgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbi8vY29uc3QgWl9ERUZBVUxUX1NUUkFURUdZICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbmNvbnN0IFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG5jb25zdCBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy9jb25zdCBaX0FTQ0lJICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbmNvbnN0IFpfVU5LTk9XTiAgICAgICAgICAgICA9IDI7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuZnVuY3Rpb24gemVybyhidWYpIHsgbGV0IGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cbi8vIEZyb20genV0aWwuaFxuXG5jb25zdCBTVE9SRURfQkxPQ0sgPSAwO1xuY29uc3QgU1RBVElDX1RSRUVTID0gMTtcbmNvbnN0IERZTl9UUkVFUyAgICA9IDI7XG4vKiBUaGUgdGhyZWUga2luZHMgb2YgYmxvY2sgdHlwZSAqL1xuXG5jb25zdCBNSU5fTUFUQ0ggICAgPSAzO1xuY29uc3QgTUFYX01BVENIICAgID0gMjU4O1xuLyogVGhlIG1pbmltdW0gYW5kIG1heGltdW0gbWF0Y2ggbGVuZ3RocyAqL1xuXG4vLyBGcm9tIGRlZmxhdGUuaFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbnRlcm5hbCBjb21wcmVzc2lvbiBzdGF0ZS5cbiAqL1xuXG5jb25zdCBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cblxuY29uc3QgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xuXG5jb25zdCBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG5cbmNvbnN0IERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuXG5jb25zdCBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cblxuY29uc3QgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG5cbmNvbnN0IE1BWF9CSVRTICAgICAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG5jb25zdCBCdWZfc2l6ZSAgICAgID0gMTY7XG4vKiBzaXplIG9mIGJpdCBidWZmZXIgaW4gYmlfYnVmICovXG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBNQVhfQkxfQklUUyA9IDc7XG4vKiBCaXQgbGVuZ3RoIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQkxfQklUUyBiaXRzICovXG5cbmNvbnN0IEVORF9CTE9DSyAgID0gMjU2O1xuLyogZW5kIG9mIGJsb2NrIGxpdGVyYWwgY29kZSAqL1xuXG5jb25zdCBSRVBfM182ICAgICA9IDE2O1xuLyogcmVwZWF0IHByZXZpb3VzIGJpdCBsZW5ndGggMy02IHRpbWVzICgyIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG5jb25zdCBSRVBaXzNfMTAgICA9IDE3O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMy0xMCB0aW1lcyAgKDMgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbmNvbnN0IFJFUFpfMTFfMTM4ID0gMTg7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAxMS0xMzggdGltZXMgICg3IGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xuY29uc3QgZXh0cmFfbGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggbGVuZ3RoIGNvZGUgKi9cbiAgbmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMF0pO1xuXG5jb25zdCBleHRyYV9kYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBkaXN0YW5jZSBjb2RlICovXG4gIG5ldyBVaW50OEFycmF5KFswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzXSk7XG5cbmNvbnN0IGV4dHJhX2JsYml0cyA9ICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGJpdCBsZW5ndGggY29kZSAqL1xuICBuZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyLDMsN10pO1xuXG5jb25zdCBibF9vcmRlciA9XG4gIG5ldyBVaW50OEFycmF5KFsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XSk7XG4vKiBlc2xpbnQtZW5hYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG5cbi8qIFRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzIGFyZSBzZW50IGluIG9yZGVyIG9mIGRlY3JlYXNpbmdcbiAqIHByb2JhYmlsaXR5LCB0byBhdm9pZCB0cmFuc21pdHRpbmcgdGhlIGxlbmd0aHMgZm9yIHVudXNlZCBiaXQgbGVuZ3RoIGNvZGVzLlxuICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogTG9jYWwgZGF0YS4gVGhlc2UgYXJlIGluaXRpYWxpemVkIG9ubHkgb25jZS5cbiAqL1xuXG4vLyBXZSBwcmUtZmlsbCBhcnJheXMgd2l0aCAwIHRvIGF2b2lkIHVuaW5pdGlhbGl6ZWQgZ2Fwc1xuXG5jb25zdCBESVNUX0NPREVfTEVOID0gNTEyOyAvKiBzZWUgZGVmaW5pdGlvbiBvZiBhcnJheSBkaXN0X2NvZGUgYmVsb3cgKi9cblxuLy8gISEhISBVc2UgZmxhdCBhcnJheSBpbnN0ZWFkIG9mIHN0cnVjdHVyZSwgRnJlcSA9IGkqMiwgTGVuID0gaSoyKzFcbmNvbnN0IHN0YXRpY19sdHJlZSAgPSBuZXcgQXJyYXkoKExfQ09ERVMgKyAyKSAqIDIpO1xuemVybyhzdGF0aWNfbHRyZWUpO1xuLyogVGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUuIFNpbmNlIHRoZSBiaXQgbGVuZ3RocyBhcmUgaW1wb3NlZCwgdGhlcmUgaXMgbm9cbiAqIG5lZWQgZm9yIHRoZSBMX0NPREVTIGV4dHJhIGNvZGVzIHVzZWQgZHVyaW5nIGhlYXAgY29uc3RydWN0aW9uLiBIb3dldmVyXG4gKiBUaGUgY29kZXMgMjg2IGFuZCAyODcgYXJlIG5lZWRlZCB0byBidWlsZCBhIGNhbm9uaWNhbCB0cmVlIChzZWUgX3RyX2luaXRcbiAqIGJlbG93KS5cbiAqL1xuXG5jb25zdCBzdGF0aWNfZHRyZWUgID0gbmV3IEFycmF5KERfQ09ERVMgKiAyKTtcbnplcm8oc3RhdGljX2R0cmVlKTtcbi8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZS4gKEFjdHVhbGx5IGEgdHJpdmlhbCB0cmVlIHNpbmNlIGFsbCBjb2RlcyB1c2VcbiAqIDUgYml0cy4pXG4gKi9cblxuY29uc3QgX2Rpc3RfY29kZSAgICA9IG5ldyBBcnJheShESVNUX0NPREVfTEVOKTtcbnplcm8oX2Rpc3RfY29kZSk7XG4vKiBEaXN0YW5jZSBjb2Rlcy4gVGhlIGZpcnN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgZGlzdGFuY2VzXG4gKiAzIC4uIDI1OCwgdGhlIGxhc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSB0b3AgOCBiaXRzIG9mXG4gKiB0aGUgMTUgYml0IGRpc3RhbmNlcy5cbiAqL1xuXG5jb25zdCBfbGVuZ3RoX2NvZGUgID0gbmV3IEFycmF5KE1BWF9NQVRDSCAtIE1JTl9NQVRDSCArIDEpO1xuemVybyhfbGVuZ3RoX2NvZGUpO1xuLyogbGVuZ3RoIGNvZGUgZm9yIGVhY2ggbm9ybWFsaXplZCBtYXRjaCBsZW5ndGggKDAgPT0gTUlOX01BVENIKSAqL1xuXG5jb25zdCBiYXNlX2xlbmd0aCAgID0gbmV3IEFycmF5KExFTkdUSF9DT0RFUyk7XG56ZXJvKGJhc2VfbGVuZ3RoKTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgbGVuZ3RoIGZvciBlYWNoIGNvZGUgKDAgPSBNSU5fTUFUQ0gpICovXG5cbmNvbnN0IGJhc2VfZGlzdCAgICAgPSBuZXcgQXJyYXkoRF9DT0RFUyk7XG56ZXJvKGJhc2VfZGlzdCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGRpc3RhbmNlIGZvciBlYWNoIGNvZGUgKDAgPSBkaXN0YW5jZSBvZiAxKSAqL1xuXG5cbmZ1bmN0aW9uIFN0YXRpY1RyZWVEZXNjKHN0YXRpY190cmVlLCBleHRyYV9iaXRzLCBleHRyYV9iYXNlLCBlbGVtcywgbWF4X2xlbmd0aCkge1xuXG4gIHRoaXMuc3RhdGljX3RyZWUgID0gc3RhdGljX3RyZWU7ICAvKiBzdGF0aWMgdHJlZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYml0cyAgID0gZXh0cmFfYml0czsgICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGNvZGUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2Jhc2UgICA9IGV4dHJhX2Jhc2U7ICAgLyogYmFzZSBpbmRleCBmb3IgZXh0cmFfYml0cyAqL1xuICB0aGlzLmVsZW1zICAgICAgICA9IGVsZW1zOyAgICAgICAgLyogbWF4IG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgdHJlZSAqL1xuICB0aGlzLm1heF9sZW5ndGggICA9IG1heF9sZW5ndGg7ICAgLyogbWF4IGJpdCBsZW5ndGggZm9yIHRoZSBjb2RlcyAqL1xuXG4gIC8vIHNob3cgaWYgYHN0YXRpY190cmVlYCBoYXMgZGF0YSBvciBkdW1teSAtIG5lZWRlZCBmb3IgbW9ub21vcnBoaWMgb2JqZWN0c1xuICB0aGlzLmhhc19zdHJlZSAgICA9IHN0YXRpY190cmVlICYmIHN0YXRpY190cmVlLmxlbmd0aDtcbn1cblxuXG5sZXQgc3RhdGljX2xfZGVzYztcbmxldCBzdGF0aWNfZF9kZXNjO1xubGV0IHN0YXRpY19ibF9kZXNjO1xuXG5cbmZ1bmN0aW9uIFRyZWVEZXNjKGR5bl90cmVlLCBzdGF0X2Rlc2MpIHtcbiAgdGhpcy5keW5fdHJlZSA9IGR5bl90cmVlOyAgICAgLyogdGhlIGR5bmFtaWMgdHJlZSAqL1xuICB0aGlzLm1heF9jb2RlID0gMDsgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgdGhpcy5zdGF0X2Rlc2MgPSBzdGF0X2Rlc2M7ICAgLyogdGhlIGNvcnJlc3BvbmRpbmcgc3RhdGljIHRyZWUgKi9cbn1cblxuXG5cbmNvbnN0IGRfY29kZSA9IChkaXN0KSA9PiB7XG5cbiAgcmV0dXJuIGRpc3QgPCAyNTYgPyBfZGlzdF9jb2RlW2Rpc3RdIDogX2Rpc3RfY29kZVsyNTYgKyAoZGlzdCA+Pj4gNyldO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIE91dHB1dCBhIHNob3J0IExTQiBmaXJzdCBvbiB0aGUgc3RyZWFtLlxuICogSU4gYXNzZXJ0aW9uOiB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpbiBwZW5kaW5nQnVmLlxuICovXG5jb25zdCBwdXRfc2hvcnQgPSAocywgdykgPT4ge1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHcpICYgMHhmZikpO1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHVzaCkodykgPj4gOCkpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcgPj4+IDgpICYgMHhmZjtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgdmFsdWUgb24gYSBnaXZlbiBudW1iZXIgb2YgYml0cy5cbiAqIElOIGFzc2VydGlvbjogbGVuZ3RoIDw9IDE2IGFuZCB2YWx1ZSBmaXRzIGluIGxlbmd0aCBiaXRzLlxuICovXG5jb25zdCBzZW5kX2JpdHMgPSAocywgdmFsdWUsIGxlbmd0aCkgPT4ge1xuXG4gIGlmIChzLmJpX3ZhbGlkID4gKEJ1Zl9zaXplIC0gbGVuZ3RoKSkge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gdmFsdWUgPj4gKEJ1Zl9zaXplIC0gcy5iaV92YWxpZCk7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGggLSBCdWZfc2l6ZTtcbiAgfSBlbHNlIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGg7XG4gIH1cbn07XG5cblxuY29uc3Qgc2VuZF9jb2RlID0gKHMsIGMsIHRyZWUpID0+IHtcblxuICBzZW5kX2JpdHMocywgdHJlZVtjICogMl0vKi5Db2RlKi8sIHRyZWVbYyAqIDIgKyAxXS8qLkxlbiovKTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXZlcnNlIHRoZSBmaXJzdCBsZW4gYml0cyBvZiBhIGNvZGUsIHVzaW5nIHN0cmFpZ2h0Zm9yd2FyZCBjb2RlIChhIGZhc3RlclxuICogbWV0aG9kIHdvdWxkIHVzZSBhIHRhYmxlKVxuICogSU4gYXNzZXJ0aW9uOiAxIDw9IGxlbiA8PSAxNVxuICovXG5jb25zdCBiaV9yZXZlcnNlID0gKGNvZGUsIGxlbikgPT4ge1xuXG4gIGxldCByZXMgPSAwO1xuICBkbyB7XG4gICAgcmVzIHw9IGNvZGUgJiAxO1xuICAgIGNvZGUgPj4+PSAxO1xuICAgIHJlcyA8PD0gMTtcbiAgfSB3aGlsZSAoLS1sZW4gPiAwKTtcbiAgcmV0dXJuIHJlcyA+Pj4gMTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciwga2VlcGluZyBhdCBtb3N0IDcgYml0cyBpbiBpdC5cbiAqL1xuY29uc3QgYmlfZmx1c2ggPSAocykgPT4ge1xuXG4gIGlmIChzLmJpX3ZhbGlkID09PSAxNikge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSAwO1xuICAgIHMuYmlfdmFsaWQgPSAwO1xuXG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+PSA4KSB7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZiAmIDB4ZmY7XG4gICAgcy5iaV9idWYgPj49IDg7XG4gICAgcy5iaV92YWxpZCAtPSA4O1xuICB9XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyBmb3IgYSB0cmVlIGFuZCB1cGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGhcbiAqIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldCwgaGVhcFtoZWFwX21heF0gYW5kXG4gKiAgICBhYm92ZSBhcmUgdGhlIHRyZWUgbm9kZXMgc29ydGVkIGJ5IGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZCBsZW4gaXMgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGgsIHRoZVxuICogICAgIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBmcmVxdWVuY2llcyBmb3IgZWFjaCBiaXQgbGVuZ3RoLlxuICogICAgIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpc1xuICogICAgIG5vdCBudWxsLlxuICovXG5jb25zdCBnZW5fYml0bGVuID0gKHMsIGRlc2MpID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAgICAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIGNvbnN0IHRyZWUgICAgICAgICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIGNvbnN0IG1heF9jb2RlICAgICAgICA9IGRlc2MubWF4X2NvZGU7XG4gIGNvbnN0IHN0cmVlICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICBjb25zdCBoYXNfc3RyZWUgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIGNvbnN0IGV4dHJhICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2JpdHM7XG4gIGNvbnN0IGJhc2UgICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2Jhc2U7XG4gIGNvbnN0IG1heF9sZW5ndGggICAgICA9IGRlc2Muc3RhdF9kZXNjLm1heF9sZW5ndGg7XG4gIGxldCBoOyAgICAgICAgICAgICAgLyogaGVhcCBpbmRleCAqL1xuICBsZXQgbiwgbTsgICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBlbGVtZW50cyAqL1xuICBsZXQgYml0czsgICAgICAgICAgIC8qIGJpdCBsZW5ndGggKi9cbiAgbGV0IHhiaXRzOyAgICAgICAgICAvKiBleHRyYSBiaXRzICovXG4gIGxldCBmOyAgICAgICAgICAgICAgLyogZnJlcXVlbmN5ICovXG4gIGxldCBvdmVyZmxvdyA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIHdpdGggYml0IGxlbmd0aCB0b28gbGFyZ2UgKi9cblxuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBzLmJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIC8qIEluIGEgZmlyc3QgcGFzcywgY29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyAod2hpY2ggbWF5XG4gICAqIG92ZXJmbG93IGluIHRoZSBjYXNlIG9mIHRoZSBiaXQgbGVuZ3RoIHRyZWUpLlxuICAgKi9cbiAgdHJlZVtzLmhlYXBbcy5oZWFwX21heF0gKiAyICsgMV0vKi5MZW4qLyA9IDA7IC8qIHJvb3Qgb2YgdGhlIGhlYXAgKi9cblxuICBmb3IgKGggPSBzLmhlYXBfbWF4ICsgMTsgaCA8IEhFQVBfU0laRTsgaCsrKSB7XG4gICAgbiA9IHMuaGVhcFtoXTtcbiAgICBiaXRzID0gdHJlZVt0cmVlW24gKiAyICsgMV0vKi5EYWQqLyAqIDIgKyAxXS8qLkxlbiovICsgMTtcbiAgICBpZiAoYml0cyA+IG1heF9sZW5ndGgpIHtcbiAgICAgIGJpdHMgPSBtYXhfbGVuZ3RoO1xuICAgICAgb3ZlcmZsb3crKztcbiAgICB9XG4gICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgIC8qIFdlIG92ZXJ3cml0ZSB0cmVlW25dLkRhZCB3aGljaCBpcyBubyBsb25nZXIgbmVlZGVkICovXG5cbiAgICBpZiAobiA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9IC8qIG5vdCBhIGxlYWYgbm9kZSAqL1xuXG4gICAgcy5ibF9jb3VudFtiaXRzXSsrO1xuICAgIHhiaXRzID0gMDtcbiAgICBpZiAobiA+PSBiYXNlKSB7XG4gICAgICB4Yml0cyA9IGV4dHJhW24gLSBiYXNlXTtcbiAgICB9XG4gICAgZiA9IHRyZWVbbiAqIDJdLyouRnJlcSovO1xuICAgIHMub3B0X2xlbiArPSBmICogKGJpdHMgKyB4Yml0cyk7XG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuICs9IGYgKiAoc3RyZWVbbiAqIDIgKyAxXS8qLkxlbiovICsgeGJpdHMpO1xuICAgIH1cbiAgfVxuICBpZiAob3ZlcmZsb3cgPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgLy8gVHJhY2UoKHN0ZGVycixcIlxcbmJpdCBsZW5ndGggb3ZlcmZsb3dcXG5cIikpO1xuICAvKiBUaGlzIGhhcHBlbnMgZm9yIGV4YW1wbGUgb24gb2JqMiBhbmQgcGljIG9mIHRoZSBDYWxnYXJ5IGNvcnB1cyAqL1xuXG4gIC8qIEZpbmQgdGhlIGZpcnN0IGJpdCBsZW5ndGggd2hpY2ggY291bGQgaW5jcmVhc2U6ICovXG4gIGRvIHtcbiAgICBiaXRzID0gbWF4X2xlbmd0aCAtIDE7XG4gICAgd2hpbGUgKHMuYmxfY291bnRbYml0c10gPT09IDApIHsgYml0cy0tOyB9XG4gICAgcy5ibF9jb3VudFtiaXRzXS0tOyAgICAgIC8qIG1vdmUgb25lIGxlYWYgZG93biB0aGUgdHJlZSAqL1xuICAgIHMuYmxfY291bnRbYml0cyArIDFdICs9IDI7IC8qIG1vdmUgb25lIG92ZXJmbG93IGl0ZW0gYXMgaXRzIGJyb3RoZXIgKi9cbiAgICBzLmJsX2NvdW50W21heF9sZW5ndGhdLS07XG4gICAgLyogVGhlIGJyb3RoZXIgb2YgdGhlIG92ZXJmbG93IGl0ZW0gYWxzbyBtb3ZlcyBvbmUgc3RlcCB1cCxcbiAgICAgKiBidXQgdGhpcyBkb2VzIG5vdCBhZmZlY3QgYmxfY291bnRbbWF4X2xlbmd0aF1cbiAgICAgKi9cbiAgICBvdmVyZmxvdyAtPSAyO1xuICB9IHdoaWxlIChvdmVyZmxvdyA+IDApO1xuXG4gIC8qIE5vdyByZWNvbXB1dGUgYWxsIGJpdCBsZW5ndGhzLCBzY2FubmluZyBpbiBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAgICogaCBpcyBzdGlsbCBlcXVhbCB0byBIRUFQX1NJWkUuIChJdCBpcyBzaW1wbGVyIHRvIHJlY29uc3RydWN0IGFsbFxuICAgKiBsZW5ndGhzIGluc3RlYWQgb2YgZml4aW5nIG9ubHkgdGhlIHdyb25nIG9uZXMuIFRoaXMgaWRlYSBpcyB0YWtlblxuICAgKiBmcm9tICdhcicgd3JpdHRlbiBieSBIYXJ1aGlrbyBPa3VtdXJhLilcbiAgICovXG4gIGZvciAoYml0cyA9IG1heF9sZW5ndGg7IGJpdHMgIT09IDA7IGJpdHMtLSkge1xuICAgIG4gPSBzLmJsX2NvdW50W2JpdHNdO1xuICAgIHdoaWxlIChuICE9PSAwKSB7XG4gICAgICBtID0gcy5oZWFwWy0taF07XG4gICAgICBpZiAobSA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9XG4gICAgICBpZiAodHJlZVttICogMiArIDFdLyouTGVuKi8gIT09IGJpdHMpIHtcbiAgICAgICAgLy8gVHJhY2UoKHN0ZGVycixcImNvZGUgJWQgYml0cyAlZC0+JWRcXG5cIiwgbSwgdHJlZVttXS5MZW4sIGJpdHMpKTtcbiAgICAgICAgcy5vcHRfbGVuICs9IChiaXRzIC0gdHJlZVttICogMiArIDFdLyouTGVuKi8pICogdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgICAgIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAgIH1cbiAgICAgIG4tLTtcbiAgICB9XG4gIH1cbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBHZW5lcmF0ZSB0aGUgY29kZXMgZm9yIGEgZ2l2ZW4gdHJlZSBhbmQgYml0IGNvdW50cyAod2hpY2ggbmVlZCBub3QgYmVcbiAqIG9wdGltYWwpLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGJpdCBsZW5ndGggc3RhdGlzdGljcyBmb3JcbiAqIHRoZSBnaXZlbiB0cmVlIGFuZCB0aGUgZmllbGQgbGVuIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgZmllbGQgY29kZSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzIG9mIG5vblxuICogICAgIHplcm8gY29kZSBsZW5ndGguXG4gKi9cbmNvbnN0IGdlbl9jb2RlcyA9ICh0cmVlLCBtYXhfY29kZSwgYmxfY291bnQpID0+XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgICAgICAgICAgICAvKiB0aGUgdHJlZSB0byBkZWNvcmF0ZSAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4vLyAgICB1c2hmICpibF9jb3VudDsgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoICovXG57XG4gIGNvbnN0IG5leHRfY29kZSA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpOyAvKiBuZXh0IGNvZGUgdmFsdWUgZm9yIGVhY2ggYml0IGxlbmd0aCAqL1xuICBsZXQgY29kZSA9IDA7ICAgICAgICAgICAgICAvKiBydW5uaW5nIGNvZGUgdmFsdWUgKi9cbiAgbGV0IGJpdHM7ICAgICAgICAgICAgICAgICAgLyogYml0IGluZGV4ICovXG4gIGxldCBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgaW5kZXggKi9cblxuICAvKiBUaGUgZGlzdHJpYnV0aW9uIGNvdW50cyBhcmUgZmlyc3QgdXNlZCB0byBnZW5lcmF0ZSB0aGUgY29kZSB2YWx1ZXNcbiAgICogd2l0aG91dCBiaXQgcmV2ZXJzYWwuXG4gICAqL1xuICBmb3IgKGJpdHMgPSAxOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBuZXh0X2NvZGVbYml0c10gPSBjb2RlID0gKGNvZGUgKyBibF9jb3VudFtiaXRzIC0gMV0pIDw8IDE7XG4gIH1cbiAgLyogQ2hlY2sgdGhhdCB0aGUgYml0IGNvdW50cyBpbiBibF9jb3VudCBhcmUgY29uc2lzdGVudC4gVGhlIGxhc3QgY29kZVxuICAgKiBtdXN0IGJlIGFsbCBvbmVzLlxuICAgKi9cbiAgLy9Bc3NlcnQgKGNvZGUgKyBibF9jb3VudFtNQVhfQklUU10tMSA9PSAoMTw8TUFYX0JJVFMpLTEsXG4gIC8vICAgICAgICBcImluY29uc2lzdGVudCBiaXQgY291bnRzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLFwiXFxuZ2VuX2NvZGVzOiBtYXhfY29kZSAlZCBcIiwgbWF4X2NvZGUpKTtcblxuICBmb3IgKG4gPSAwOyAgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgbGV0IGxlbiA9IHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovO1xuICAgIGlmIChsZW4gPT09IDApIHsgY29udGludWU7IH1cbiAgICAvKiBOb3cgcmV2ZXJzZSB0aGUgYml0cyAqL1xuICAgIHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuZXh0X2NvZGVbbGVuXSsrLCBsZW4pO1xuXG4gICAgLy9UcmFjZWN2KHRyZWUgIT0gc3RhdGljX2x0cmVlLCAoc3RkZXJyLFwiXFxubiAlM2QgJWMgbCAlMmQgYyAlNHggKCV4KSBcIixcbiAgICAvLyAgICAgbiwgKGlzZ3JhcGgobikgPyBuIDogJyAnKSwgbGVuLCB0cmVlW25dLkNvZGUsIG5leHRfY29kZVtsZW5dLTEpKTtcbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHZhcmlvdXMgJ2NvbnN0YW50JyB0YWJsZXMuXG4gKi9cbmNvbnN0IHRyX3N0YXRpY19pbml0ID0gKCkgPT4ge1xuXG4gIGxldCBuOyAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG4gIGxldCBiaXRzOyAgICAgLyogYml0IGNvdW50ZXIgKi9cbiAgbGV0IGxlbmd0aDsgICAvKiBsZW5ndGggdmFsdWUgKi9cbiAgbGV0IGNvZGU7ICAgICAvKiBjb2RlIHZhbHVlICovXG4gIGxldCBkaXN0OyAgICAgLyogZGlzdGFuY2UgaW5kZXggKi9cbiAgY29uc3QgYmxfY291bnQgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy8gZG8gY2hlY2sgaW4gX3RyX2luaXQoKVxuICAvL2lmIChzdGF0aWNfaW5pdF9kb25lKSByZXR1cm47XG5cbiAgLyogRm9yIHNvbWUgZW1iZWRkZWQgdGFyZ2V0cywgZ2xvYmFsIHZhcmlhYmxlcyBhcmUgbm90IGluaXRpYWxpemVkOiAqL1xuLyojaWZkZWYgTk9fSU5JVF9HTE9CQUxfUE9JTlRFUlNcbiAgc3RhdGljX2xfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19sdHJlZTtcbiAgc3RhdGljX2xfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfbGJpdHM7XG4gIHN0YXRpY19kX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfZHRyZWU7XG4gIHN0YXRpY19kX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2RiaXRzO1xuICBzdGF0aWNfYmxfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfYmxiaXRzO1xuI2VuZGlmKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGxlbmd0aCAoMC4uMjU1KSAtPiBsZW5ndGggY29kZSAoMC4uMjgpICovXG4gIGxlbmd0aCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCBMRU5HVEhfQ09ERVMgLSAxOyBjb2RlKyspIHtcbiAgICBiYXNlX2xlbmd0aFtjb2RlXSA9IGxlbmd0aDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfbGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9sZW5ndGhfY29kZVtsZW5ndGgrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAobGVuZ3RoID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogbGVuZ3RoICE9IDI1NlwiKTtcbiAgLyogTm90ZSB0aGF0IHRoZSBsZW5ndGggMjU1IChtYXRjaCBsZW5ndGggMjU4KSBjYW4gYmUgcmVwcmVzZW50ZWRcbiAgICogaW4gdHdvIGRpZmZlcmVudCB3YXlzOiBjb2RlIDI4NCArIDUgYml0cyBvciBjb2RlIDI4NSwgc28gd2VcbiAgICogb3ZlcndyaXRlIGxlbmd0aF9jb2RlWzI1NV0gdG8gdXNlIHRoZSBiZXN0IGVuY29kaW5nOlxuICAgKi9cbiAgX2xlbmd0aF9jb2RlW2xlbmd0aCAtIDFdID0gY29kZTtcblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGRpc3QgKDAuLjMySykgLT4gZGlzdCBjb2RlICgwLi4yOSkgKi9cbiAgZGlzdCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCAxNjsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfZGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogZGlzdCAhPSAyNTZcIik7XG4gIGRpc3QgPj49IDc7IC8qIGZyb20gbm93IG9uLCBhbGwgZGlzdGFuY2VzIGFyZSBkaXZpZGVkIGJ5IDEyOCAqL1xuICBmb3IgKDsgY29kZSA8IERfQ09ERVM7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3QgPDwgNztcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgKGV4dHJhX2RiaXRzW2NvZGVdIC0gNykpOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbMjU2ICsgZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogMjU2K2Rpc3QgIT0gNTEyXCIpO1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgY29kZXMgb2YgdGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUgKi9cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgbiA9IDA7XG4gIHdoaWxlIChuIDw9IDE0Mykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI1NSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA5O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs5XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI3OSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA3O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs3XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI4Nykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIC8qIENvZGVzIDI4NiBhbmQgMjg3IGRvIG5vdCBleGlzdCwgYnV0IHdlIG11c3QgaW5jbHVkZSB0aGVtIGluIHRoZVxuICAgKiB0cmVlIGNvbnN0cnVjdGlvbiB0byBnZXQgYSBjYW5vbmljYWwgSHVmZm1hbiB0cmVlIChsb25nZXN0IGNvZGVcbiAgICogYWxsIG9uZXMpXG4gICAqL1xuICBnZW5fY29kZXMoc3RhdGljX2x0cmVlLCBMX0NPREVTICsgMSwgYmxfY291bnQpO1xuXG4gIC8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZSBpcyB0cml2aWFsOiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgbisrKSB7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDU7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobiwgNSk7XG4gIH1cblxuICAvLyBOb3cgZGF0YSByZWFkeSBhbmQgd2UgY2FuIGluaXQgc3RhdGljIHRyZWVzXG4gIHN0YXRpY19sX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2x0cmVlLCBleHRyYV9sYml0cywgTElURVJBTFMgKyAxLCBMX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19kX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2R0cmVlLCBleHRyYV9kYml0cywgMCwgICAgICAgICAgRF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfYmxfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhuZXcgQXJyYXkoMCksIGV4dHJhX2JsYml0cywgMCwgICAgICAgICBCTF9DT0RFUywgTUFYX0JMX0JJVFMpO1xuXG4gIC8vc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSBhIG5ldyBibG9jay5cbiAqL1xuY29uc3QgaW5pdF9ibG9jayA9IChzKSA9PiB7XG5cbiAgbGV0IG47IC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIHRyZWVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgTF9DT0RFUzsgIG4rKykgeyBzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyAgbisrKSB7IHMuZHluX2R0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IEJMX0NPREVTOyBuKyspIHsgcy5ibF90cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cblxuICBzLmR5bl9sdHJlZVtFTkRfQkxPQ0sgKiAyXS8qLkZyZXEqLyA9IDE7XG4gIHMub3B0X2xlbiA9IHMuc3RhdGljX2xlbiA9IDA7XG4gIHMubGFzdF9saXQgPSBzLm1hdGNoZXMgPSAwO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyIGFuZCBhbGlnbiB0aGUgb3V0cHV0IG9uIGEgYnl0ZSBib3VuZGFyeVxuICovXG5jb25zdCBiaV93aW5kdXAgPSAocykgPT5cbntcbiAgaWYgKHMuYmlfdmFsaWQgPiA4KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID4gMCkge1xuICAgIC8vcHV0X2J5dGUocywgKEJ5dGUpcy0+YmlfYnVmKTtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmO1xuICB9XG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgYSBzdG9yZWQgYmxvY2ssIHN0b3JpbmcgZmlyc3QgdGhlIGxlbmd0aCBhbmQgaXRzXG4gKiBvbmUncyBjb21wbGVtZW50IGlmIHJlcXVlc3RlZC5cbiAqL1xuY29uc3QgY29weV9ibG9jayA9IChzLCBidWYsIGxlbiwgaGVhZGVyKSA9PlxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICAgICpidWY7ICAgIC8qIHRoZSBpbnB1dCBkYXRhICovXG4vL3Vuc2lnbmVkIGxlbjsgICAgIC8qIGl0cyBsZW5ndGggKi9cbi8vaW50ICAgICAgaGVhZGVyOyAgLyogdHJ1ZSBpZiBibG9jayBoZWFkZXIgbXVzdCBiZSB3cml0dGVuICovXG57XG4gIGJpX3dpbmR1cChzKTsgICAgICAgIC8qIGFsaWduIG9uIGJ5dGUgYm91bmRhcnkgKi9cblxuICBpZiAoaGVhZGVyKSB7XG4gICAgcHV0X3Nob3J0KHMsIGxlbik7XG4gICAgcHV0X3Nob3J0KHMsIH5sZW4pO1xuICB9XG4vLyAgd2hpbGUgKGxlbi0tKSB7XG4vLyAgICBwdXRfYnl0ZShzLCAqYnVmKyspO1xuLy8gIH1cbiAgcy5wZW5kaW5nX2J1Zi5zZXQocy53aW5kb3cuc3ViYXJyYXkoYnVmLCBidWYgKyBsZW4pLCBzLnBlbmRpbmcpO1xuICBzLnBlbmRpbmcgKz0gbGVuO1xufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wYXJlcyB0byBzdWJ0cmVlcywgdXNpbmcgdGhlIHRyZWUgZGVwdGggYXMgdGllIGJyZWFrZXIgd2hlblxuICogdGhlIHN1YnRyZWVzIGhhdmUgZXF1YWwgZnJlcXVlbmN5LiBUaGlzIG1pbmltaXplcyB0aGUgd29yc3QgY2FzZSBsZW5ndGguXG4gKi9cbmNvbnN0IHNtYWxsZXIgPSAodHJlZSwgbiwgbSwgZGVwdGgpID0+IHtcblxuICBjb25zdCBfbjIgPSBuICogMjtcbiAgY29uc3QgX20yID0gbSAqIDI7XG4gIHJldHVybiAodHJlZVtfbjJdLyouRnJlcSovIDwgdHJlZVtfbTJdLyouRnJlcSovIHx8XG4gICAgICAgICAodHJlZVtfbjJdLyouRnJlcSovID09PSB0cmVlW19tMl0vKi5GcmVxKi8gJiYgZGVwdGhbbl0gPD0gZGVwdGhbbV0pKTtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVzdG9yZSB0aGUgaGVhcCBwcm9wZXJ0eSBieSBtb3ZpbmcgZG93biB0aGUgdHJlZSBzdGFydGluZyBhdCBub2RlIGssXG4gKiBleGNoYW5naW5nIGEgbm9kZSB3aXRoIHRoZSBzbWFsbGVzdCBvZiBpdHMgdHdvIHNvbnMgaWYgbmVjZXNzYXJ5LCBzdG9wcGluZ1xuICogd2hlbiB0aGUgaGVhcCBwcm9wZXJ0eSBpcyByZS1lc3RhYmxpc2hlZCAoZWFjaCBmYXRoZXIgc21hbGxlciB0aGFuIGl0c1xuICogdHdvIHNvbnMpLlxuICovXG5jb25zdCBwcWRvd25oZWFwID0gKHMsIHRyZWUsIGspID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgIC8qIHRoZSB0cmVlIHRvIHJlc3RvcmUgKi9cbi8vICAgIGludCBrOyAgICAgICAgICAgICAgIC8qIG5vZGUgdG8gbW92ZSBkb3duICovXG57XG4gIGNvbnN0IHYgPSBzLmhlYXBba107XG4gIGxldCBqID0gayA8PCAxOyAgLyogbGVmdCBzb24gb2YgayAqL1xuICB3aGlsZSAoaiA8PSBzLmhlYXBfbGVuKSB7XG4gICAgLyogU2V0IGogdG8gdGhlIHNtYWxsZXN0IG9mIHRoZSB0d28gc29uczogKi9cbiAgICBpZiAoaiA8IHMuaGVhcF9sZW4gJiZcbiAgICAgIHNtYWxsZXIodHJlZSwgcy5oZWFwW2ogKyAxXSwgcy5oZWFwW2pdLCBzLmRlcHRoKSkge1xuICAgICAgaisrO1xuICAgIH1cbiAgICAvKiBFeGl0IGlmIHYgaXMgc21hbGxlciB0aGFuIGJvdGggc29ucyAqL1xuICAgIGlmIChzbWFsbGVyKHRyZWUsIHYsIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHsgYnJlYWs7IH1cblxuICAgIC8qIEV4Y2hhbmdlIHYgd2l0aCB0aGUgc21hbGxlc3Qgc29uICovXG4gICAgcy5oZWFwW2tdID0gcy5oZWFwW2pdO1xuICAgIGsgPSBqO1xuXG4gICAgLyogQW5kIGNvbnRpbnVlIGRvd24gdGhlIHRyZWUsIHNldHRpbmcgaiB0byB0aGUgbGVmdCBzb24gb2YgayAqL1xuICAgIGogPDw9IDE7XG4gIH1cbiAgcy5oZWFwW2tdID0gdjtcbn07XG5cblxuLy8gaW5saW5lZCBtYW51YWxseVxuLy8gY29uc3QgU01BTExFU1QgPSAxO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGJsb2NrIGRhdGEgY29tcHJlc3NlZCB1c2luZyB0aGUgZ2l2ZW4gSHVmZm1hbiB0cmVlc1xuICovXG5jb25zdCBjb21wcmVzc19ibG9jayA9IChzLCBsdHJlZSwgZHRyZWUpID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY29uc3QgY3RfZGF0YSAqbHRyZWU7IC8qIGxpdGVyYWwgdHJlZSAqL1xuLy8gICAgY29uc3QgY3RfZGF0YSAqZHRyZWU7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbntcbiAgbGV0IGRpc3Q7ICAgICAgICAgICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuICBsZXQgbGM7ICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdCA9PSAwKSAqL1xuICBsZXQgbHggPSAwOyAgICAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cbiAgbGV0IGNvZGU7ICAgICAgICAgICAvKiB0aGUgY29kZSB0byBzZW5kICovXG4gIGxldCBleHRyYTsgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgdG8gc2VuZCAqL1xuXG4gIGlmIChzLmxhc3RfbGl0ICE9PSAwKSB7XG4gICAgZG8ge1xuICAgICAgZGlzdCA9IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDJdIDw8IDgpIHwgKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMiArIDFdKTtcbiAgICAgIGxjID0gcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgbHhdO1xuICAgICAgbHgrKztcblxuICAgICAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGxjLCBsdHJlZSk7IC8qIHNlbmQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgICAgLy9UcmFjZWN2KGlzZ3JhcGgobGMpLCAoc3RkZXJyLFwiICclYycgXCIsIGxjKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgICAgIGNvZGUgPSBfbGVuZ3RoX2NvZGVbbGNdO1xuICAgICAgICBzZW5kX2NvZGUocywgY29kZSArIExJVEVSQUxTICsgMSwgbHRyZWUpOyAvKiBzZW5kIHRoZSBsZW5ndGggY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2xiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBsYyAtPSBiYXNlX2xlbmd0aFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgbGMsIGV4dHJhKTsgICAgICAgLyogc2VuZCB0aGUgZXh0cmEgbGVuZ3RoIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgICBkaXN0LS07IC8qIGRpc3QgaXMgbm93IHRoZSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAgICAgY29kZSA9IGRfY29kZShkaXN0KTtcbiAgICAgICAgLy9Bc3NlcnQgKGNvZGUgPCBEX0NPREVTLCBcImJhZCBkX2NvZGVcIik7XG5cbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUsIGR0cmVlKTsgICAgICAgLyogc2VuZCB0aGUgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2RiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBkaXN0IC09IGJhc2VfZGlzdFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgZGlzdCwgZXh0cmEpOyAgIC8qIHNlbmQgdGhlIGV4dHJhIGRpc3RhbmNlIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgfSAvKiBsaXRlcmFsIG9yIG1hdGNoIHBhaXIgPyAqL1xuXG4gICAgICAvKiBDaGVjayB0aGF0IHRoZSBvdmVybGF5IGJldHdlZW4gcGVuZGluZ19idWYgYW5kIGRfYnVmK2xfYnVmIGlzIG9rOiAqL1xuICAgICAgLy9Bc3NlcnQoKHVJbnQpKHMtPnBlbmRpbmcpIDwgcy0+bGl0X2J1ZnNpemUgKyAyKmx4LFxuICAgICAgLy8gICAgICAgXCJwZW5kaW5nQnVmIG92ZXJmbG93XCIpO1xuXG4gICAgfSB3aGlsZSAobHggPCBzLmxhc3RfbGl0KTtcbiAgfVxuXG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIGx0cmVlKTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3Qgb25lIEh1ZmZtYW4gdHJlZSBhbmQgYXNzaWducyB0aGUgY29kZSBiaXQgc3RyaW5ncyBhbmQgbGVuZ3Rocy5cbiAqIFVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aCBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZCBmcmVxIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkcyBsZW4gYW5kIGNvZGUgYXJlIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoXG4gKiAgICAgYW5kIGNvcnJlc3BvbmRpbmcgY29kZS4gVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXNcbiAqICAgICBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXMgbm90IG51bGwuIFRoZSBmaWVsZCBtYXhfY29kZSBpcyBzZXQuXG4gKi9cbmNvbnN0IGJ1aWxkX3RyZWUgPSAocywgZGVzYykgPT5cbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7IC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgY29uc3QgdHJlZSAgICAgPSBkZXNjLmR5bl90cmVlO1xuICBjb25zdCBzdHJlZSAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICBjb25zdCBoYXNfc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIGNvbnN0IGVsZW1zICAgID0gZGVzYy5zdGF0X2Rlc2MuZWxlbXM7XG4gIGxldCBuLCBtOyAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgaGVhcCBlbGVtZW50cyAqL1xuICBsZXQgbWF4X2NvZGUgPSAtMTsgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIGxldCBub2RlOyAgICAgICAgICAvKiBuZXcgbm9kZSBiZWluZyBjcmVhdGVkICovXG5cbiAgLyogQ29uc3RydWN0IHRoZSBpbml0aWFsIGhlYXAsIHdpdGggbGVhc3QgZnJlcXVlbnQgZWxlbWVudCBpblxuICAgKiBoZWFwW1NNQUxMRVNUXS4gVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS5cbiAgICogaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICovXG4gIHMuaGVhcF9sZW4gPSAwO1xuICBzLmhlYXBfbWF4ID0gSEVBUF9TSVpFO1xuXG4gIGZvciAobiA9IDA7IG4gPCBlbGVtczsgbisrKSB7XG4gICAgaWYgKHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IG1heF9jb2RlID0gbjtcbiAgICAgIHMuZGVwdGhbbl0gPSAwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gMDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGUgcGt6aXAgZm9ybWF0IHJlcXVpcmVzIHRoYXQgYXQgbGVhc3Qgb25lIGRpc3RhbmNlIGNvZGUgZXhpc3RzLFxuICAgKiBhbmQgdGhhdCBhdCBsZWFzdCBvbmUgYml0IHNob3VsZCBiZSBzZW50IGV2ZW4gaWYgdGhlcmUgaXMgb25seSBvbmVcbiAgICogcG9zc2libGUgY29kZS4gU28gdG8gYXZvaWQgc3BlY2lhbCBjaGVja3MgbGF0ZXIgb24gd2UgZm9yY2UgYXQgbGVhc3RcbiAgICogdHdvIGNvZGVzIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeS5cbiAgICovXG4gIHdoaWxlIChzLmhlYXBfbGVuIDwgMikge1xuICAgIG5vZGUgPSBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IChtYXhfY29kZSA8IDIgPyArK21heF9jb2RlIDogMCk7XG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSAxO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAwO1xuICAgIHMub3B0X2xlbi0tO1xuXG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuIC09IHN0cmVlW25vZGUgKiAyICsgMV0vKi5MZW4qLztcbiAgICB9XG4gICAgLyogbm9kZSBpcyAwIG9yIDEgc28gaXQgZG9lcyBub3QgaGF2ZSBleHRyYSBiaXRzICovXG4gIH1cbiAgZGVzYy5tYXhfY29kZSA9IG1heF9jb2RlO1xuXG4gIC8qIFRoZSBlbGVtZW50cyBoZWFwW2hlYXBfbGVuLzIrMSAuLiBoZWFwX2xlbl0gYXJlIGxlYXZlcyBvZiB0aGUgdHJlZSxcbiAgICogZXN0YWJsaXNoIHN1Yi1oZWFwcyBvZiBpbmNyZWFzaW5nIGxlbmd0aHM6XG4gICAqL1xuICBmb3IgKG4gPSAocy5oZWFwX2xlbiA+PiAxLyppbnQgLzIqLyk7IG4gPj0gMTsgbi0tKSB7IHBxZG93bmhlYXAocywgdHJlZSwgbik7IH1cblxuICAvKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBieSByZXBlYXRlZGx5IGNvbWJpbmluZyB0aGUgbGVhc3QgdHdvXG4gICAqIGZyZXF1ZW50IG5vZGVzLlxuICAgKi9cbiAgbm9kZSA9IGVsZW1zOyAgICAgICAgICAgICAgLyogbmV4dCBpbnRlcm5hbCBub2RlIG9mIHRoZSB0cmVlICovXG4gIGRvIHtcbiAgICAvL3BxcmVtb3ZlKHMsIHRyZWUsIG4pOyAgLyogbiA9IG5vZGUgb2YgbGVhc3QgZnJlcXVlbmN5ICovXG4gICAgLyoqKiBwcXJlbW92ZSAqKiovXG4gICAgbiA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBzLmhlYXBbcy5oZWFwX2xlbi0tXTtcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuICAgIC8qKiovXG5cbiAgICBtID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dOyAvKiBtID0gbm9kZSBvZiBuZXh0IGxlYXN0IGZyZXF1ZW5jeSAqL1xuXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBuOyAvKiBrZWVwIHRoZSBub2RlcyBzb3J0ZWQgYnkgZnJlcXVlbmN5ICovXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBtO1xuXG4gICAgLyogQ3JlYXRlIGEgbmV3IG5vZGUgZmF0aGVyIG9mIG4gYW5kIG0gKi9cbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IHRyZWVbbiAqIDJdLyouRnJlcSovICsgdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgcy5kZXB0aFtub2RlXSA9IChzLmRlcHRoW25dID49IHMuZGVwdGhbbV0gPyBzLmRlcHRoW25dIDogcy5kZXB0aFttXSkgKyAxO1xuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkRhZCovID0gdHJlZVttICogMiArIDFdLyouRGFkKi8gPSBub2RlO1xuXG4gICAgLyogYW5kIGluc2VydCB0aGUgbmV3IG5vZGUgaW4gdGhlIGhlYXAgKi9cbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBub2RlKys7XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcblxuICB9IHdoaWxlIChzLmhlYXBfbGVuID49IDIpO1xuXG4gIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuXG4gIC8qIEF0IHRoaXMgcG9pbnQsIHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQuIFdlIGNhbiBub3dcbiAgICogZ2VuZXJhdGUgdGhlIGJpdCBsZW5ndGhzLlxuICAgKi9cbiAgZ2VuX2JpdGxlbihzLCBkZXNjKTtcblxuICAvKiBUaGUgZmllbGQgbGVuIGlzIG5vdyBzZXQsIHdlIGNhbiBnZW5lcmF0ZSB0aGUgYml0IGNvZGVzICovXG4gIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgcy5ibF9jb3VudCk7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2NhbiBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSB0byBkZXRlcm1pbmUgdGhlIGZyZXF1ZW5jaWVzIG9mIHRoZSBjb2Rlc1xuICogaW4gdGhlIGJpdCBsZW5ndGggdHJlZS5cbiAqL1xuY29uc3Qgc2Nhbl90cmVlID0gKHMsIHRyZWUsIG1heF9jb2RlKSA9PlxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgbGV0IG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICBsZXQgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIGxldCBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICBsZXQgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgbGV0IGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgbGV0IG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICBsZXQgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuICB0cmVlWyhtYXhfY29kZSArIDEpICogMiArIDFdLyouTGVuKi8gPSAweGZmZmY7IC8qIGd1YXJkICovXG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovICs9IGNvdW50O1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcblxuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikgeyBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8rKzsgfVxuICAgICAgcy5ibF90cmVlW1JFUF8zXzYgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgcy5ibF90cmVlW1JFUFpfM18xMCAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcy5ibF90cmVlW1JFUFpfMTFfMTM4ICogMl0vKi5GcmVxKi8rKztcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcblxuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgaW4gY29tcHJlc3NlZCBmb3JtLCB1c2luZyB0aGUgY29kZXMgaW5cbiAqIGJsX3RyZWUuXG4gKi9cbmNvbnN0IHNlbmRfdHJlZSA9IChzLCB0cmVlLCBtYXhfY29kZSkgPT5cbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICBsZXQgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIGxldCBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgbGV0IGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIGxldCBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICBsZXQgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICBsZXQgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIGxldCBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICAvKiB0cmVlW21heF9jb2RlKzFdLkxlbiA9IC0xOyAqLyAgLyogZ3VhcmQgYWxyZWFkeSBzZXQgKi9cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIGRvIHsgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTsgfSB3aGlsZSAoLS1jb3VudCAhPT0gMCk7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikge1xuICAgICAgICBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpO1xuICAgICAgICBjb3VudC0tO1xuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoY291bnQgPj0gMyAmJiBjb3VudCA8PSA2LCBcIiAzXzY/XCIpO1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUF8zXzYsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAyKTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzNfMTAsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAzKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8xMV8xMzgsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAxMSwgNyk7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgZm9yIHRoZSBiaXQgbGVuZ3RocyBhbmQgcmV0dXJuIHRoZSBpbmRleCBpblxuICogYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gKi9cbmNvbnN0IGJ1aWxkX2JsX3RyZWUgPSAocykgPT4ge1xuXG4gIGxldCBtYXhfYmxpbmRleDsgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIGJpdCBsZW5ndGggZnJlcXVlbmNpZXMgZm9yIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gIHNjYW5fdHJlZShzLCBzLmR5bl9sdHJlZSwgcy5sX2Rlc2MubWF4X2NvZGUpO1xuICBzY2FuX3RyZWUocywgcy5keW5fZHRyZWUsIHMuZF9kZXNjLm1heF9jb2RlKTtcblxuICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlOiAqL1xuICBidWlsZF90cmVlKHMsIHMuYmxfZGVzYyk7XG4gIC8qIG9wdF9sZW4gbm93IGluY2x1ZGVzIHRoZSBsZW5ndGggb2YgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLCBleGNlcHRcbiAgICogdGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGhzIGNvZGVzIGFuZCB0aGUgNSs1KzQgYml0cyBmb3IgdGhlIGNvdW50cy5cbiAgICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYml0IGxlbmd0aCBjb2RlcyB0byBzZW5kLiBUaGUgcGt6aXAgZm9ybWF0XG4gICAqIHJlcXVpcmVzIHRoYXQgYXQgbGVhc3QgNCBiaXQgbGVuZ3RoIGNvZGVzIGJlIHNlbnQuIChhcHBub3RlLnR4dCBzYXlzXG4gICAqIDMgYnV0IHRoZSBhY3R1YWwgdmFsdWUgdXNlZCBpcyA0LilcbiAgICovXG4gIGZvciAobWF4X2JsaW5kZXggPSBCTF9DT0RFUyAtIDE7IG1heF9ibGluZGV4ID49IDM7IG1heF9ibGluZGV4LS0pIHtcbiAgICBpZiAocy5ibF90cmVlW2JsX29yZGVyW21heF9ibGluZGV4XSAqIDIgKyAxXS8qLkxlbiovICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLyogVXBkYXRlIG9wdF9sZW4gdG8gaW5jbHVkZSB0aGUgYml0IGxlbmd0aCB0cmVlIGFuZCBjb3VudHMgKi9cbiAgcy5vcHRfbGVuICs9IDMgKiAobWF4X2JsaW5kZXggKyAxKSArIDUgKyA1ICsgNDtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5keW4gdHJlZXM6IGR5biAlbGQsIHN0YXQgJWxkXCIsXG4gIC8vICAgICAgICBzLT5vcHRfbGVuLCBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgcmV0dXJuIG1heF9ibGluZGV4O1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGhlYWRlciBmb3IgYSBibG9jayB1c2luZyBkeW5hbWljIEh1ZmZtYW4gdHJlZXM6IHRoZSBjb3VudHMsIHRoZVxuICogbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcywgdGhlIGxpdGVyYWwgdHJlZSBhbmQgdGhlIGRpc3RhbmNlIHRyZWUuXG4gKiBJTiBhc3NlcnRpb246IGxjb2RlcyA+PSAyNTcsIGRjb2RlcyA+PSAxLCBibGNvZGVzID49IDQuXG4gKi9cbmNvbnN0IHNlbmRfYWxsX3RyZWVzID0gKHMsIGxjb2RlcywgZGNvZGVzLCBibGNvZGVzKSA9PlxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGludCBsY29kZXMsIGRjb2RlcywgYmxjb2RlczsgLyogbnVtYmVyIG9mIGNvZGVzIGZvciBlYWNoIHRyZWUgKi9cbntcbiAgbGV0IHJhbms7ICAgICAgICAgICAgICAgICAgICAvKiBpbmRleCBpbiBibF9vcmRlciAqL1xuXG4gIC8vQXNzZXJ0IChsY29kZXMgPj0gMjU3ICYmIGRjb2RlcyA+PSAxICYmIGJsY29kZXMgPj0gNCwgXCJub3QgZW5vdWdoIGNvZGVzXCIpO1xuICAvL0Fzc2VydCAobGNvZGVzIDw9IExfQ09ERVMgJiYgZGNvZGVzIDw9IERfQ09ERVMgJiYgYmxjb2RlcyA8PSBCTF9DT0RFUyxcbiAgLy8gICAgICAgIFwidG9vIG1hbnkgY29kZXNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY291bnRzOiBcIikpO1xuICBzZW5kX2JpdHMocywgbGNvZGVzIC0gMjU3LCA1KTsgLyogbm90ICsyNTUgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIHNlbmRfYml0cyhzLCBkY29kZXMgLSAxLCAgIDUpO1xuICBzZW5kX2JpdHMocywgYmxjb2RlcyAtIDQsICA0KTsgLyogbm90IC0zIGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBmb3IgKHJhbmsgPSAwOyByYW5rIDwgYmxjb2RlczsgcmFuaysrKSB7XG4gICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb2RlICUyZCBcIiwgYmxfb3JkZXJbcmFua10pKTtcbiAgICBzZW5kX2JpdHMocywgcy5ibF90cmVlW2JsX29yZGVyW3JhbmtdICogMiArIDFdLyouTGVuKi8sIDMpO1xuICB9XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2x0cmVlLCBsY29kZXMgLSAxKTsgLyogbGl0ZXJhbCB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9kdHJlZSwgZGNvZGVzIC0gMSk7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENoZWNrIGlmIHRoZSBkYXRhIHR5cGUgaXMgVEVYVCBvciBCSU5BUlksIHVzaW5nIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtOlxuICogLSBURVhUIGlmIHRoZSB0d28gY29uZGl0aW9ucyBiZWxvdyBhcmUgc2F0aXNmaWVkOlxuICogICAgYSkgVGhlcmUgYXJlIG5vIG5vbi1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJibGFjayBsaXN0XCIgKDAuLjYsIDE0Li4yNSwgMjguLjMxKS5cbiAqICAgIGIpIFRoZXJlIGlzIGF0IGxlYXN0IG9uZSBwcmludGFibGUgY2hhcmFjdGVyIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwid2hpdGUgbGlzdFwiICg5IHtUQUJ9LCAxMCB7TEZ9LCAxMyB7Q1J9LCAzMi4uMjU1KS5cbiAqIC0gQklOQVJZIG90aGVyd2lzZS5cbiAqIC0gVGhlIGZvbGxvd2luZyBwYXJ0aWFsbHktcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGZvcm0gYVxuICogICBcImdyYXkgbGlzdFwiIHRoYXQgaXMgaWdub3JlZCBpbiB0aGlzIGRldGVjdGlvbiBhbGdvcml0aG06XG4gKiAgICg3IHtCRUx9LCA4IHtCU30sIDExIHtWVH0sIDEyIHtGRn0sIDI2IHtTVUJ9LCAyNyB7RVNDfSkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgRnJlcSBvZiBkeW5fbHRyZWUgYXJlIHNldC5cbiAqL1xuY29uc3QgZGV0ZWN0X2RhdGFfdHlwZSA9IChzKSA9PiB7XG4gIC8qIGJsYWNrX21hc2sgaXMgdGhlIGJpdCBtYXNrIG9mIGJsYWNrLWxpc3RlZCBieXRlc1xuICAgKiBzZXQgYml0cyAwLi42LCAxNC4uMjUsIGFuZCAyOC4uMzFcbiAgICogMHhmM2ZmYzA3ZiA9IGJpbmFyeSAxMTExMDAxMTExMTExMTExMTEwMDAwMDAwMTExMTExMVxuICAgKi9cbiAgbGV0IGJsYWNrX21hc2sgPSAweGYzZmZjMDdmO1xuICBsZXQgbjtcblxuICAvKiBDaGVjayBmb3Igbm9uLXRleHR1YWwgKFwiYmxhY2stbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDw9IDMxOyBuKyssIGJsYWNrX21hc2sgPj4+PSAxKSB7XG4gICAgaWYgKChibGFja19tYXNrICYgMSkgJiYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkpIHtcbiAgICAgIHJldHVybiBaX0JJTkFSWTtcbiAgICB9XG4gIH1cblxuICAvKiBDaGVjayBmb3IgdGV4dHVhbCAoXCJ3aGl0ZS1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGlmIChzLmR5bl9sdHJlZVs5ICogMl0vKi5GcmVxKi8gIT09IDAgfHwgcy5keW5fbHRyZWVbMTAgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fFxuICAgICAgcy5keW5fbHRyZWVbMTMgKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgIHJldHVybiBaX1RFWFQ7XG4gIH1cbiAgZm9yIChuID0gMzI7IG4gPCBMSVRFUkFMUzsgbisrKSB7XG4gICAgaWYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcmV0dXJuIFpfVEVYVDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGVyZSBhcmUgbm8gXCJibGFjay1saXN0ZWRcIiBvciBcIndoaXRlLWxpc3RlZFwiIGJ5dGVzOlxuICAgKiB0aGlzIHN0cmVhbSBlaXRoZXIgaXMgZW1wdHkgb3IgaGFzIHRvbGVyYXRlZCAoXCJncmF5LWxpc3RlZFwiKSBieXRlcyBvbmx5LlxuICAgKi9cbiAgcmV0dXJuIFpfQklOQVJZO1xufTtcblxuXG5sZXQgc3RhdGljX2luaXRfZG9uZSA9IGZhbHNlO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHRyZWUgZGF0YSBzdHJ1Y3R1cmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbS5cbiAqL1xuY29uc3QgX3RyX2luaXQgPSAocykgPT5cbntcblxuICBpZiAoIXN0YXRpY19pbml0X2RvbmUpIHtcbiAgICB0cl9zdGF0aWNfaW5pdCgpO1xuICAgIHN0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xuICB9XG5cbiAgcy5sX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2x0cmVlLCBzdGF0aWNfbF9kZXNjKTtcbiAgcy5kX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2R0cmVlLCBzdGF0aWNfZF9kZXNjKTtcbiAgcy5ibF9kZXNjID0gbmV3IFRyZWVEZXNjKHMuYmxfdHJlZSwgc3RhdGljX2JsX2Rlc2MpO1xuXG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgZmlyc3QgYmxvY2sgb2YgdGhlIGZpcnN0IGZpbGU6ICovXG4gIGluaXRfYmxvY2socyk7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHN0b3JlZCBibG9ja1xuICovXG5jb25zdCBfdHJfc3RvcmVkX2Jsb2NrID0gKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCkgPT5cbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jayAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICBzZW5kX2JpdHMocywgKFNUT1JFRF9CTE9DSyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTsgICAgLyogc2VuZCBibG9jayB0eXBlICovXG4gIGNvcHlfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCB0cnVlKTsgLyogd2l0aCBoZWFkZXIgKi9cbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIG9uZSBlbXB0eSBzdGF0aWMgYmxvY2sgdG8gZ2l2ZSBlbm91Z2ggbG9va2FoZWFkIGZvciBpbmZsYXRlLlxuICogVGhpcyB0YWtlcyAxMCBiaXRzLCBvZiB3aGljaCA3IG1heSByZW1haW4gaW4gdGhlIGJpdCBidWZmZXIuXG4gKi9cbmNvbnN0IF90cl9hbGlnbiA9IChzKSA9PiB7XG4gIHNlbmRfYml0cyhzLCBTVEFUSUNfVFJFRVMgPDwgMSwgMyk7XG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIHN0YXRpY19sdHJlZSk7XG4gIGJpX2ZsdXNoKHMpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZyBmb3IgdGhlIGN1cnJlbnQgYmxvY2s6IGR5bmFtaWMgdHJlZXMsIHN0YXRpY1xuICogdHJlZXMgb3Igc3RvcmUsIGFuZCBvdXRwdXQgdGhlIGVuY29kZWQgYmxvY2sgdG8gdGhlIHppcCBmaWxlLlxuICovXG5jb25zdCBfdHJfZmx1c2hfYmxvY2sgPSAocywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KSA9PlxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrLCBvciBOVUxMIGlmIHRvbyBvbGQgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgbGV0IG9wdF9sZW5iLCBzdGF0aWNfbGVuYjsgIC8qIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gaW4gYnl0ZXMgKi9cbiAgbGV0IG1heF9ibGluZGV4ID0gMDsgICAgICAgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBCdWlsZCB0aGUgSHVmZm1hbiB0cmVlcyB1bmxlc3MgYSBzdG9yZWQgYmxvY2sgaXMgZm9yY2VkICovXG4gIGlmIChzLmxldmVsID4gMCkge1xuXG4gICAgLyogQ2hlY2sgaWYgdGhlIGZpbGUgaXMgYmluYXJ5IG9yIHRleHQgKi9cbiAgICBpZiAocy5zdHJtLmRhdGFfdHlwZSA9PT0gWl9VTktOT1dOKSB7XG4gICAgICBzLnN0cm0uZGF0YV90eXBlID0gZGV0ZWN0X2RhdGFfdHlwZShzKTtcbiAgICB9XG5cbiAgICAvKiBDb25zdHJ1Y3QgdGhlIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gICAgYnVpbGRfdHJlZShzLCBzLmxfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcblxuICAgIGJ1aWxkX3RyZWUocywgcy5kX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuICAgIC8qIEF0IHRoaXMgcG9pbnQsIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gYXJlIHRoZSB0b3RhbCBiaXQgbGVuZ3RocyBvZlxuICAgICAqIHRoZSBjb21wcmVzc2VkIGJsb2NrIGRhdGEsIGV4Y2x1ZGluZyB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG5cbiAgICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlIGZvciB0aGUgYWJvdmUgdHdvIHRyZWVzLCBhbmQgZ2V0IHRoZSBpbmRleFxuICAgICAqIGluIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICAgICAqL1xuICAgIG1heF9ibGluZGV4ID0gYnVpbGRfYmxfdHJlZShzKTtcblxuICAgIC8qIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZy4gQ29tcHV0ZSB0aGUgYmxvY2sgbGVuZ3RocyBpbiBieXRlcy4gKi9cbiAgICBvcHRfbGVuYiA9IChzLm9wdF9sZW4gKyAzICsgNykgPj4+IDM7XG4gICAgc3RhdGljX2xlbmIgPSAocy5zdGF0aWNfbGVuICsgMyArIDcpID4+PiAzO1xuXG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxub3B0ICVsdSglbHUpIHN0YXQgJWx1KCVsdSkgc3RvcmVkICVsdSBsaXQgJXUgXCIsXG4gICAgLy8gICAgICAgIG9wdF9sZW5iLCBzLT5vcHRfbGVuLCBzdGF0aWNfbGVuYiwgcy0+c3RhdGljX2xlbiwgc3RvcmVkX2xlbixcbiAgICAvLyAgICAgICAgcy0+bGFzdF9saXQpKTtcblxuICAgIGlmIChzdGF0aWNfbGVuYiA8PSBvcHRfbGVuYikgeyBvcHRfbGVuYiA9IHN0YXRpY19sZW5iOyB9XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBBc3NlcnQoYnVmICE9IChjaGFyKikwLCBcImxvc3QgYnVmXCIpO1xuICAgIG9wdF9sZW5iID0gc3RhdGljX2xlbmIgPSBzdG9yZWRfbGVuICsgNTsgLyogZm9yY2UgYSBzdG9yZWQgYmxvY2sgKi9cbiAgfVxuXG4gIGlmICgoc3RvcmVkX2xlbiArIDQgPD0gb3B0X2xlbmIpICYmIChidWYgIT09IC0xKSkge1xuICAgIC8qIDQ6IHR3byB3b3JkcyBmb3IgdGhlIGxlbmd0aHMgKi9cblxuICAgIC8qIFRoZSB0ZXN0IGJ1ZiAhPSBOVUxMIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIExJVF9CVUZTSVpFID4gV1NJWkUuXG4gICAgICogT3RoZXJ3aXNlIHdlIGNhbid0IGhhdmUgcHJvY2Vzc2VkIG1vcmUgdGhhbiBXU0laRSBpbnB1dCBieXRlcyBzaW5jZVxuICAgICAqIHRoZSBsYXN0IGJsb2NrIGZsdXNoLCBiZWNhdXNlIGNvbXByZXNzaW9uIHdvdWxkIGhhdmUgYmVlblxuICAgICAqIHN1Y2Nlc3NmdWwuIElmIExJVF9CVUZTSVpFIDw9IFdTSVpFLCBpdCBpcyBuZXZlciB0b28gbGF0ZSB0b1xuICAgICAqIHRyYW5zZm9ybSBhIGJsb2NrIGludG8gYSBzdG9yZWQgYmxvY2suXG4gICAgICovXG4gICAgX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpO1xuXG4gIH0gZWxzZSBpZiAocy5zdHJhdGVneSA9PT0gWl9GSVhFRCB8fCBzdGF0aWNfbGVuYiA9PT0gb3B0X2xlbmIpIHtcblxuICAgIHNlbmRfYml0cyhzLCAoU1RBVElDX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHN0YXRpY19sdHJlZSwgc3RhdGljX2R0cmVlKTtcblxuICB9IGVsc2Uge1xuICAgIHNlbmRfYml0cyhzLCAoRFlOX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIHNlbmRfYWxsX3RyZWVzKHMsIHMubF9kZXNjLm1heF9jb2RlICsgMSwgcy5kX2Rlc2MubWF4X2NvZGUgKyAxLCBtYXhfYmxpbmRleCArIDEpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHMuZHluX2x0cmVlLCBzLmR5bl9kdHJlZSk7XG4gIH1cbiAgLy8gQXNzZXJ0IChzLT5jb21wcmVzc2VkX2xlbiA9PSBzLT5iaXRzX3NlbnQsIFwiYmFkIGNvbXByZXNzZWQgc2l6ZVwiKTtcbiAgLyogVGhlIGFib3ZlIGNoZWNrIGlzIG1hZGUgbW9kIDJeMzIsIGZvciBmaWxlcyBsYXJnZXIgdGhhbiA1MTIgTUJcbiAgICogYW5kIHVMb25nIGltcGxlbWVudGVkIG9uIDMyIGJpdHMuXG4gICAqL1xuICBpbml0X2Jsb2NrKHMpO1xuXG4gIGlmIChsYXN0KSB7XG4gICAgYmlfd2luZHVwKHMpO1xuICB9XG4gIC8vIFRyYWNldigoc3RkZXJyLFwiXFxuY29tcHJsZW4gJWx1KCVsdSkgXCIsIHMtPmNvbXByZXNzZWRfbGVuPj4zLFxuICAvLyAgICAgICBzLT5jb21wcmVzc2VkX2xlbi03Kmxhc3QpKTtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2F2ZSB0aGUgbWF0Y2ggaW5mbyBhbmQgdGFsbHkgdGhlIGZyZXF1ZW5jeSBjb3VudHMuIFJldHVybiB0cnVlIGlmXG4gKiB0aGUgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQuXG4gKi9cbmNvbnN0IF90cl90YWxseSA9IChzLCBkaXN0LCBsYykgPT5cbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB1bnNpZ25lZCBkaXN0OyAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbi8vICAgIHVuc2lnbmVkIGxjOyAgICAvKiBtYXRjaCBsZW5ndGgtTUlOX01BVENIIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0PT0wKSAqL1xue1xuICAvL2xldCBvdXRfbGVuZ3RoLCBpbl9sZW5ndGgsIGRjb2RlO1xuXG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyXSAgICAgPSAoZGlzdCA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMiArIDFdID0gZGlzdCAmIDB4ZmY7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgcy5sYXN0X2xpdF0gPSBsYyAmIDB4ZmY7XG4gIHMubGFzdF9saXQrKztcblxuICBpZiAoZGlzdCA9PT0gMCkge1xuICAgIC8qIGxjIGlzIHRoZSB1bm1hdGNoZWQgY2hhciAqL1xuICAgIHMuZHluX2x0cmVlW2xjICogMl0vKi5GcmVxKi8rKztcbiAgfSBlbHNlIHtcbiAgICBzLm1hdGNoZXMrKztcbiAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgZGlzdC0tOyAgICAgICAgICAgICAvKiBkaXN0ID0gbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgLy9Bc3NlcnQoKHVzaClkaXN0IDwgKHVzaClNQVhfRElTVChzKSAmJlxuICAgIC8vICAgICAgICh1c2gpbGMgPD0gKHVzaCkoTUFYX01BVENILU1JTl9NQVRDSCkgJiZcbiAgICAvLyAgICAgICAodXNoKWRfY29kZShkaXN0KSA8ICh1c2gpRF9DT0RFUywgIFwiX3RyX3RhbGx5OiBiYWQgbWF0Y2hcIik7XG5cbiAgICBzLmR5bl9sdHJlZVsoX2xlbmd0aF9jb2RlW2xjXSArIExJVEVSQUxTICsgMSkgKiAyXS8qLkZyZXEqLysrO1xuICAgIHMuZHluX2R0cmVlW2RfY29kZShkaXN0KSAqIDJdLyouRnJlcSovKys7XG4gIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcblxuLy8jaWZkZWYgVFJVTkNBVEVfQkxPQ0tcbi8vICAvKiBUcnkgdG8gZ3Vlc3MgaWYgaXQgaXMgcHJvZml0YWJsZSB0byBzdG9wIHRoZSBjdXJyZW50IGJsb2NrIGhlcmUgKi9cbi8vICBpZiAoKHMubGFzdF9saXQgJiAweDFmZmYpID09PSAwICYmIHMubGV2ZWwgPiAyKSB7XG4vLyAgICAvKiBDb21wdXRlIGFuIHVwcGVyIGJvdW5kIGZvciB0aGUgY29tcHJlc3NlZCBsZW5ndGggKi9cbi8vICAgIG91dF9sZW5ndGggPSBzLmxhc3RfbGl0Kjg7XG4vLyAgICBpbl9sZW5ndGggPSBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydDtcbi8vXG4vLyAgICBmb3IgKGRjb2RlID0gMDsgZGNvZGUgPCBEX0NPREVTOyBkY29kZSsrKSB7XG4vLyAgICAgIG91dF9sZW5ndGggKz0gcy5keW5fZHRyZWVbZGNvZGUqMl0vKi5GcmVxKi8gKiAoNSArIGV4dHJhX2RiaXRzW2Rjb2RlXSk7XG4vLyAgICB9XG4vLyAgICBvdXRfbGVuZ3RoID4+Pj0gMztcbi8vICAgIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5sYXN0X2xpdCAldSwgaW4gJWxkLCBvdXQgfiVsZCglbGQlJSkgXCIsXG4vLyAgICAvLyAgICAgICBzLT5sYXN0X2xpdCwgaW5fbGVuZ3RoLCBvdXRfbGVuZ3RoLFxuLy8gICAgLy8gICAgICAgMTAwTCAtIG91dF9sZW5ndGgqMTAwTC9pbl9sZW5ndGgpKTtcbi8vICAgIGlmIChzLm1hdGNoZXMgPCAocy5sYXN0X2xpdD4+MSkvKmludCAvMiovICYmIG91dF9sZW5ndGggPCAoaW5fbGVuZ3RoPj4xKS8qaW50IC8yKi8pIHtcbi8vICAgICAgcmV0dXJuIHRydWU7XG4vLyAgICB9XG4vLyAgfVxuLy8jZW5kaWZcblxuICByZXR1cm4gKHMubGFzdF9saXQgPT09IHMubGl0X2J1ZnNpemUgLSAxKTtcbiAgLyogV2UgYXZvaWQgZXF1YWxpdHkgd2l0aCBsaXRfYnVmc2l6ZSBiZWNhdXNlIG9mIHdyYXBhcm91bmQgYXQgNjRLXG4gICAqIG9uIDE2IGJpdCBtYWNoaW5lcyBhbmQgYmVjYXVzZSBzdG9yZWQgYmxvY2tzIGFyZSByZXN0cmljdGVkIHRvXG4gICAqIDY0Sy0xIGJ5dGVzLlxuICAgKi9cbn07XG5cbm1vZHVsZS5leHBvcnRzLl90cl9pbml0ICA9IF90cl9pbml0O1xubW9kdWxlLmV4cG9ydHMuX3RyX3N0b3JlZF9ibG9jayA9IF90cl9zdG9yZWRfYmxvY2s7XG5tb2R1bGUuZXhwb3J0cy5fdHJfZmx1c2hfYmxvY2sgID0gX3RyX2ZsdXNoX2Jsb2NrO1xubW9kdWxlLmV4cG9ydHMuX3RyX3RhbGx5ID0gX3RyX3RhbGx5O1xubW9kdWxlLmV4cG9ydHMuX3RyX2FsaWduID0gX3RyX2FsaWduO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIFpTdHJlYW0oKSB7XG4gIC8qIG5leHQgaW5wdXQgYnl0ZSAqL1xuICB0aGlzLmlucHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfaW4gPSAwO1xuICAvKiBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlIGF0IGlucHV0ICovXG4gIHRoaXMuYXZhaWxfaW4gPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgaW5wdXQgYnl0ZXMgcmVhZCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9pbiA9IDA7XG4gIC8qIG5leHQgb3V0cHV0IGJ5dGUgc2hvdWxkIGJlIHB1dCB0aGVyZSAqL1xuICB0aGlzLm91dHB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X291dCA9IDA7XG4gIC8qIHJlbWFpbmluZyBmcmVlIHNwYWNlIGF0IG91dHB1dCAqL1xuICB0aGlzLmF2YWlsX291dCA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBieXRlcyBvdXRwdXQgc28gZmFyICovXG4gIHRoaXMudG90YWxfb3V0ID0gMDtcbiAgLyogbGFzdCBlcnJvciBtZXNzYWdlLCBOVUxMIGlmIG5vIGVycm9yICovXG4gIHRoaXMubXNnID0gJycvKlpfTlVMTCovO1xuICAvKiBub3QgdmlzaWJsZSBieSBhcHBsaWNhdGlvbnMgKi9cbiAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gIC8qIGJlc3QgZ3Vlc3MgYWJvdXQgdGhlIGRhdGEgdHlwZTogYmluYXJ5IG9yIHRleHQgKi9cbiAgdGhpcy5kYXRhX3R5cGUgPSAyLypaX1VOS05PV04qLztcbiAgLyogYWRsZXIzMiB2YWx1ZSBvZiB0aGUgdW5jb21wcmVzc2VkIGRhdGEgKi9cbiAgdGhpcy5hZGxlciA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWlN0cmVhbTtcbiIsIi8qKlxyXG4gKiBUaGlzIE1vZHVsZSBjb250YWlucyBjbGFzc2VzIHJlbGV2YW50IHRvIGRhdGEgYWJvdXQgYSB1c2VyIGluIHRoZSB2aXJ0dWFsIDNEIGVudmlyb25tZW50LlxyXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cclxuICovXHJcblxyXG5pbXBvcnQgeyByZWN1cnNpdmVseURpZmZPYmplY3RzIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9IaUZpVXRpbGl0aWVzXCI7XHJcblxyXG4vKipcclxuICogSW5zdGFudGlhdGlvbnMgb2YgdGhpcyBjbGFzcyBkZWZpbmUgYSBwb3NpdGlvbiBpbiAzRCBzcGFjZS4gVGhlIHBvc2l0aW9uIG9mIGEgdXNlciBhZmZlY3RzIHRoZSB3YXkgdGhlIG1peGVkIHNwYXRpYWxcclxuICogYXVkaW8gaXMgaGVhcmQgYnkgdGhlIHVzZXIuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUG9pbnQzRCB7XHJcbiAgICAvKipcclxuICAgICAqIEJ5IGRlZmF1bHQsICt4IGlzIHRvIHRoZSByaWdodCBhbmQgLXggaXMgdG8gdGhlIGxlZnQuIFVuaXRzIGZvciB0aGlzIG1lbWJlciB2YXJpYWJsZSBhcmUgKiptZXRlcnMqKi5cclxuICAgICAqL1xyXG4gICAgeDogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBCeSBkZWZhdWx0LCAreSBpcyBpbnRvIHRoZSBzY3JlZW4gYW5kIC15IGlzIG91dCBvZiB0aGUgc2NyZWVuIHRvd2FyZHMgdGhlIHVzZXIuIFVuaXRzIGZvciB0aGlzIG1lbWJlciB2YXJpYWJsZSBhcmUgKiptZXRlcnMqKi5cclxuICAgICAqL1xyXG4gICAgeTogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBCeSBkZWZhdWx0LCAreiBpcyB1cCBhbmQgLXogaXMgZG93bi4gVW5pdHMgZm9yIHRoaXMgbWVtYmVyIHZhcmlhYmxlIGFyZSAqKm1ldGVycyoqLlxyXG4gICAgICovXHJcbiAgICB6OiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgYFBvaW50M0RgIG9iamVjdC4gQWxsIHBhcmFtZXRlcnMgYXJlIG9wdGlvbmFsLiBVbnNldCBwYXJhbWV0ZXJzIHdpbGwgYmUgc2V0IHRvIGBudWxsYC4gUmVtZW1iZXIsIGFsbCB1bml0cyBmb3IgbWVtYmVyIHZhcmlhYmxlcyBhcmUgYG1ldGVyc2AuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHsgeCA9IG51bGwsIHkgPSBudWxsLCB6ID0gbnVsbCB9OiB7IHg/OiBudW1iZXIsIHk/OiBudW1iZXIsIHo/OiBudW1iZXIgfSA9IHt9KSB7XHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIHRoaXMueiA9IHo7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbnN0YW50aWF0aW9ucyBvZiB0aGlzIGNsYXNzIGRlZmluZSBhbiBvcmllbnRhdGlvbiBpbiAzRCBzcGFjZS4gQSB1c2VyJ3Mgb3JpZW50YXRpb24gaW4gM0Qgc3BhY2VcclxuICogYWZmZWN0cyB0aGUgd2F5IHRoZSBtaXhlZCBzcGF0aWFsIGF1ZGlvIGlzIGhlYXJkIGJ5IHRoZSB1c2VyLiBBZGRpdGlvbmFsbHksIG9yaWVudGF0aW9uIGFmZmVjdHMgdGhlIHdheVxyXG4gKiBhIHVzZXIncyBhdWRpbyBpbnB1dCBwcm9wYWdhdGVzIHRocm91Z2ggYSBzcGFjZTogc3BlYWtlcnMgZmFjaW5nIGRpcmVjdGx5IHRvd2FyZHMgYSBsaXN0ZW5lciB3aWxsIHNvdW5kIGxvdWRlciB0aGFuXHJcbiAqIHNwZWFrZXJzIGZhY2luZyBhd2F5IGZyb20gYSBsaXN0ZW5lci4gQnkgZGVmYXVsdCwgdGhlIGF4aXMgY29uZmlndXJhdGlvbiBpcyBzZXQgdXAgdG8gYmUgcmlnaHQtaGFuZGVkLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE9yaWVudGF0aW9uRXVsZXIzRCB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnNpZGVyIGFuIGFpcmNyYWZ0OiBcIlBpdGNoXCIgaXMgZGVmaW5lZCBhcyBcIm5vc2UgdXAvZG93biBhYm91dCB0aGUgYXhpcyBydW5uaW5nIGZyb20gd2luZyB0byB3aW5nXCIuXHJcbiAgICAgKiAqKk5lZ2F0aXZlIHBpdGNoKiogbWVhbnMgdGhhdCB0aGUgYWlyY3JhZnQgbW92ZXMgaXRzIG5vc2UgKipjbG9zZXIgdG8gdGhlIGdyb3VuZCoqLlxyXG4gICAgICogKipQb3NpdGl2ZSBwaXRjaCoqIG1lYW5zIHRoYXQgdGhlIGFpcmNyYWZ0IG1vdmVzIGl0cyBub3NlICoqYXdheSBmcm9tIHRoZSBncm91bmQqKi5cclxuICAgICAqIFVuaXRzIGhlcmUgYXJlIGRlZ3JlZXMuXHJcbiAgICAgKi9cclxuICAgIHBpdGNoRGVncmVlczogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zaWRlciBhbiBhaXJjcmFmdDogXCJZYXdcIiBpcyBkZWZpbmVkIGFzIFwibm9zZSBsZWZ0L3JpZ2h0IGFib3V0IHRoZSBheGlzIHJ1bm5pbmcgdXAgYW5kIGRvd25cIi5cclxuICAgICAqICoqTmVnYXRpdmUgeWF3KiogbWVhbnMgdGhhdCB0aGUgYWlyY3JhZnQgd2lsbCByb3RhdGUgKipjbG9ja3dpc2UqKiB3aGVuIHZpZXdpbmcgdGhlIGFpcmNyYWZ0IGZyb20gYWJvdmUuXHJcbiAgICAgKiAqKlBvc2l0aXZlIHlhdyoqIG1lYW5zIHRoYXQgdGhlIGFpcmNyYWZ0IHdpbGwgcm90YXRlICoqY291bnRlci1jbG9ja3dpc2UqKiB3aGVuIHZpZXdpbmcgdGhlIGFpcmNyYWZ0IGZyb20gYWJvdmUuXHJcbiAgICAgKiBVbml0cyBoZXJlIGFyZSBkZWdyZWVzLlxyXG4gICAgICovXHJcbiAgICB5YXdEZWdyZWVzOiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIENvbnNpZGVyIGFuIGFpcmNyYWZ0OiBcIlJvbGxcIiBpcyBkZWZpbmVkIGFzIFwicm90YXRpb24gYWJvdXQgdGhlIGF4aXMgcnVubmluZyBmcm9tIG5vc2UgdG8gdGFpbFwiLlxyXG4gICAgICogKipQb3NpdGl2ZSByb2xsKiogbWVhbnMgdGhhdCB0aGUgYWlyY3JhZnQncyAqKnJpZ2h0IHdpbmcgd2lsbCBtb3ZlIGNsb3NlciB0byB0aGUgZ3JvdW5kKiouXHJcbiAgICAgKiAqKk5lZ2F0aXZlIHJvbGwqKiBtZWFucyB0aGF0IHRoZSBhaXJjcmFmdCdzICoqbGVmdCB3aW5nIHdpbGwgbW92ZSBjbG9zZXIgdG8gdGhlIGdyb3VuZCoqLlxyXG4gICAgICogVW5pdHMgaGVyZSBhcmUgZGVncmVlcy5cclxuICAgICAqL1xyXG4gICAgcm9sbERlZ3JlZXM6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBgT3JpZW50YXRpb25FdWxlcjNEYCBvYmplY3QuIEFsbCBwYXJhbWV0ZXJzIGFyZSBvcHRpb25hbC4gVW5zZXQgcGFyYW1ldGVycyB3aWxsIGJlIHNldCB0byBgMGAuIFJlbWVtYmVyLCBhbGwgdW5pdHMgZm9yIG1lbWJlciB2YXJpYWJsZXMgYXJlIGBkZWdyZWVzYC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoeyBwaXRjaERlZ3JlZXMgPSAwLCB5YXdEZWdyZWVzID0gMCwgcm9sbERlZ3JlZXMgPSAwIH06IHsgcGl0Y2hEZWdyZWVzPzogbnVtYmVyLCB5YXdEZWdyZWVzPzogbnVtYmVyLCByb2xsRGVncmVlcz86IG51bWJlciB9ID0ge30pIHtcclxuICAgICAgICB0aGlzLnBpdGNoRGVncmVlcyA9IHBpdGNoRGVncmVlcztcclxuICAgICAgICB0aGlzLnlhd0RlZ3JlZXMgPSB5YXdEZWdyZWVzO1xyXG4gICAgICAgIHRoaXMucm9sbERlZ3JlZXMgPSByb2xsRGVncmVlcztcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEluc3RhbnRpYXRpb25zIG9mIHRoaXMgY2xhc3MgZGVmaW5lIGFuIG9yaWVudGF0aW9uIGluIDNEIHNwYWNlIGluIFF1YXRlcm5pb24gZm9ybWF0LiBBIHVzZXIncyBvcmllbnRhdGlvbiBpbiAzRCBzcGFjZVxyXG4gKiBhZmZlY3RzIHRoZSB3YXkgdGhlIG1peGVkIHNwYXRpYWwgYXVkaW8gaXMgaGVhcmQgYnkgdGhlIHVzZXIuIEFkZGl0aW9uYWxseSwgb3JpZW50YXRpb24gYWZmZWN0cyB0aGUgd2F5XHJcbiAqIGEgdXNlcidzIGF1ZGlvIGlucHV0IHByb3BhZ2F0ZXMgdGhyb3VnaCBhIHNwYWNlOiBzcGVha2VycyBmYWNpbmcgZGlyZWN0bHkgdG93YXJkcyBhIGxpc3RlbmVyIHdpbGwgc291bmQgbG91ZGVyIHRoYW5cclxuICogc3BlYWtlcnMgZmFjaW5nIGF3YXkgZnJvbSBhIGxpc3RlbmVyLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE9yaWVudGF0aW9uUXVhdDNEIHtcclxuICAgIHc6IG51bWJlcjtcclxuICAgIHg6IG51bWJlcjtcclxuICAgIHk6IG51bWJlcjtcclxuICAgIHo6IG51bWJlclxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGBPcmllbnRhdGlvblF1YXQzRGAgb2JqZWN0LiBBbGwgcGFyYW1ldGVycyBhcmUgcmVxdWlyZWQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHsgdyA9IDEsIHggPSAwLCB5ID0gMCwgeiA9IDAgfTogeyB3PzogbnVtYmVyLCB4PzogbnVtYmVyLCB5PzogbnVtYmVyLCB6PzogbnVtYmVyIH0gPSB7fSkge1xyXG4gICAgICAgIHRoaXMudyA9IHc7XHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIHRoaXMueiA9IHo7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbnN0YW50aWF0aW9ucyBvZiB0aGlzIGNsYXNzIGNvbnRhaW4gYWxsIG9mIHRoZSBkYXRhIHRoYXQgaXMgcG9zc2libGUgdG8gKipzZW5kIHRvIEFORCByZWNlaXZlIGZyb20qKiB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBBUEkgU2VydmVyLlxyXG4gKiBBbGwgbWVtYmVyIGRhdGEgaW5zaWRlIHRoaXMgYGNsYXNzYCBjYW4gYmUgc2VudCB0byB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBBUEkgU2VydmVyLiBTZWUgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cclxuICogXHJcbiAqIFNlZSB7QGxpbmsgUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhfSBmb3IgZGF0YSB0aGF0IGNhbid0IGJlIHNlbnQgdG8gdGhlIFNlcnZlciwgYnV0IHJhdGhlciBjYW4gb25seSBiZSByZWNlaXZlZCBmcm9tIHRoZSBTZXJ2ZXIgKGkuZS4gYHZvbHVtZURlY2liZWxzYCkuXHJcbiAqIFxyXG4gKiBNZW1iZXIgZGF0YSBvZiB0aGlzIGNsYXNzIHRoYXQgaXMgc2VudCB0byB0aGUgU2VydmVyIHdpbGwgYWZmZWN0IHRoZSBmaW5hbCBtaXhlZCBzcGF0aWFsIGF1ZGlvIGZvciBhbGwgbGlzdGVuZXJzIGluIHRoZSBzZXJ2ZXIncyB2aXJ0dWFsIHNwYWNlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEhpRmlBdWRpb0FQSURhdGEge1xyXG4gICAgcG9zaXRpb246IFBvaW50M0Q7XHJcbiAgICBvcmllbnRhdGlvbkV1bGVyOiBPcmllbnRhdGlvbkV1bGVyM0Q7XHJcbiAgICBvcmllbnRhdGlvblF1YXQ6IE9yaWVudGF0aW9uUXVhdDNEO1xyXG4gICAgaGlGaUdhaW46IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIF9fbmFtZWRQYXJhbWV0ZXJzXHJcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gSWYgeW91IGRvbid0IHN1cHBseSBhIGBwb3NpdGlvbmAgd2hlbiBjb25zdHJ1Y3RpbmcgaW5zdGFudGlhdGlvbnMgb2YgdGhpcyBjbGFzcywgYHBvc2l0aW9uYCB3aWxsIGJlIGBudWxsYC5cclxuICAgICAqIFxyXG4gICAgICog4pyUIFRoZSBjbGllbnQgc2VuZHMgYHBvc2l0aW9uYCBkYXRhIHRvIHRoZSBzZXJ2ZXIgd2hlbiBgX3RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YVRvU2VydmVyKClgIGlzIGNhbGxlZC5cclxuICAgICAqIFxyXG4gICAgICog4pyUIFRoZSBzZXJ2ZXIgc2VuZHMgYHBvc2l0aW9uYCBkYXRhIHRvIGFsbCBjbGllbnRzIGNvbm5lY3RlZCB0byBhIHNlcnZlciBkdXJpbmcgXCJwZWVyIHVwZGF0ZXNcIi5cclxuICAgICAqIEBwYXJhbSBvcmllbnRhdGlvbkV1bGVyIElmIHlvdSBkb24ndCBzdXBwbHkgYW4gYG9yaWVudGF0aW9uRXVsZXJgIHdoZW4gY29uc3RydWN0aW5nIGluc3RhbnRpYXRpb25zIG9mIHRoaXMgY2xhc3MsIGBvcmllbnRhdGlvbkV1bGVyYCB3aWxsIGJlIGBudWxsYC5cclxuICAgICAqIFxyXG4gICAgICog4pyUIFRoZSBjbGllbnQgc2VuZHMgYG9yaWVudGF0aW9uRXVsZXJgIGRhdGEgdG8gdGhlIHNlcnZlciB3aGVuIGBfdHJhbnNtaXRIaUZpQXVkaW9BUElEYXRhVG9TZXJ2ZXIoKWAgaXMgY2FsbGVkLlxyXG4gICAgICogXHJcbiAgICAgKiDinJQgVGhlIHNlcnZlciBzZW5kcyBgb3JpZW50YXRpb25FdWxlcmAgZGF0YSB0byBhbGwgY2xpZW50cyBjb25uZWN0ZWQgdG8gYSBzZXJ2ZXIgZHVyaW5nIFwicGVlciB1cGRhdGVzXCIuXHJcbiAgICAgKiBAcGFyYW0gb3JpZW50YXRpb25RdWF0IElmIHlvdSBkb24ndCBzdXBwbHkgYW4gYG9yaWVudGF0aW9uUXVhdGAgd2hlbiBjb25zdHJ1Y3RpbmcgaW5zdGFudGlhdGlvbnMgb2YgdGhpcyBjbGFzcywgYG9yaWVudGF0aW9uUXVhdGAgd2lsbCBiZSBgbnVsbGAuXHJcbiAgICAgKiBcclxuICAgICAqIOKclCBUaGUgY2xpZW50IHNlbmRzIGBvcmllbnRhdGlvblF1YXRgIGRhdGEgdG8gdGhlIHNlcnZlciB3aGVuIGBfdHJhbnNtaXRIaUZpQXVkaW9BUElEYXRhVG9TZXJ2ZXIoKWAgaXMgY2FsbGVkLlxyXG4gICAgICogXHJcbiAgICAgKiDinJQgVGhlIHNlcnZlciBzZW5kcyBgb3JpZW50YXRpb25RdWF0YCBkYXRhIHRvIGFsbCBjbGllbnRzIGNvbm5lY3RlZCB0byBhIHNlcnZlciBkdXJpbmcgXCJwZWVyIHVwZGF0ZXNcIi5cclxuICAgICAqIEBwYXJhbSBoaUZpR2FpbiBUaGlzIHZhbHVlIGFmZmVjdHMgaG93IGxvdWQgVXNlciBBIHdpbGwgc291bmQgdG8gVXNlciBCIGF0IGEgZ2l2ZW4gZGlzdGFuY2UgaW4gM0Qgc3BhY2UuXHJcbiAgICAgKiBUaGlzIHZhbHVlIGFsc28gYWZmZWN0cyB0aGUgZGlzdGFuY2UgYXQgd2hpY2ggVXNlciBBIGNhbiBiZSBoZWFyZCBpbiAzRCBzcGFjZS5cclxuICAgICAqIEhpZ2hlciB2YWx1ZXMgZm9yIFVzZXIgQSBtZWFucyB0aGF0IFVzZXIgQSB3aWxsIHNvdW5kIGxvdWRlciB0byBvdGhlciB1c2VycyBhcm91bmQgVXNlciBBLCBhbmQgaXQgYWxzbyBtZWFucyB0aGF0IFVzZXIgQSB3aWxsIGJlIGF1ZGlibGUgZnJvbSBhIGdyZWF0ZXIgZGlzdGFuY2UuXHJcbiAgICAgKiBJZiB5b3UgZG9uJ3Qgc3VwcGx5IGFuIGBoaUZpR2FpbmAgd2hlbiBjb25zdHJ1Y3RpbmcgaW5zdGFudGlhdGlvbnMgb2YgdGhpcyBjbGFzcywgYGhpRmlHYWluYCB3aWxsIGJlIGBudWxsYC5cclxuICAgICAqIFxyXG4gICAgICog4pyUIFRoZSBjbGllbnQgc2VuZHMgYGhpRmlHYWluYCBkYXRhIHRvIHRoZSBzZXJ2ZXIgd2hlbiBgX3RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YVRvU2VydmVyKClgIGlzIGNhbGxlZC5cclxuICAgICAqIFxyXG4gICAgICog4pyUIFRoZSBzZXJ2ZXIgc2VuZHMgYGhpRmlHYWluYCBkYXRhIHRvIGFsbCBjbGllbnRzIGNvbm5lY3RlZCB0byBhIHNlcnZlciBkdXJpbmcgXCJwZWVyIHVwZGF0ZXNcIi5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoeyBwb3NpdGlvbiA9IG51bGwsIG9yaWVudGF0aW9uRXVsZXIgPSBudWxsLCBvcmllbnRhdGlvblF1YXQgPSBudWxsLCBoaUZpR2FpbiA9IG51bGwgfTogeyBwb3NpdGlvbj86IFBvaW50M0QsIG9yaWVudGF0aW9uRXVsZXI/OiBPcmllbnRhdGlvbkV1bGVyM0QsIG9yaWVudGF0aW9uUXVhdD86IE9yaWVudGF0aW9uUXVhdDNELCBoaUZpR2Fpbj86IG51bWJlciB9ID0ge30pIHtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICAgICAgdGhpcy5vcmllbnRhdGlvblF1YXQgPSBvcmllbnRhdGlvblF1YXQ7XHJcbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbkV1bGVyID0gb3JpZW50YXRpb25FdWxlcjtcclxuICAgICAgICB0aGlzLmhpRmlHYWluID0gaGlGaUdhaW47XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIGludGVybmFsbHkgZm9yIGdldHRpbmcgdGhlIG1pbmltYWwgc2V0IG9mIGRhdGEgdG8gdHJhbnNtaXQgdG8gdGhlIHNlcnZlci5cclxuICAgICAqIEBwYXJhbSBvdGhlckhpRmlEYXRhIFRoZSBcIm90aGVyXCIgQXVkaW8gQVBJIERhdGEgYWdhaW5zdCB3aGljaCB3ZSB3YW50IHRvIGNvbXBhcmUuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGlzIEF1ZGlvIEFQSSBEYXRhIGFuZCB0aGUgXCJvdGhlclwiIEF1ZGlvIEFQSSBEYXRhIGluIGBIaUZpQXVkaW9BUElEYXRhYCBmb3JtYXQuIFxyXG4gICAgICovXHJcbiAgICBkaWZmKG90aGVySGlGaURhdGE6IEhpRmlBdWRpb0FQSURhdGEpOiBIaUZpQXVkaW9BUElEYXRhIHtcclxuICAgICAgICBsZXQgY3VycmVudEhpRmlBdWRpb0FQSURhdGFPYmo6IGFueSA9IHtcclxuICAgICAgICAgICAgXCJwb3NpdGlvblwiOiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnBvc2l0aW9uKSxcclxuICAgICAgICAgICAgXCJvcmllbnRhdGlvbkV1bGVyXCI6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3JpZW50YXRpb25FdWxlciksXHJcbiAgICAgICAgICAgIFwib3JpZW50YXRpb25RdWF0XCI6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3JpZW50YXRpb25RdWF0KSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0eXBlb2YgKHRoaXMuaGlGaUdhaW4pID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRIaUZpQXVkaW9BUElEYXRhT2JqW1wiaGlGaUdhaW5cIl0gPSB0aGlzLmhpRmlHYWluO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IG90aGVySGlGaURhdGFPYmo6IGFueSA9IHtcclxuICAgICAgICAgICAgXCJwb3NpdGlvblwiOiBPYmplY3QuYXNzaWduKHt9LCBvdGhlckhpRmlEYXRhLnBvc2l0aW9uKSxcclxuICAgICAgICAgICAgXCJvcmllbnRhdGlvbkV1bGVyXCI6IE9iamVjdC5hc3NpZ24oe30sIG90aGVySGlGaURhdGEub3JpZW50YXRpb25FdWxlciksXHJcbiAgICAgICAgICAgIFwib3JpZW50YXRpb25RdWF0XCI6IE9iamVjdC5hc3NpZ24oe30sIG90aGVySGlGaURhdGEub3JpZW50YXRpb25RdWF0KSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0eXBlb2YgKG90aGVySGlGaURhdGEuaGlGaUdhaW4pID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIG90aGVySGlGaURhdGFPYmpbXCJoaUZpR2FpblwiXSA9IG90aGVySGlGaURhdGEuaGlGaUdhaW47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZGlmZk9iamVjdCA9IHJlY3Vyc2l2ZWx5RGlmZk9iamVjdHMoY3VycmVudEhpRmlBdWRpb0FQSURhdGFPYmosIG90aGVySGlGaURhdGFPYmopO1xyXG5cclxuICAgICAgICBsZXQgcmV0dXJuVmFsdWUgPSBuZXcgSGlGaUF1ZGlvQVBJRGF0YSgpO1xyXG5cclxuICAgICAgICBpZiAoZGlmZk9iamVjdC5wb3NpdGlvbiAmJiAodHlwZW9mIChkaWZmT2JqZWN0LnBvc2l0aW9uLngpID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiAoZGlmZk9iamVjdC5wb3NpdGlvbi55KSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgKGRpZmZPYmplY3QucG9zaXRpb24ueikgPT09IFwibnVtYmVyXCIpKSB7XHJcbiAgICAgICAgICAgIC8vIHJldHVyblZhbHVlLnBvc2l0aW9uID0gbmV3IFBvaW50M0QoZGlmZk9iamVjdC5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gcGFzcyB0aGUgZnVsbCBwb3NpdGlvbiBkYXRhIHVudGlsIHRoZSBtaXhlciBjYW4gaGFuZGxlIGZyYWdtZW50ZWQgY29vcmRpbmF0ZXMgXHJcbiAgICAgICAgICAgIHJldHVyblZhbHVlLnBvc2l0aW9uID0gbmV3IFBvaW50M0Qob3RoZXJIaUZpRGF0YS5wb3NpdGlvbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGlmZk9iamVjdC5vcmllbnRhdGlvbkV1bGVyICYmICh0eXBlb2YgKGRpZmZPYmplY3Qub3JpZW50YXRpb25FdWxlci5waXRjaERlZ3JlZXMpID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiAoZGlmZk9iamVjdC5vcmllbnRhdGlvbkV1bGVyLnlhd0RlZ3JlZXMpID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiAoZGlmZk9iamVjdC5vcmllbnRhdGlvbkV1bGVyLnJvbGxEZWdyZWVzKSA9PT0gXCJudW1iZXJcIikpIHtcclxuICAgICAgICAgICAgcmV0dXJuVmFsdWUub3JpZW50YXRpb25FdWxlciA9IG5ldyBPcmllbnRhdGlvbkV1bGVyM0QoZGlmZk9iamVjdC5vcmllbnRhdGlvbkV1bGVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkaWZmT2JqZWN0Lm9yaWVudGF0aW9uUXVhdCAmJiAodHlwZW9mIChkaWZmT2JqZWN0Lm9yaWVudGF0aW9uUXVhdC53KSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgKGRpZmZPYmplY3Qub3JpZW50YXRpb25RdWF0LngpID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiAoZGlmZk9iamVjdC5vcmllbnRhdGlvblF1YXQueSkgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIChkaWZmT2JqZWN0Lm9yaWVudGF0aW9uUXVhdC56KSA9PT0gXCJudW1iZXJcIikpIHtcclxuICAgICAgICAgICAgcmV0dXJuVmFsdWUub3JpZW50YXRpb25RdWF0ID0gbmV3IE9yaWVudGF0aW9uUXVhdDNEKGRpZmZPYmplY3Qub3JpZW50YXRpb25RdWF0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgKGRpZmZPYmplY3QuaGlGaUdhaW4pID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIHJldHVyblZhbHVlLmhpRmlHYWluID0gZGlmZk9iamVjdC5oaUZpR2FpbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEluc3RhbnRpYXRpb25zIG9mIHRoaXMgY2xhc3MgY29udGFpbiBhbGwgb2YgdGhlIGRhdGEgdGhhdCBpcyBwb3NzaWJsZSB0byAqKnJlY2VpdmUgZnJvbSoqIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIEFQSSBTZXJ2ZXIuXHJcbiAqIFNlZSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKiBcclxuICogU2VlIHtAbGluayBIaUZpQXVkaW9BUElEYXRhfSBmb3IgZGF0YSB0aGF0IGNhbiBib3RoIGJlIHNlbnQgdG8gYW5kIHJlY2VpdmVkIGZyb20gdGhlIFNlcnZlciAoaS5lLiBgcG9zaXRpb25gKS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGEgZXh0ZW5kcyBIaUZpQXVkaW9BUElEYXRhIHtcclxuICAgIHByb3ZpZGVkVXNlcklEOiBzdHJpbmc7XHJcbiAgICBoYXNoZWRWaXNpdElEOiBzdHJpbmc7XHJcbiAgICB2b2x1bWVEZWNpYmVsczogbnVtYmVyO1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHBhcmFtcyBcclxuICAgICAqIEBwYXJhbSBwYXJhbXMucHJvdmlkZWRVc2VySUQgVGhpcyBVc2VyIElEIGlzIGFuIGFyYml0cmFyeSBzdHJpbmcgcHJvdmlkZWQgYnkgYW4gYXBwbGljYXRpb24gZGV2ZWxvcGVyIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5IHRoZSB1c2VyIGFzc29jaWF0ZWQgd2l0aCBhIGNsaWVudC5cclxuICAgICAqIFdlIHJlY29tbWVuZCB0aGF0IHRoaXMgYHByb3ZpZGVkVXNlcklEYCBpcyB1bmlxdWUgYWNyb3NzIGFsbCB1c2VycywgYnV0IHRoZSBIaWdoIEZpZGVsaXR5IEFQSSB3aWxsIG5vdCBlbmZvcmNlIHVuaXF1ZW5lc3MgYWNyb3NzIGNsaWVudHMgZm9yIHRoaXMgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1zLmhhc2hlZFZpc2l0SUQgVGhpcyBzdHJpbmcgaXMgYSBoYXNoZWQgdmVyc2lvbiBvZiB0aGUgcmFuZG9tIFVVSUQgdGhhdCBpcyBnZW5lcmF0ZWQgYXV0b21hdGljYWxseS5cclxuICAgICAqIEEgY29ubmVjdGluZyBjbGllbnQgc2VuZHMgdGhpcyB2YWx1ZSBhcyB0aGUgYHNlc3Npb25gIGtleSBpbnNpZGUgdGhlIGFyZ3VtZW50IHRvIHRoZSBgYXVkaW9uZXQuaW5pdGAgY29tbWFuZC5cclxuICAgICAqIEl0IGlzIHVzZWQgdG8gaWRlbnRpZnkgYSBnaXZlbiBjbGllbnQgYWNyb3NzIGEgY2xvdWQgb2YgbWl4ZXJzIGFuZCBpcyBndWFyYW50ZWVkIChcImd1YXJhbnRlZWRcIiBnaXZlbiB0aGUgY29udGV4dCBvZiByYW5kb20gVVVJRFMpIHRvIGJlIHVuaXF1ZS5cclxuICAgICAqIEFwcGxpY2F0aW9uIGRldmVsb3BlcnMgc2hvdWxkIG5vdCBuZWVkIHRvIGludGVyYWN0IHdpdGggb3IgbWFrZSB1c2Ugb2YgdGhpcyB2YWx1ZSwgdW5sZXNzIHRoZXkgd2FudCB0byB1c2UgaXQgaW50ZXJuYWxseSBmb3IgdHJhY2tpbmcgb3Igb3RoZXIgcHVycG9zZXMuXHJcbiAgICAgKiBUaGlzIHZhbHVlIGNhbm5vdCBiZSBzZXQgYnkgdGhlIGFwcGxpY2F0aW9uIGRldmVsb3Blci5cclxuICAgICAqIEBwYXJhbSBwYXJhbXMudm9sdW1lRGVjaWJlbHMgVGhlIGN1cnJlbnQgdm9sdW1lIG9mIHRoZSB1c2VyIGluIGRlY2liZWxzLlxyXG4gICAgICog4p2MIFRoZSBjbGllbnQgbmV2ZXIgc2VuZHMgYHZvbHVtZURlY2liZWxzYCBkYXRhIHRvIHRoZSBzZXJ2ZXIuXHJcbiAgICAgKiDinJQgVGhlIHNlcnZlciBzZW5kcyBgdm9sdW1lRGVjaWJlbHNgIGRhdGEgdG8gYWxsIGNsaWVudHMgY29ubmVjdGVkIHRvIGEgc2VydmVyIGR1cmluZyBcInBlZXIgdXBkYXRlc1wiLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXM6IHsgcHJvdmlkZWRVc2VySUQ/OiBzdHJpbmcsIGhhc2hlZFZpc2l0SUQ/OiBzdHJpbmcsIHZvbHVtZURlY2liZWxzPzogbnVtYmVyLCBwb3NpdGlvbj86IFBvaW50M0QsIG9yaWVudGF0aW9uRXVsZXI/OiBPcmllbnRhdGlvbkV1bGVyM0QsIG9yaWVudGF0aW9uUXVhdD86IE9yaWVudGF0aW9uUXVhdDNELCBoaUZpR2Fpbj86IG51bWJlciB9ID0ge30pIHtcclxuICAgICAgICBzdXBlcihwYXJhbXMpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZWRVc2VySUQgPSBwYXJhbXMucHJvdmlkZWRVc2VySUQ7XHJcbiAgICAgICAgdGhpcy5oYXNoZWRWaXNpdElEID0gcGFyYW1zLmhhc2hlZFZpc2l0SUQ7XHJcbiAgICAgICAgdGhpcy52b2x1bWVEZWNpYmVscyA9IHBhcmFtcy52b2x1bWVEZWNpYmVscztcclxuICAgIH1cclxufSIsIi8qKlxyXG4gKiBUaGlzIG1vZHVsZSBwZXJ0YWlucyB0byAzRCBBeGlzIGNvbmZpZ3VhdGlvbi4gTW9kaWZ5IHlvdXIgM0QgYXhpcyBjb25maWd1cmF0aW9uIHdoZW4gY29uc3RydWN0aW5nIGEgbmV3IFtbSGlGaUNvbW11bmljYXRvcl1dIG9iamVjdC5cclxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgSGlGaUxvZ2dlciB9IGZyb20gXCIuLi91dGlsaXRpZXMvSGlGaUxvZ2dlclwiO1xyXG5pbXBvcnQgeyBPcmllbnRhdGlvbkV1bGVyM0QsIFBvaW50M0QgfSBmcm9tIFwiLi9IaUZpQXVkaW9BUElEYXRhXCI7XHJcblxyXG5leHBvcnQgZW51bSBIaUZpQXhlcyB7XHJcbiAgICBQb3NpdGl2ZVggPSBcIlBvc2l0aXZlIFhcIixcclxuICAgIE5lZ2F0aXZlWCA9IFwiTmVnYXRpdmUgWFwiLFxyXG4gICAgUG9zaXRpdmVZID0gXCJQb3NpdGl2ZSBZXCIsXHJcbiAgICBOZWdhdGl2ZVkgPSBcIk5lZ2F0aXZlIFlcIixcclxuICAgIFBvc2l0aXZlWiA9IFwiUG9zaXRpdmUgWlwiLFxyXG4gICAgTmVnYXRpdmVaID0gXCJOZWdhdGl2ZSBaXCJcclxufVxyXG5cclxuZXhwb3J0IGVudW0gSGlGaUhhbmRlZG5lc3Mge1xyXG4gICAgUmlnaHRIYW5kID0gXCJSaWdodCBIYW5kXCIsXHJcbiAgICBMZWZ0SGFuZCA9IFwiTGVmdCBIYW5kXCJcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEhpRmlBeGlzQ29uZmlndXJhdGlvbiB7XHJcbiAgICByaWdodEF4aXM6IEhpRmlBeGVzO1xyXG4gICAgbGVmdEF4aXM6IEhpRmlBeGVzO1xyXG5cclxuICAgIGludG9TY3JlZW5BeGlzOiBIaUZpQXhlcztcclxuICAgIG91dE9mU2NyZWVuQXhpczogSGlGaUF4ZXM7XHJcblxyXG4gICAgdXBBeGlzOiBIaUZpQXhlcztcclxuICAgIGRvd25BeGlzOiBIaUZpQXhlcztcclxuXHJcbiAgICBoYW5kZWRuZXNzOiBIaUZpSGFuZGVkbmVzcztcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcih7cmlnaHRBeGlzLCBsZWZ0QXhpcywgaW50b1NjcmVlbkF4aXMsIG91dE9mU2NyZWVuQXhpcywgdXBBeGlzLCBkb3duQXhpcywgaGFuZGVkbmVzcyB9OiB7cmlnaHRBeGlzOiBIaUZpQXhlcywgbGVmdEF4aXM6IEhpRmlBeGVzLCBpbnRvU2NyZWVuQXhpczogSGlGaUF4ZXMsIG91dE9mU2NyZWVuQXhpczogSGlGaUF4ZXMsIHVwQXhpczogSGlGaUF4ZXMsIGRvd25BeGlzOiBIaUZpQXhlcywgaGFuZGVkbmVzczogSGlGaUhhbmRlZG5lc3MgfSkge1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyByaWdodEF4aXMsIGxlZnRBeGlzLCBpbnRvU2NyZWVuQXhpcywgb3V0T2ZTY3JlZW5BeGlzLCB1cEF4aXMsIGRvd25BeGlzLCBoYW5kZWRuZXNzIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ29udGFpbnMgdGhlIGFwcGxpY2F0aW9uJ3MgM0QgYXhpcyBjb25maWd1cmF0aW9uLiBCeSBkZWZhdWx0OlxyXG4gKiAtIGAreGAgaXMgdG8gdGhlIHJpZ2h0IGFuZCBgLXhgIGlzIHRvIHRoZSBsZWZ0XHJcbiAqIC0gYCt5YCBpcyBpbnRvIHRoZSBzY3JlZW4gYW5kIGAteWAgaXMgb3V0IG9mIHRoZSBzY3JlZW4gdG93YXJkcyB0aGUgdXNlclxyXG4gKiAtIGAremAgaXMgdXAgYW5kIGAtemAgaXMgZG93blxyXG4gKiAtIFRoZSBjb29yZGluYXRlIHN5c3RlbSBpcyByaWdodC1oYW5kZWQuXHJcbiAqL1xyXG5leHBvcnQgbGV0IG91ckhpRmlBeGlzQ29uZmlndXJhdGlvbiA9IG5ldyBIaUZpQXhpc0NvbmZpZ3VyYXRpb24oe1xyXG4gICAgcmlnaHRBeGlzOiBIaUZpQXhlcy5Qb3NpdGl2ZVgsXHJcbiAgICBsZWZ0QXhpczogSGlGaUF4ZXMuTmVnYXRpdmVYLFxyXG4gICAgaW50b1NjcmVlbkF4aXM6IEhpRmlBeGVzLlBvc2l0aXZlWSxcclxuICAgIG91dE9mU2NyZWVuQXhpczogSGlGaUF4ZXMuTmVnYXRpdmVZLFxyXG4gICAgdXBBeGlzOiBIaUZpQXhlcy5Qb3NpdGl2ZVosXHJcbiAgICBkb3duQXhpczogSGlGaUF4ZXMuTmVnYXRpdmVaLFxyXG4gICAgaGFuZGVkbmVzczogSGlGaUhhbmRlZG5lc3MuUmlnaHRIYW5kLFxyXG59KTtcclxuXHJcbmV4cG9ydCBjbGFzcyBIaUZpQXhpc1V0aWxpdGllcyB7XHJcbiAgICBzdGF0aWMgdmVyaWZ5KGF4aXNDb25maWd1cmF0aW9uOiBIaUZpQXhpc0NvbmZpZ3VyYXRpb24pIHtcclxuICAgICAgICBsZXQgaXNWYWxpZCA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIFNUQVJUIGxlZnQvcmlnaHQgYXhpcyBlcnJvciBjaGVja2luZ1xyXG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi5yaWdodEF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWCAmJiBheGlzQ29uZmlndXJhdGlvbi5sZWZ0QXhpcyAhPT0gSGlGaUF4ZXMuTmVnYXRpdmVYKSB7XHJcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYEludmFsaWQgYXhpcyBjb25maWd1cmF0aW9uIVxcblJpZ2h0IEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5yaWdodEF4aXN9LCBhbmQgTGVmdCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24ubGVmdEF4aXN9IWApO1xyXG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi5sZWZ0QXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVYICYmIGF4aXNDb25maWd1cmF0aW9uLnJpZ2h0QXhpcyAhPT0gSGlGaUF4ZXMuTmVnYXRpdmVYKSB7XHJcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYEludmFsaWQgYXhpcyBjb25maWd1cmF0aW9uIVxcblJpZ2h0IEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5yaWdodEF4aXN9LCBhbmQgTGVmdCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24ubGVmdEF4aXN9IWApO1xyXG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24ucmlnaHRBeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVkgJiYgYXhpc0NvbmZpZ3VyYXRpb24ubGVmdEF4aXMgIT09IEhpRmlBeGVzLk5lZ2F0aXZlWSkge1xyXG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBJbnZhbGlkIGF4aXMgY29uZmlndXJhdGlvbiFcXG5SaWdodCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24ucmlnaHRBeGlzfSwgYW5kIExlZnQgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLmxlZnRBeGlzfSFgKTtcclxuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24ubGVmdEF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWSAmJiBheGlzQ29uZmlndXJhdGlvbi5yaWdodEF4aXMgIT09IEhpRmlBeGVzLk5lZ2F0aXZlWSkge1xyXG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBJbnZhbGlkIGF4aXMgY29uZmlndXJhdGlvbiFcXG5SaWdodCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24ucmlnaHRBeGlzfSwgYW5kIExlZnQgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLmxlZnRBeGlzfSFgKTtcclxuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGF4aXNDb25maWd1cmF0aW9uLnJpZ2h0QXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVaICYmIGF4aXNDb25maWd1cmF0aW9uLmxlZnRBeGlzICE9PSBIaUZpQXhlcy5OZWdhdGl2ZVopIHtcclxuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgSW52YWxpZCBheGlzIGNvbmZpZ3VyYXRpb24hXFxuUmlnaHQgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLnJpZ2h0QXhpc30sIGFuZCBMZWZ0IEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5sZWZ0QXhpc30hYCk7XHJcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGF4aXNDb25maWd1cmF0aW9uLmxlZnRBeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVogJiYgYXhpc0NvbmZpZ3VyYXRpb24ucmlnaHRBeGlzICE9PSBIaUZpQXhlcy5OZWdhdGl2ZVopIHtcclxuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgSW52YWxpZCBheGlzIGNvbmZpZ3VyYXRpb24hXFxuUmlnaHQgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLnJpZ2h0QXhpc30sIGFuZCBMZWZ0IEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5sZWZ0QXhpc30hYCk7XHJcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRU5EIGxlZnQvcmlnaHQgYXhpcyBlcnJvciBjaGVja2luZ1xyXG5cclxuICAgICAgICAvLyBTVEFSVCBpbnRvLXNjcmVlbi9vdXQtb2Ytc2NyZWVuIGF4aXMgZXJyb3IgY2hlY2tpbmdcclxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24uaW50b1NjcmVlbkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWCAmJiBheGlzQ29uZmlndXJhdGlvbi5vdXRPZlNjcmVlbkF4aXMgIT09IEhpRmlBeGVzLk5lZ2F0aXZlWCkge1xyXG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBJbnZhbGlkIGF4aXMgY29uZmlndXJhdGlvbiFcXG5SaWdodCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24uaW50b1NjcmVlbkF4aXN9LCBhbmQgTGVmdCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24ub3V0T2ZTY3JlZW5BeGlzfSFgKTtcclxuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24ub3V0T2ZTY3JlZW5BeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVggJiYgYXhpc0NvbmZpZ3VyYXRpb24uaW50b1NjcmVlbkF4aXMgIT09IEhpRmlBeGVzLk5lZ2F0aXZlWCkge1xyXG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBJbnZhbGlkIGF4aXMgY29uZmlndXJhdGlvbiFcXG5SaWdodCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24uaW50b1NjcmVlbkF4aXN9LCBhbmQgTGVmdCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24ub3V0T2ZTY3JlZW5BeGlzfSFgKTtcclxuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGF4aXNDb25maWd1cmF0aW9uLmludG9TY3JlZW5BeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVkgJiYgYXhpc0NvbmZpZ3VyYXRpb24ub3V0T2ZTY3JlZW5BeGlzICE9PSBIaUZpQXhlcy5OZWdhdGl2ZVkpIHtcclxuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgSW52YWxpZCBheGlzIGNvbmZpZ3VyYXRpb24hXFxuUmlnaHQgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLmludG9TY3JlZW5BeGlzfSwgYW5kIExlZnQgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLm91dE9mU2NyZWVuQXhpc30hYCk7XHJcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGF4aXNDb25maWd1cmF0aW9uLm91dE9mU2NyZWVuQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVZICYmIGF4aXNDb25maWd1cmF0aW9uLmludG9TY3JlZW5BeGlzICE9PSBIaUZpQXhlcy5OZWdhdGl2ZVkpIHtcclxuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgSW52YWxpZCBheGlzIGNvbmZpZ3VyYXRpb24hXFxuUmlnaHQgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLmludG9TY3JlZW5BeGlzfSwgYW5kIExlZnQgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLm91dE9mU2NyZWVuQXhpc30hYCk7XHJcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi5pbnRvU2NyZWVuQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVaICYmIGF4aXNDb25maWd1cmF0aW9uLm91dE9mU2NyZWVuQXhpcyAhPT0gSGlGaUF4ZXMuTmVnYXRpdmVaKSB7XHJcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYEludmFsaWQgYXhpcyBjb25maWd1cmF0aW9uIVxcblJpZ2h0IEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5pbnRvU2NyZWVuQXhpc30sIGFuZCBMZWZ0IEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5vdXRPZlNjcmVlbkF4aXN9IWApO1xyXG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi5vdXRPZlNjcmVlbkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWiAmJiBheGlzQ29uZmlndXJhdGlvbi5pbnRvU2NyZWVuQXhpcyAhPT0gSGlGaUF4ZXMuTmVnYXRpdmVaKSB7XHJcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYEludmFsaWQgYXhpcyBjb25maWd1cmF0aW9uIVxcblJpZ2h0IEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5pbnRvU2NyZWVuQXhpc30sIGFuZCBMZWZ0IEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5vdXRPZlNjcmVlbkF4aXN9IWApO1xyXG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEVORCBpbnRvLXNjcmVlbi9vdXQtb2Ytc2NyZWVuIGF4aXMgZXJyb3IgY2hlY2tpbmdcclxuXHJcbiAgICAgICAgLy8gU1RBUlQgdXAvZG93biBheGlzIGVycm9yIGNoZWNraW5nXHJcbiAgICAgICAgaWYgKGF4aXNDb25maWd1cmF0aW9uLnVwQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVYICYmIGF4aXNDb25maWd1cmF0aW9uLmRvd25BeGlzICE9PSBIaUZpQXhlcy5OZWdhdGl2ZVgpIHtcclxuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgSW52YWxpZCBheGlzIGNvbmZpZ3VyYXRpb24hXFxuUmlnaHQgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLnVwQXhpc30sIGFuZCBMZWZ0IEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5kb3duQXhpc30hYCk7XHJcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGF4aXNDb25maWd1cmF0aW9uLmRvd25BeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVggJiYgYXhpc0NvbmZpZ3VyYXRpb24udXBBeGlzICE9PSBIaUZpQXhlcy5OZWdhdGl2ZVgpIHtcclxuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgSW52YWxpZCBheGlzIGNvbmZpZ3VyYXRpb24hXFxuUmlnaHQgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLnVwQXhpc30sIGFuZCBMZWZ0IEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5kb3duQXhpc30hYCk7XHJcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi51cEF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWSAmJiBheGlzQ29uZmlndXJhdGlvbi5kb3duQXhpcyAhPT0gSGlGaUF4ZXMuTmVnYXRpdmVZKSB7XHJcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYEludmFsaWQgYXhpcyBjb25maWd1cmF0aW9uIVxcblJpZ2h0IEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi51cEF4aXN9LCBhbmQgTGVmdCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24uZG93bkF4aXN9IWApO1xyXG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi5kb3duQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVZICYmIGF4aXNDb25maWd1cmF0aW9uLnVwQXhpcyAhPT0gSGlGaUF4ZXMuTmVnYXRpdmVZKSB7XHJcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYEludmFsaWQgYXhpcyBjb25maWd1cmF0aW9uIVxcblJpZ2h0IEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi51cEF4aXN9LCBhbmQgTGVmdCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24uZG93bkF4aXN9IWApO1xyXG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24udXBBeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVogJiYgYXhpc0NvbmZpZ3VyYXRpb24uZG93bkF4aXMgIT09IEhpRmlBeGVzLk5lZ2F0aXZlWikge1xyXG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBJbnZhbGlkIGF4aXMgY29uZmlndXJhdGlvbiFcXG5SaWdodCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24udXBBeGlzfSwgYW5kIExlZnQgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLmRvd25BeGlzfSFgKTtcclxuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24uZG93bkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWiAmJiBheGlzQ29uZmlndXJhdGlvbi51cEF4aXMgIT09IEhpRmlBeGVzLk5lZ2F0aXZlWikge1xyXG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBJbnZhbGlkIGF4aXMgY29uZmlndXJhdGlvbiFcXG5SaWdodCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24udXBBeGlzfSwgYW5kIExlZnQgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLmRvd25BeGlzfSFgKTtcclxuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBFTkQgdXAvZG93biBheGlzIGVycm9yIGNoZWNraW5nXHJcblxyXG4gICAgICAgIGlmICghKGF4aXNDb25maWd1cmF0aW9uLmhhbmRlZG5lc3MgPT09IEhpRmlIYW5kZWRuZXNzLlJpZ2h0SGFuZCB8fCBheGlzQ29uZmlndXJhdGlvbi5oYW5kZWRuZXNzID09PSBIaUZpSGFuZGVkbmVzcy5MZWZ0SGFuZCkpIHtcclxuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgSW52YWxpZCBheGlzIGNvbmZpZ3VyYXRpb24hXFxuSGFuZGVkbmVzcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLmhhbmRlZG5lc3N9IWApO1xyXG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gaXNWYWxpZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOKaoCBXQVJOSU5HIOKaoCBUaGUgY29kZSBpbiB0aGlzIGZ1bmN0aW9uIG1pZ2h0IGJlIHdyb25nLCBiZWNhdXNlIDNEIG1hdGggaXMgcmVhbGx5IGhhcmQuIFRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gd29ya3MgZmluZSxcclxuICAgICAqIGJ1dCBpdCdzIGNoYWxsZW5naW5nIHRvIHZlcmlmeSB0aGF0IG90aGVyIGNvbmZpZ3VyYXRpb25zIHdvcmsgYXMgZXhwZWN0ZWQgdW50aWwgd2UgaGF2ZSBhIGJldHRlciAzRCBleGFtcGxlIGFwcC5cclxuICAgICAqIFRPRE86IFZlcmlmeSB0aGF0IHRoaXMgaXMgYWN0dWFsbHkgZG9pbmcgd2hhdCB3ZSB3YW50IGZvciBpdCB0byBiZSBkb2luZy5cclxuICAgICAqIFxyXG4gICAgICogVGhlIEhpRmkgQXhpcyBDb25maWd1cmF0aW9uIG11c3QgaGF2ZSBiZWVuIHZlcmlmaWVkIHVzaW5nIGBIaUZpQXhpc0NvbmZpZ3VyYXRpb24udmVyaWZ5KClgIGJlZm9yZSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZC5cclxuICAgICAqIE90aGVyd2lzZSwgdW5kZWZpbmVkIGJlaGF2aW9yIHdpbGwgb2NjdXIuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSBheGlzQ29uZmlndXJhdGlvbiBcclxuICAgICAqIEBwYXJhbSBpbnB1dFBvaW50M0QgXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB0cmFuc2xhdGVQb2ludDNEVG9NaXhlclNwYWNlKGF4aXNDb25maWd1cmF0aW9uOiBIaUZpQXhpc0NvbmZpZ3VyYXRpb24sIGlucHV0UG9pbnQzRDogUG9pbnQzRCk6IFBvaW50M0Qge1xyXG4gICAgICAgIGxldCByZXR2YWwgPSBuZXcgUG9pbnQzRCgpO1xyXG5cclxuICAgICAgICBsZXQgaW5wdXRYSXNOdW1iZXIgPSB0eXBlb2YgKGlucHV0UG9pbnQzRC54KSA9PT0gXCJudW1iZXJcIjtcclxuICAgICAgICBsZXQgaW5wdXRZSXNOdW1iZXIgPSB0eXBlb2YgKGlucHV0UG9pbnQzRC55KSA9PT0gXCJudW1iZXJcIjtcclxuICAgICAgICBsZXQgaW5wdXRaSXNOdW1iZXIgPSB0eXBlb2YgKGlucHV0UG9pbnQzRC56KSA9PT0gXCJudW1iZXJcIjtcclxuXHJcbiAgICAgICAgaWYgKGF4aXNDb25maWd1cmF0aW9uLnJpZ2h0QXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVYICYmIGlucHV0WElzTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJldHZhbC54ID0gaW5wdXRQb2ludDNELng7XHJcbiAgICAgICAgfSBlbHNlIGlmIChheGlzQ29uZmlndXJhdGlvbi5sZWZ0QXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVYICYmIGlucHV0WElzTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJldHZhbC54ID0gLWlucHV0UG9pbnQzRC54O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24uaW50b1NjcmVlbkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWCAmJiBpbnB1dFlJc051bWJlcikge1xyXG4gICAgICAgICAgICByZXR2YWwueCA9IGlucHV0UG9pbnQzRC55O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24ub3V0T2ZTY3JlZW5BeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVggJiYgaW5wdXRZSXNOdW1iZXIpIHtcclxuICAgICAgICAgICAgcmV0dmFsLnggPSAtaW5wdXRQb2ludDNELnk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChheGlzQ29uZmlndXJhdGlvbi51cEF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWCAmJiBpbnB1dFpJc051bWJlcikge1xyXG4gICAgICAgICAgICByZXR2YWwueCA9IGlucHV0UG9pbnQzRC56O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24uZG93bkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWCAmJiBpbnB1dFpJc051bWJlcikge1xyXG4gICAgICAgICAgICByZXR2YWwueCA9IC1pbnB1dFBvaW50M0QuejtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi5yaWdodEF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWSAmJiBpbnB1dFhJc051bWJlcikge1xyXG4gICAgICAgICAgICByZXR2YWwueSA9IGlucHV0UG9pbnQzRC54O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24ubGVmdEF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWSAmJiBpbnB1dFhJc051bWJlcikge1xyXG4gICAgICAgICAgICByZXR2YWwueSA9IC1pbnB1dFBvaW50M0QueDtcclxuICAgICAgICB9IGVsc2UgaWYgKGF4aXNDb25maWd1cmF0aW9uLmludG9TY3JlZW5BeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVkgJiYgaW5wdXRZSXNOdW1iZXIpIHtcclxuICAgICAgICAgICAgcmV0dmFsLnkgPSBpbnB1dFBvaW50M0QueTtcclxuICAgICAgICB9IGVsc2UgaWYgKGF4aXNDb25maWd1cmF0aW9uLm91dE9mU2NyZWVuQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVZICYmIGlucHV0WUlzTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJldHZhbC55ID0gLWlucHV0UG9pbnQzRC55O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24udXBBeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVkgJiYgaW5wdXRaSXNOdW1iZXIpIHtcclxuICAgICAgICAgICAgcmV0dmFsLnkgPSBpbnB1dFBvaW50M0QuejtcclxuICAgICAgICB9IGVsc2UgaWYgKGF4aXNDb25maWd1cmF0aW9uLmRvd25BeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVkgJiYgaW5wdXRaSXNOdW1iZXIpIHtcclxuICAgICAgICAgICAgcmV0dmFsLnkgPSAtaW5wdXRQb2ludDNELno7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24ucmlnaHRBeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVogJiYgaW5wdXRYSXNOdW1iZXIpIHtcclxuICAgICAgICAgICAgcmV0dmFsLnogPSBpbnB1dFBvaW50M0QueDtcclxuICAgICAgICB9IGVsc2UgaWYgKGF4aXNDb25maWd1cmF0aW9uLmxlZnRBeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVogJiYgaW5wdXRYSXNOdW1iZXIpIHtcclxuICAgICAgICAgICAgcmV0dmFsLnogPSAtaW5wdXRQb2ludDNELng7XHJcbiAgICAgICAgfSBlbHNlIGlmIChheGlzQ29uZmlndXJhdGlvbi5pbnRvU2NyZWVuQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVaICYmIGlucHV0WUlzTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJldHZhbC56ID0gaW5wdXRQb2ludDNELnk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChheGlzQ29uZmlndXJhdGlvbi5vdXRPZlNjcmVlbkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWiAmJiBpbnB1dFlJc051bWJlcikge1xyXG4gICAgICAgICAgICByZXR2YWwueiA9IC1pbnB1dFBvaW50M0QueTtcclxuICAgICAgICB9IGVsc2UgaWYgKGF4aXNDb25maWd1cmF0aW9uLnVwQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVaICYmIGlucHV0WklzTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJldHZhbC56ID0gaW5wdXRQb2ludDNELno7XHJcbiAgICAgICAgfSBlbHNlIGlmIChheGlzQ29uZmlndXJhdGlvbi5kb3duQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVaICYmIGlucHV0WklzTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJldHZhbC56ID0gLWlucHV0UG9pbnQzRC56O1xyXG4gICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOKaoCBXQVJOSU5HIOKaoCBUaGUgY29kZSBpbiB0aGlzIGZ1bmN0aW9uIG1pZ2h0IGJlIHdyb25nLCBiZWNhdXNlIDNEIG1hdGggaXMgcmVhbGx5IGhhcmQuIFRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gd29ya3MgZmluZSxcclxuICAgICAqIGJ1dCBpdCdzIGNoYWxsZW5naW5nIHRvIHZlcmlmeSB0aGF0IG90aGVyIGNvbmZpZ3VyYXRpb25zIHdvcmsgYXMgZXhwZWN0ZWQgdW50aWwgd2UgaGF2ZSBhIGJldHRlciAzRCBleGFtcGxlIGFwcC5cclxuICAgICAqIFRPRE86IFZlcmlmeSB0aGF0IHRoaXMgaXMgYWN0dWFsbHkgZG9pbmcgd2hhdCB3ZSB3YW50IGZvciBpdCB0byBiZSBkb2luZy5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIGF4aXNDb25maWd1cmF0aW9uIFxyXG4gICAgICogQHBhcmFtIGlucHV0T3JpZW50YXRpb25FdWxlcjNEIFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdHJhbnNsYXRlT3JpZW50YXRpb25FdWxlcjNEVG9NaXhlclNwYWNlKGF4aXNDb25maWd1cmF0aW9uOiBIaUZpQXhpc0NvbmZpZ3VyYXRpb24sIGlucHV0T3JpZW50YXRpb25FdWxlcjNEOiBPcmllbnRhdGlvbkV1bGVyM0QpOiBPcmllbnRhdGlvbkV1bGVyM0Qge1xyXG4gICAgICAgIGxldCByZXR2YWwgPSBuZXcgT3JpZW50YXRpb25FdWxlcjNEKCk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgKGlucHV0T3JpZW50YXRpb25FdWxlcjNELnBpdGNoRGVncmVlcykgIT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgaW5wdXRPcmllbnRhdGlvbkV1bGVyM0QucGl0Y2hEZWdyZWVzID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiAoaW5wdXRPcmllbnRhdGlvbkV1bGVyM0QueWF3RGVncmVlcykgIT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgaW5wdXRPcmllbnRhdGlvbkV1bGVyM0QueWF3RGVncmVlcyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgKGlucHV0T3JpZW50YXRpb25FdWxlcjNELnJvbGxEZWdyZWVzKSAhPT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICBpbnB1dE9yaWVudGF0aW9uRXVsZXIzRC5yb2xsRGVncmVlcyA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24uaGFuZGVkbmVzcyA9PT0gSGlGaUhhbmRlZG5lc3MuUmlnaHRIYW5kKSB7XHJcbiAgICAgICAgICAgIHJldHZhbC5waXRjaERlZ3JlZXMgPSBpbnB1dE9yaWVudGF0aW9uRXVsZXIzRC5waXRjaERlZ3JlZXM7XHJcbiAgICAgICAgICAgIHJldHZhbC55YXdEZWdyZWVzID0gaW5wdXRPcmllbnRhdGlvbkV1bGVyM0QueWF3RGVncmVlcztcclxuICAgICAgICAgICAgcmV0dmFsLnJvbGxEZWdyZWVzID0gaW5wdXRPcmllbnRhdGlvbkV1bGVyM0Qucm9sbERlZ3JlZXM7XHJcbiAgICAgICAgfSBlbHNlIGlmIChheGlzQ29uZmlndXJhdGlvbi5oYW5kZWRuZXNzID09PSBIaUZpSGFuZGVkbmVzcy5MZWZ0SGFuZCkge1xyXG4gICAgICAgICAgICByZXR2YWwucGl0Y2hEZWdyZWVzID0gaW5wdXRPcmllbnRhdGlvbkV1bGVyM0QucGl0Y2hEZWdyZWVzO1xyXG4gICAgICAgICAgICByZXR2YWwueWF3RGVncmVlcyA9IC1pbnB1dE9yaWVudGF0aW9uRXVsZXIzRC55YXdEZWdyZWVzO1xyXG4gICAgICAgICAgICByZXR2YWwucm9sbERlZ3JlZXMgPSBpbnB1dE9yaWVudGF0aW9uRXVsZXIzRC5yb2xsRGVncmVlcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIE1ldGhvZHMgb24gdGhlIFtbSGlGaUNvbW11bmljYXRvcl1dIGNsYXNzIGFsbG93IGRldmVsb3BlcnMgdG8gcGVyZm9ybSBhY3Rpb25zIHN1Y2ggYXM6XHJcbiAqIC0gYGNvbm5lY3RUb0hpRmlBdWRpb0FQSVNlcnZlcigpYDogQ29ubmVjdCB0byBhbmQgZGlzY29ubmVjdCBmcm9tIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIFNlcnZlclxyXG4gKiAtIGB1cGRhdGVVc2VyRGF0YUFuZFRyYW5zbWl0KClgOiBVcGRhdGUgdGhlIHVzZXIncyBkYXRhIChwb3NpdGlvbiwgb3JpZW50YXRpb24sIGV0Yykgb24gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gU2VydmVyXHJcbiAqIC0gYHNldElucHV0QXVkaW9NZWRpYVN0cmVhbSgpYDogU2V0IGEgbmV3IGlucHV0IGF1ZGlvIG1lZGlhIHN0cmVhbSAoZm9yIGV4YW1wbGUsIHdoZW4gdGhlIHVzZXIncyBhdWRpbyBpbnB1dCBkZXZpY2UgY2hhbmdlcylcclxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXHJcbiAqL1xyXG5cclxuZGVjbGFyZSB2YXIgQlVJTERfRU5WSVJPTk1FTlQ6IHN0cmluZztcclxuZGVjbGFyZSB2YXIgSElGSV9BUElfVkVSU0lPTjogc3RyaW5nO1xyXG5cclxuaW1wb3J0IHsgSGlGaUNvbnN0YW50cyB9IGZyb20gXCIuLi9jb25zdGFudHMvSGlGaUNvbnN0YW50c1wiO1xyXG5pbXBvcnQgeyBIaUZpTG9nZ2VyIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9IaUZpTG9nZ2VyXCI7XHJcbmltcG9ydCB7IEhpRmlBdWRpb0FQSURhdGEsIFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YSwgUG9pbnQzRCwgT3JpZW50YXRpb25FdWxlcjNELCBPcmllbnRhdGlvblF1YXQzRCB9IGZyb20gXCIuL0hpRmlBdWRpb0FQSURhdGFcIjtcclxuaW1wb3J0IHsgSGlGaUF4aXNDb25maWd1cmF0aW9uLCBIaUZpQXhpc1V0aWxpdGllcywgb3VySGlGaUF4aXNDb25maWd1cmF0aW9uIH0gZnJvbSBcIi4vSGlGaUF4aXNDb25maWd1cmF0aW9uXCI7XHJcbmltcG9ydCB7IEhpRmlNaXhlclNlc3Npb24gfSBmcm9tIFwiLi9IaUZpTWl4ZXJTZXNzaW9uXCI7XHJcbmltcG9ydCB7IEF2YWlsYWJsZVVzZXJEYXRhU3Vic2NyaXB0aW9uQ29tcG9uZW50cywgVXNlckRhdGFTdWJzY3JpcHRpb24gfSBmcm9tIFwiLi9IaUZpVXNlckRhdGFTdWJzY3JpcHRpb25cIjtcclxuXHJcbi8qKlxyXG4gKiBXaGVuIHRoZSBzdGF0ZSBvZiB0aGUgY29ubmVjdGlvbiB0byB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBTZXJ2ZXIgY2hhbmdlcywgdGhlIG5ldyBzdGF0ZSB3aWxsIGJlIG9uZSBvZiB0aGVzZSB2YWx1ZXMuXHJcbiAqL1xyXG5leHBvcnQgZW51bSBIaUZpQ29ubmVjdGlvblN0YXRlcyB7XHJcbiAgICBDb25uZWN0ZWQgPSBcIkNvbm5lY3RlZFwiLFxyXG4gICAgRGlzY29ubmVjdGVkID0gXCJEaXNjb25uZWN0ZWRcIixcclxuICAgIEZhaWxlZCA9IFwiRmFpbGVkXCIsXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBgSGlGaUNvbm5lY3Rpb25TdGF0ZWAgd2lsbCBiZSBgXCJVbmF2YWlsYWJsZVwiYCB3aGVuIHRoZSBBUEkgU2VydmVyIGlzIGF0IGNhcGFjaXR5LlxyXG4gICAgICovXHJcbiAgICBVbmF2YWlsYWJsZSA9IFwiVW5hdmFpbGFibGVcIlxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFxyXG4gKi9cclxuZXhwb3J0IGVudW0gSGlGaVVzZXJEYXRhU3RyZWFtaW5nU2NvcGVzIHtcclxuICAgIC8qKlxyXG4gICAgICogUGFzc2luZyB0aGlzIHZhbHVlIHRvIHRoZSB7QGxpbmsgSGlGaUNvbW11bmljYXRvcn0gY29uc3RydWN0b3IgbWVhbnMgdGhhdCB0aGUgU2VydmVyIHdpbGwgbm90IHNlbmQgYW55XHJcbiAgICAgKiBVc2VyIERhdGEgdXBkYXRlcyB0byB0aGUgY2xpZW50LCBtZWFuaW5nIFVzZXIgRGF0YSBTdWJzY3JpcHRpb25zIHdpbGwgbm90IGZ1bmN0aW9uLiBUaGlzIFN0cmVhbWluZyBTY29wZVxyXG4gICAgICogc2F2ZXMgYmFuZHdpZHRoIGFuZCwgbWFyZ2luYWxseSwgcHJvY2Vzc2luZyB0aW1lLlxyXG4gICAgICovXHJcbiAgICBOb25lID0gXCJub25lXCIsXHJcbiAgICAvKipcclxuICAgICAqIFBhc3NpbmcgdGhpcyB2YWx1ZSB0byB0aGUge0BsaW5rIEhpRmlDb21tdW5pY2F0b3J9IGNvbnN0cnVjdG9yIG1lYW5zIHRoYXQgdGhlIFNlcnZlciB3aWxsIG9ubHkgc2VuZFxyXG4gICAgICogX3BlZXIgZGF0YV8gdG8gdGhlIENsaWVudDsgdGhlIFNlcnZlciB3aWxsIG5vdCBzZW5kIFVzZXIgRGF0YSBwZXJ0YWluaW5nIHRvIHRoZSBjb25uZWN0aW5nIENsaWVudCB3aGVuXHJcbiAgICAgKiB0aGlzIERhdGEgU3RyZWFtaW5nIFNjb3BlIGlzIHNlbGVjdGVkLlxyXG4gICAgICovXHJcbiAgICBQZWVycyA9IFwicGVlcnNcIixcclxuICAgIC8qKlxyXG4gICAgICogXCJhbGxcIiBpcyB0aGUgZGVmYXVsdCB2YWx1ZSB3aGVuIHRoZSB7QGxpbmsgSGlGaUNvbW11bmljYXRvcn0gY29uc3RydWN0b3IgaXMgY2FsbGVkLiBBbGwgVXNlciBEYXRhXHJcbiAgICAgKiB3aWxsIGJlIHN0cmVhbWVkIGZyb20gdGhlIFNlcnZlciB0byB0aGUgQ2xpZW50LlxyXG4gICAgICovXHJcbiAgICBBbGwgPSBcImFsbFwiXHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyBleHBvc2VzIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgdXNlZnVsIGZvciBjb21tdW5pY2F0aW5nIGZyb20gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJIENsaWVudCB0b1xyXG4gKiB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBBUEkgU2VydmVyLiBcclxuICovXHJcbmV4cG9ydCBjbGFzcyBIaUZpQ29tbXVuaWNhdG9yIHtcclxuICAgIC8vIFByZXZlbnRzIHVzZXJzIG9mIG91ciBjbGllbnQtc2lkZSBBUEkgZnJvbSBzbGFtbWluZyB0aGVpciBtaXhlciB3aXRoIHJlcXVlc3RzLlxyXG4gICAgLy8gT2YgY291cnNlLCBiZWNhdXNlIHRoaXMgcmF0ZSBsaW1pdCBpcyBjbGllbnRzaWRlLCBpdCBjb3VsZCBiZSB3b3JrZWQgYXJvdW5kLlxyXG4gICAgdHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0TVM6IG51bWJlcjtcclxuICAgIHByaXZhdGUgX3RpbWVyczogYW55ID0ge1xyXG4gICAgICAgIHRyYW5zbWl0UmF0ZUxpbWl0VGltZW91dDogbnVsbCxcclxuICAgICAgICB3YW50ZWRUb1RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YTogdHJ1ZVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBUaGlzIGlzIHVzdWFsbHkgdGhlIGBNZWRpYVN0cmVhbWAgYXNzb2NpYXRlZCB3aXRoIGEgdXNlcidzIGF1ZGlvIGlucHV0IGRldmljZSxcclxuICAgIC8vIGJ1dCBpdCBjb3VsZCBiZSBhbnkgYE1lZGlhU3RyZWFtYC5cclxuICAgIHByaXZhdGUgX2lucHV0QXVkaW9NZWRpYVN0cmVhbTogTWVkaWFTdHJlYW07XHJcblxyXG4gICAgLy8gVGhlc2UgbmV4dCB0d28gbWVtYmVyIHZhcmlhYmxlcyBhcmUgdXNlZCBmb3Iga2VlcGluZyB0cmFjayBvZiB3aGF0IHRvIHNlbmQgdG8gdGhlIG1peGVyLlxyXG4gICAgLy8gVGhlIGNsaWVudCBvbmx5IHNlbmRzIGRhdGEgdGhhdCB0aGUgbWl4ZXIgZG9lc24ndCBhbHJlYWR5IGtub3cgYWJvdXQuXHJcbiAgICBwcml2YXRlIF9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YTogSGlGaUF1ZGlvQVBJRGF0YTtcclxuICAgIHByaXZhdGUgX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGE6IEhpRmlBdWRpb0FQSURhdGE7XHJcblxyXG4gICAgLy8gTGlicmFyeSB1c2VycyBjYW4gbWFrZSB1c2Ugb2YgXCJVc2VyIERhdGEgU3Vic2NyaXB0aW9uc1wiIHRvIGNhdXNlIHNvbWV0aGluZyB0byBoYXBwZW5cclxuICAgIC8vIHdoZW4gdGhlIHNlcnZlciByZXBvcnRzIHRoYXQgYSB1c2VyJ3MgZGF0YSAtIHN1Y2ggYXMgcG9zaXRpb24sIG9yaWVudGF0aW9uRXVsZXIsIGFuZCB2b2x1bWUgLSBoYXMgYmVlbiBtb2RpZmllZC5cclxuICAgIHByaXZhdGUgX3VzZXJEYXRhU3Vic2NyaXB0aW9uczogQXJyYXk8VXNlckRhdGFTdWJzY3JpcHRpb24+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VlIHtAbGluayBIaUZpQ29tbXVuaWNhdG9yLl9vblVzZXJzRGlzY29ubmVjdGVkfS5cclxuICAgICAqL1xyXG4gICAgb25Vc2Vyc0Rpc2Nvbm5lY3RlZDogRnVuY3Rpb247XHJcblxyXG4gICAgLy8gVGhpcyBjb250YWlucyBkYXRhIGRlYWxpbmcgd2l0aCB0aGUgbWl4ZXIgc2Vzc2lvbiwgc3VjaCBhcyB0aGUgUkFWSSBzZXNzaW9uLCBXZWJSVEMgYWRkcmVzcywgZXRjLlxyXG4gICAgcHJpdmF0ZSBfbWl4ZXJTZXNzaW9uOiBIaUZpTWl4ZXJTZXNzaW9uO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0b3IgZm9yIHRoZSBIaUZpQ29tbXVuaWNhdG9yIG9iamVjdC4gT25jZSB5b3UgaGF2ZSBjcmVhdGVkIGEgSGlGaUNvbW11bmljYXRvciwgeW91IGNhbiB1c2UgdGhlXHJcbiAgICAgKiB7QGxpbmsgc2V0SW5wdXRBdWRpb01lZGlhU3RyZWFtfSBtZXRob2QgdG8gYXNzaWduIGFuIGlucHV0IGF1ZGlvIHN0cmVhbSB0byB0aGUgY29ubmVjdGlvbiwgYW5kXHJcbiAgICAgKiBvbmNlIHRoZSBjb25uZWN0aW9uIGhhcyBiZWVuIGVzdGFibGlzaGVkLCB1c2UgdGhlIHtAbGluayBnZXRPdXRwdXRBdWRpb01lZGlhU3RyZW19IG1ldGhvZCB0b1xyXG4gICAgICogcmV0cmlldmUgdGhlIG91dHB1dCBhdWRpbyBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gX19uYW1lZFBhcmFtZXRlcnNcclxuICAgICAqIEBwYXJhbSBpbml0aWFsSGlGaUF1ZGlvQVBJRGF0YSAtIFRoZSBpbml0aWFsIHBvc2l0aW9uLCBvcmllbnRhdGlvbiwgZXRjIG9mIHRoZSB1c2VyLlxyXG4gICAgICogQHBhcmFtIG9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCAtIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBjb25uZWN0aW9uIHN0YXRlIHRvIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIEFQSSBTZXJ2ZXIgY2hhbmdlcy4gU2VlIHtAbGluayBIaUZpQ29ubmVjdGlvblN0YXRlc30uXHJcbiAgICAgKiBAcGFyYW0gb25Vc2Vyc0Rpc2Nvbm5lY3RlZCAtIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIGEgcGVlciBkaXNjb25uZWN0cyBmcm9tIHRoZSBTcGFjZS5cclxuICAgICAqIEBwYXJhbSB0cmFuc21pdFJhdGVMaW1pdFRpbWVvdXRNUyAtIFVzZXIgRGF0YSB1cGRhdGVzIHdpbGwgbm90IGJlIHNlbnQgdG8gdGhlIHNlcnZlciBhbnkgbW9yZSBmcmVxdWVudGx5IHRoYW4gdGhpcyBudW1iZXIgaW4gbWlsbGlzZWNvbmRzLlxyXG4gICAgICogQHBhcmFtIHVzZXJEYXRhU3RyZWFtaW5nU2NvcGUgLSBDYW5ub3QgYmUgc2V0IGxhdGVyLiBTZWUge0BsaW5rIEhpRmlVc2VyRGF0YVN0cmVhbWluZ1Njb3Blc30uXHJcbiAgICAgKiBAcGFyYW0gaGlGaUF4aXNDb25maWd1cmF0aW9uIC0gQ2Fubm90IGJlIHNldCBsYXRlci4gVGhlIDNEIGF4aXMgY29uZmlndXJhdGlvbi4gU2VlIHtAbGluayBvdXJIaUZpQXhpc0NvbmZpZ3VyYXRpb259IGZvciBkZWZhdWx0cy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Ioe1xyXG4gICAgICAgIGluaXRpYWxIaUZpQXVkaW9BUElEYXRhID0gbmV3IEhpRmlBdWRpb0FQSURhdGEoKSxcclxuICAgICAgICBvbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQsXHJcbiAgICAgICAgb25Vc2Vyc0Rpc2Nvbm5lY3RlZCxcclxuICAgICAgICB0cmFuc21pdFJhdGVMaW1pdFRpbWVvdXRNUyA9IEhpRmlDb25zdGFudHMuREVGQVVMVF9UUkFOU01JVF9SQVRFX0xJTUlUX1RJTUVPVVRfTVMsXHJcbiAgICAgICAgdXNlckRhdGFTdHJlYW1pbmdTY29wZSA9IEhpRmlVc2VyRGF0YVN0cmVhbWluZ1Njb3Blcy5BbGwsXHJcbiAgICAgICAgaGlGaUF4aXNDb25maWd1cmF0aW9uXHJcbiAgICB9OiB7XHJcbiAgICAgICAgaW5pdGlhbEhpRmlBdWRpb0FQSURhdGE/OiBIaUZpQXVkaW9BUElEYXRhLFxyXG4gICAgICAgIG9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZD86IEZ1bmN0aW9uLFxyXG4gICAgICAgIG9uVXNlcnNEaXNjb25uZWN0ZWQ/OiBGdW5jdGlvbixcclxuICAgICAgICB0cmFuc21pdFJhdGVMaW1pdFRpbWVvdXRNUz86IG51bWJlcixcclxuICAgICAgICB1c2VyRGF0YVN0cmVhbWluZ1Njb3BlPzogSGlGaVVzZXJEYXRhU3RyZWFtaW5nU2NvcGVzLFxyXG4gICAgICAgIGhpRmlBeGlzQ29uZmlndXJhdGlvbj86IEhpRmlBeGlzQ29uZmlndXJhdGlvblxyXG4gICAgfSA9IHt9KSB7XHJcbiAgICAgICAgLy8gTWFrZSBtaW5pbXVtIDEwbXNcclxuICAgICAgICBpZiAodHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0TVMgPCBIaUZpQ29uc3RhbnRzLk1JTl9UUkFOU01JVF9SQVRFX0xJTUlUX1RJTUVPVVRfTVMpIHtcclxuICAgICAgICAgICAgSGlGaUxvZ2dlci53YXJuKGBcXGB0cmFuc21pdFJhdGVMaW1pdFRpbWVvdXRNU1xcYCBtdXN0IGJlID49ICR7SGlGaUNvbnN0YW50cy5NSU5fVFJBTlNNSVRfUkFURV9MSU1JVF9USU1FT1VUX01TfW1zISBTZXR0aW5nIHRvICR7SGlGaUNvbnN0YW50cy5NSU5fVFJBTlNNSVRfUkFURV9MSU1JVF9USU1FT1VUX01TfW1zLi4uYCk7XHJcbiAgICAgICAgICAgIHRyYW5zbWl0UmF0ZUxpbWl0VGltZW91dE1TID0gSGlGaUNvbnN0YW50cy5NSU5fVFJBTlNNSVRfUkFURV9MSU1JVF9USU1FT1VUX01TO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRyYW5zbWl0UmF0ZUxpbWl0VGltZW91dE1TID0gdHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0TVM7XHJcblxyXG4gICAgICAgIGlmIChvblVzZXJzRGlzY29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25Vc2Vyc0Rpc2Nvbm5lY3RlZCA9IG9uVXNlcnNEaXNjb25uZWN0ZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9taXhlclNlc3Npb24gPSBuZXcgSGlGaU1peGVyU2Vzc2lvbih7XHJcbiAgICAgICAgICAgIFwidXNlckRhdGFTdHJlYW1pbmdTY29wZVwiOiB1c2VyRGF0YVN0cmVhbWluZ1Njb3BlLFxyXG4gICAgICAgICAgICBcIm9uVXNlckRhdGFVcGRhdGVkXCI6IChkYXRhOiBBcnJheTxSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGE+KSA9PiB7IHRoaXMuX2hhbmRsZVVzZXJEYXRhVXBkYXRlcyhkYXRhKTsgfSxcclxuICAgICAgICAgICAgXCJvblVzZXJzRGlzY29ubmVjdGVkXCI6IChkYXRhOiBBcnJheTxSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGE+KSA9PiB7IHRoaXMuX29uVXNlcnNEaXNjb25uZWN0ZWQoZGF0YSk7IH0sXHJcbiAgICAgICAgICAgIFwib25Db25uZWN0aW9uU3RhdGVDaGFuZ2VkXCI6IG9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLl9pbnB1dEF1ZGlvTWVkaWFTdHJlYW0gPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhID0gaW5pdGlhbEhpRmlBdWRpb0FQSURhdGE7XHJcblxyXG4gICAgICAgIHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEgPSBuZXcgSGlGaUF1ZGlvQVBJRGF0YSgpO1xyXG5cclxuICAgICAgICB0aGlzLl91c2VyRGF0YVN1YnNjcmlwdGlvbnMgPSBbXTtcclxuXHJcbiAgICAgICAgaWYgKGhpRmlBeGlzQ29uZmlndXJhdGlvbikge1xyXG4gICAgICAgICAgICBpZiAoSGlGaUF4aXNVdGlsaXRpZXMudmVyaWZ5KGhpRmlBeGlzQ29uZmlndXJhdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIG91ckhpRmlBeGlzQ29uZmlndXJhdGlvbi5yaWdodEF4aXMgPSBoaUZpQXhpc0NvbmZpZ3VyYXRpb24ucmlnaHRBeGlzO1xyXG4gICAgICAgICAgICAgICAgb3VySGlGaUF4aXNDb25maWd1cmF0aW9uLmxlZnRBeGlzID0gaGlGaUF4aXNDb25maWd1cmF0aW9uLmxlZnRBeGlzO1xyXG4gICAgICAgICAgICAgICAgb3VySGlGaUF4aXNDb25maWd1cmF0aW9uLmludG9TY3JlZW5BeGlzID0gaGlGaUF4aXNDb25maWd1cmF0aW9uLmludG9TY3JlZW5BeGlzO1xyXG4gICAgICAgICAgICAgICAgb3VySGlGaUF4aXNDb25maWd1cmF0aW9uLm91dE9mU2NyZWVuQXhpcyA9IGhpRmlBeGlzQ29uZmlndXJhdGlvbi5vdXRPZlNjcmVlbkF4aXM7XHJcbiAgICAgICAgICAgICAgICBvdXJIaUZpQXhpc0NvbmZpZ3VyYXRpb24udXBBeGlzID0gaGlGaUF4aXNDb25maWd1cmF0aW9uLnVwQXhpcztcclxuICAgICAgICAgICAgICAgIG91ckhpRmlBeGlzQ29uZmlndXJhdGlvbi5kb3duQXhpcyA9IGhpRmlBeGlzQ29uZmlndXJhdGlvbi5kb3duQXhpcztcclxuICAgICAgICAgICAgICAgIG91ckhpRmlBeGlzQ29uZmlndXJhdGlvbi5oYW5kZWRuZXNzID0gaGlGaUF4aXNDb25maWd1cmF0aW9uLmhhbmRlZG5lc3M7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBUaGVyZSBpcyBhbiBlcnJvciB3aXRoIHRoZSBwYXNzZWQgXFxgSGlGaUF4aXNDb25maWd1cmF0aW9uXFxgLCBzbyB0aGUgbmV3IGF4aXMgY29uZmlndXJhdGlvbiB3YXMgbm90IHNldC4gVGhlcmUgYXJlIG1vcmUgZXJyb3IgZGV0YWlscyBpbiB0aGUgbG9ncyBhYm92ZS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbm5lY3RzIHRvIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIEFQSSBzZXJ2ZXIgYW5kIHRyYW5zbWl0cyB0aGUgaW5pdGlhbCB1c2VyIGRhdGEgdG8gdGhlIHNlcnZlci5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIGhpZmlBdXRoSldUICBUaGlzIEpTT04gV2ViIFRva2VuIChKV1QpIGlzIHVzZWQgYnkgY2FsbGVycyB0byBhc3NvY2lhdGUgYSB1c2VyIHdpdGggYSBzcGVjaWZpYyBIaWdoIEZpZGVsaXR5IFNwYXRpYWwgQXVkaW8gQVBJIFNlcnZlci5cclxuICAgICAqIEpXVHMgYXJlIGFuIGluZHVzdHJ5LXN0YW5kYXJkIG1ldGhvZCBmb3Igc2VjdXJlbHkgcmVwcmVzZW50aW5nIGNsYWltcyBiZXR3ZWVuIHR3byBhcHBsaWNhdGlvbnMuXHJcbiAgICAgKiBcclxuICAgICAqICoqSW1wb3J0YW50IGluZm9ybWF0aW9uIGFib3V0IEpXVHM6KipcclxuICAgICAqIC0gKipEbyBub3QgZXhwb3NlIEpXVHMgdG8gdXNlcnMhKiogQW55b25lIHdpdGggYWNjZXNzIHRvIG9uZSBvZiB5b3VyIEpXVHMgd2lsbCBiZSBhYmxlIHRvIGNvbm5lY3QgdG8geW91ciBIaWdoIEZpZGVsaXR5IFNwYXRpYWwgQXVkaW8gQVBJIFNlcnZlci5cclxuICAgICAqIC0gSW4geW91ciBhcHBsaWNhdGlvbidzIHByb2R1Y3Rpb24gZW52aXJvbm1lbnQsIGVhY2ggY2xpZW50IHJ1bm5pbmcgeW91ciBhcHAgY29kZSBzaG91bGQgY29ubmVjdCB0byB0aGUgSGlnaCBGaWRlbGl0eSBTcGF0aWFsIEF1ZGlvIFNlcnZlciB3aXRoIGEgdW5pcXVlIEpXVC5cclxuICAgICAqIEluIHRoZSBjYXNlIG9mIGEgV2ViIGFwcGxpY2F0aW9uLCB5b3VyIGFwcGxpY2F0aW9uIHNlcnZlciBjb2RlIHNob3VsZCBnZW5lcmF0ZSBhIEpXVCBhc3NvY2lhdGVkIHdpdGggdGhlIHVzZXIgcmVxdWVzdGluZyB5b3VyIFdlYiBhcHBsaWNhdGlvbi5cclxuICAgICAqIFxyXG4gICAgICogVG8gZ2VuZXJhdGUgYSBKV1QgZm9yIHVzZSB3aXRoIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIEFQSTpcclxuICAgICAqIDEuIEhlYWQgdG8ge0BsaW5rIGh0dHBzOi8vand0LmlvL30gdG8gZmluZCB0aGUgYXBwcm9wcmlhdGUgbGlicmFyeSBmb3IgeW91ciBsYW5nYXVnZS5cclxuICAgICAqICAgICBhLiBGb3IgTm9kZUpTIGFwcGxpY2F0aW9ucyBhbmQgV2ViIGFwcGxpY2F0aW9ucyBjb21waWxpZWQgZnJvbSBOb2RlSlMgY29kZSwgd2UgcmVjb21tZW5kIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9qb3NlfGpvc2V9LlxyXG4gICAgICogMi4gVXNpbmcgdGhlIHtAbGluayBodHRwczovL2FjY291bnQuaGlnaGZpZGVsaXR5LmNvbS9kZXYvYWNjb3VudHxIaWdoIEZpZGVsaXR5IEF1ZGlvIEFQSSBEZXZlbG9wZXIgQ29uc29sZX0sXHJcbiAgICAgKiBvYnRhaW4geW91ciBBcHAgSUQsIFNwYWNlIElELCBhbmQgQXBwIFNlY3JldC5cclxuICAgICAqIDMuIENyZWF0ZSB5b3VyIHVzZXIncyBKV1QgdXNpbmcgdGhlIGFwcHJvcHJpYXRlIGxpYnJhcnksIHBhc3NpbmcgeW91ciBBcHAgSUQsIFNwYWNlIElELCBhbmQgQXBwIFNlY3JldC4gSGVyZSBpcyBhbiBleGFtcGxlIG9mIHdoYXQgdGhhdCBtaWdodCBsb29rIGxpa2UsIHVzaW5nIE5vZGVKUyBhbmQgYGpvc2VgOlxyXG4gICAgICogICAgIGBgYFxyXG4gICAgICogaGlGaVNhbXBsZUpXVCA9IGF3YWl0IG5ldyBTaWduSldUKHtcclxuICAgICAqICAgICBcImFwcF9pZFwiOiBBUFBfSUQsXHJcbiAgICAgKiAgICAgXCJzcGFjZV9pZFwiOiBTUEFDRV9JRFxyXG4gICAgICogfSlcclxuICAgICAqIC5zZXRQcm90ZWN0ZWRIZWFkZXIoeyBhbGc6ICdIUzI1NicsIHR5cDogJ0pXVCcgfSlcclxuICAgICAqIC5zaWduKGNyeXB0by5jcmVhdGVTZWNyZXRLZXkoQnVmZmVyLmZyb20oQVBQX1NFQ1JFVCwgXCJ1dGY4XCIpKSk7XHJcbiAgICAgKiAgICAgYGBgXHJcbiAgICAgKiBQbGVhc2UgcmVmZXJlbmNlIG91ciB7QGxpbmsgaHR0cHM6Ly93d3cuaGlnaGZpZGVsaXR5LmNvbS9hcGkvZ3VpZGVzL21pc2MvZ2V0QUpXVHxcIkdldCBhIEpXVFwiIGd1aWRlfSBmb3IgYWRkaXRpb25hbCBjb250ZXh0LlxyXG4gICAgICogNC4gUGFzcyB0aGUgY3JlYXRlZCBKV1QgdG8gYGNvbm5lY3RUb0hpRmlBdWRpb0FQSVNlcnZlcigpYC5cclxuICAgICAqIFxyXG4gICAgICogQXMgb2YgMjAyMS0wMS0yMSwgd2UndmUgYWRkZWQgY29kZSBpbiB0aGlzIGZ1bmN0aW9uIHdoaWNoLCBpbiB0aGUgYnJvd3NlciBjb250ZXh0LCBzZWFyY2hlcyBmb3IgYSBgdG9rZW5gIFVSTCBxdWVyeSBwYXJhbWV0ZXIgYW5kLCBpZiBhIEpXVFxyXG4gICAgICogaXNuJ3Qgc3VwcGxpZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhpcyBmdW5jdGlvbiwgdXNlcyB0aGUgdmFsdWUgb2YgdGhhdCBgdG9rZW5gIFVSTCBxdWVyeSBwYXJhbWV0ZXIgYXMgdGhlIEpXVC5cclxuICAgICAqIFdlIHNob3VsZCByZW1vdmUgdGhhdCBsYXRlciwgYmVjYXVzZSB3ZSBhbG1vc3QgY2VydGFpbmx5IGRvbid0IHdhbnQgdGhpcyB0byBzdGF5IGluIHRoZSBBUEkgY29kZSwgYnV0IGl0J3MgX3ZlcnlfIGNvbnZlbmllbnQgZm9yIHNhbXBsZSBhcHBzIGZvciByaWdodCBub3cuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YWNrTmFtZSBUaGUgV2ViU29ja2V0IGFkZHJlc3MgdG8gd2hpY2ggd2UgbWFrZSBvdXIgV2ViUlRDIHNpZ25hbGluZyBjb25uZWN0aW9uIGlzIGRlY2lkZWQgYmFzZWQgb24gdGhlIGZvbGxvd2luZyBoZWlyYXJjaGFsIGxvZ2ljOlxyXG4gICAgICogMS4gSWYgdGhlIGNvZGUgaXMgcnVubmluZyBpbiB0aGUgYnJvd3NlciBjb250ZXh0LCBhbmQgdGhlIGJyb3dzZXIncyBVUkwgcXVlcnkgcGFyYW1ldGVycyBjb250YWlucyBhIGA/c3RhY2s9PHN0YWNrTmFtZT5gIHF1ZXJ5IHBhcmFtZXRlciwgXHJcbiAgICAgKiB0aGUgV2ViUlRDIHNpZ25hbGluZyBhZGRyZXNzIHdpbGwgYmUgYmFzZWQgb2ZmIG9mIHRoaXMgYHN0YWNrTmFtZWAgb3IgYHN0YWNrVVJMYC4gU3RhY2sgbmFtZXMgYXJlIHVzZWQgaW50ZXJuYWxseSBieSBIaWdoIEZpZGVsaXR5IGRldmVsb3BlcnMgd2hlbiB0ZXN0aW5nIG5ldyBzZXJ2ZXItc2lkZSBjb2RlLlxyXG4gICAgICogICAgIC0gSWYgdGhlIHBhc3NlZCBgc3RhY2tOYW1lYCBpcyBhIFVSTCwgdGhhdCBVUkwgd2lsbCBiZSB1c2VkIGFzIHRoZSBXZWJSVEMgU2lnbmFsaW5nIEFkZHJlc3MgZGlyZWN0bHkuXHJcbiAgICAgKiAyLiBJZiB0aGUgY29kZSBpcyBydW5uaW5nIGluIHRoZSBicm93c2VyIGNvbnRleHQsIGFuZCB0aGUgYnJvd3NlcidzIGN1cnJlbnQgbG9jYXRpb24ncyBob3N0bmFtZSBjb250YWlucyBgaGlnaGZpZGVsaXR5LmlvYCAoYSBob3N0bmFtZSBmb3IgaW50ZXJuYWwgdXNlIG9ubHkpLFxyXG4gICAgICogaXQgaXMgdmVyeSBsaWtlbHkgdGhhdCB3ZSBhcmUgcnVubmluZyBhIHRlc3QgaW4gYSBicm93c2VyLiBUZXN0cyBydW5uaW5nIGluIGEgYnJvd3NlciBmcm9tIHRoYXQgaG9zdG5hbWUgc2hvdWxkIGFzc3VtZSB0aGF0IHRoZSBXZWJSVEMgU2lnbmFsaW5nIEFkZHJlc3NcclxuICAgICAqIGlzIGF0IHRoZSBzYW1lIGhvc3QgZnJvbSB3aGljaCB0aGUgdGVzdCBpcyBzZXJ2ZWQuXHJcbiAgICAgKiAzLiBJZiB0aGUgY29kZSBpcyBydW5uaW5nIGluIHRoZSBicm93c2VyIGNvbnRleHQsIGFuZCBvdXIgY29kZSBjb21waWxhdGlvbiBwcm9jZXNzZXMgaGF2ZSBzcGVjaWZpZWQgdGhlIGJ1aWxkIG1vZGUgYXMgXCJwcm9kdWN0aW9uXCIsIHdlIHNob3VsZCB1c2UgdGhlIHByb2R1Y3Rpb25cclxuICAgICAqIFdlYlJUQyBzaWduYWxpbmcgY29ubmVjdGlvbiBhZGRyZXNzLlxyXG4gICAgICogNC4gSWYgYSBkZXZlbG9wZXIgaGFzIHBhc3NlZCBhIGBzdGFja05hbWVgIHBhcmFtZXRlciBpbnRvIHRoaXMgYGNvbm5lY3RUb0hpRmlBdWRpb0FQSVNlcnZlcigpYCBjYWxsLCB1c2UgYSBXZWJSVEMgc2lnbmFsaW5nIGFkZHJlc3MgYmFzZWQgb24gdGhhdCBgc3RhY2tOYW1lYC5cclxuICAgICAqICAgICAtIElmIHRoZSBwYXNzZWQgYHN0YWNrTmFtZWAgaXMgYSBVUkwsIHRoYXQgVVJMIHdpbGwgYmUgdXNlZCBhcyB0aGUgV2ViUlRDIFNpZ25hbGluZyBBZGRyZXNzIGRpcmVjdGx5LlxyXG4gICAgICogNS4gSWYgdGhlIGNvZGUgaXMgcnVubmluZyBpbiB0aGUgTm9kZUpTIGNvbnRleHQsIHdlIHdpbGwgdXNlIHRoZSBcInByb2R1Y3Rpb25cIiBgc3RhY2tOYW1lYCwgYW5kIHVzZSBhIFdlYlJUQyBzaWduYWxpbmcgYWRkcmVzcyBiYXNlZCBvbiB0aGF0IGBzdGFja05hbWVgLlxyXG4gICAgICogNi4gSWYgbm9uZSBvZiB0aGUgYWJvdmUgbG9naWMgYXBwbGllcywgd2Ugd2lsbCB1c2UgdGhlIGRlZmF1bHQgXCJzdGFnaW5nXCIgV2ViUlRDIHNpZ25hbGluZyBjb25uZWN0aW9uIGFkZHJlc3MuXHJcbiAgICAgKiBcclxuICAgICAqIEByZXR1cm5zIElmIHRoaXMgb3BlcmF0aW9uIGlzIHN1Y2Nlc3NmdWwsIHRoZSBQcm9taXNlIHdpbGwgcmVzb2x2ZSB3aXRoIGB7IHN1Y2Nlc3M6IHRydWUsIGF1ZGlvbmV0SW5pdFJlc3BvbnNlOiA8VGhlIHJlc3BvbnNlIHRvIGBhdWRpb25ldC5pbml0YCBmcm9tIHRoZSBzZXJ2ZXIgaW4gT2JqZWN0IGZvcm1hdD59YC5cclxuICAgICAqIElmIHVuc3VjY2Vzc2Z1bCwgdGhlIFByb21pc2Ugd2lsbCByZWplY3Qgd2l0aCBgeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IDxhbiBlcnJvciBtZXNzYWdlPiB9YC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgY29ubmVjdFRvSGlGaUF1ZGlvQVBJU2VydmVyKGhpZmlBdXRoSldUOiBzdHJpbmcsIHN0YWNrTmFtZT86IHN0cmluZyk6IFByb21pc2U8YW55PiB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9taXhlclNlc3Npb24pIHtcclxuICAgICAgICAgICAgbGV0IGVyck1zZyA9IGBcXGB0aGlzLl9taXhlclNlc3Npb25cXGAgaXMgZmFsc2V5IWA7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJNc2dcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbWl4ZXJDb25uZWN0aW9uUmVzcG9uc2U7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gVE9ETzogUmV2aXNpdCB0aGlzIGNodW5rIG9mIGNvZGUgbGF0ZXIuIFdlIGFsbW9zdCBjZXJ0YWlubHkgZG9uJ3Qgd2FudCB0aGlzIHRvIHN0YXkgaW4gdGhlIEFQSSBjb2RlLFxyXG4gICAgICAgICAgICAvLyBidXQgaXQncyBfdmVyeV8gY29udmVuaWVudCBmb3Igc2FtcGxlIGFwcHMgZm9yIHJpZ2h0IG5vdy5cclxuICAgICAgICAgICAgbGV0IHBhcmFtcyA9IFVSTFNlYXJjaFBhcmFtcyAmJiAodHlwZW9mIChsb2NhdGlvbikgIT09ICd1bmRlZmluZWQnKSAmJiBuZXcgVVJMU2VhcmNoUGFyYW1zKGxvY2F0aW9uLnNlYXJjaCk7XHJcbiAgICAgICAgICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLmhhcyhcInRva2VuXCIpICYmICghaGlmaUF1dGhKV1QgfHwgaGlmaUF1dGhKV1QubGVuZ3RoID09PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgaGlmaUF1dGhKV1QgPSBwYXJhbXMuZ2V0KFwidG9rZW5cIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghaGlmaUF1dGhKV1QgfHwgaGlmaUF1dGhKV1QubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZXJyTXNnID0gYENhbid0IGNvbm5lY3QgdG8gQVBJIFNlcnZlcjogTm8gSldULlxcblNlZSB0aGlzIGd1aWRlIGZvciBpbmZvcm1hdGlvbiBhYm91dCBvYnRhaW5pbmcgYSBKV1Q6XFxuaHR0cHM6Ly93d3cuaGlnaGZpZGVsaXR5LmNvbS9hcGkvZ3VpZGVzL21pc2MvZ2V0QUpXVGA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJNc2dcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgd2ViUlRDU2lnbmFsaW5nQWRkcmVzcyA9IFwid3NzOi8vbG9hZGJhbGFuY2VyLSRTVEFDS05BTUUuaGlnaGZpZGVsaXR5LmlvOjgwMDEvP3Rva2VuPVwiO1xyXG4gICAgICAgICAgICBsZXQgaXNCcm93c2VyQ29udGV4dCA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJztcclxuICAgICAgICAgICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMuaGFzKFwic3RhY2tcIikpIHtcclxuICAgICAgICAgICAgICAgIGxldCB1cmw7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVybCA9IG5ldyBVUkwocGFyYW1zLmdldChcInN0YWNrXCIpKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh1cmwpIHtcclxuICAgICAgICAgICAgICAgICAgICB3ZWJSVENTaWduYWxpbmdBZGRyZXNzID0gdXJsLmhyZWY7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHdlYlJUQ1NpZ25hbGluZ0FkZHJlc3MgPSB3ZWJSVENTaWduYWxpbmdBZGRyZXNzLnJlcGxhY2UoJyRTVEFDS05BTUUnLCBwYXJhbXMuZ2V0KFwic3RhY2tcIikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQnJvd3NlckNvbnRleHQgJiYgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lLmluZGV4T2YoXCJoaWdoZmlkZWxpdHkuaW9cIikgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgd2ViUlRDU2lnbmFsaW5nQWRkcmVzcyA9IGB3c3M6Ly8ke3dpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZX06ODAwMS8/dG9rZW49YDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0Jyb3dzZXJDb250ZXh0ICYmIEJVSUxEX0VOVklST05NRU5UICYmIEJVSUxEX0VOVklST05NRU5UID09PSBcInByb2RcIikge1xyXG4gICAgICAgICAgICAgICAgd2ViUlRDU2lnbmFsaW5nQWRkcmVzcyA9IGAke0hpRmlDb25zdGFudHMuREVGQVVMVF9QUk9EX0hJR0hfRklERUxJVFlfRU5EUE9JTlR9Lz90b2tlbj1gO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YWNrTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHVybDtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gbmV3IFVSTChzdGFja05hbWUpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHVybCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdlYlJUQ1NpZ25hbGluZ0FkZHJlc3MgPSB1cmwuaHJlZjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2ViUlRDU2lnbmFsaW5nQWRkcmVzcyA9IHdlYlJUQ1NpZ25hbGluZ0FkZHJlc3MucmVwbGFjZSgnJFNUQUNLTkFNRScsIHN0YWNrTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzQnJvd3NlckNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIHdlYlJUQ1NpZ25hbGluZ0FkZHJlc3MgPSBgJHtIaUZpQ29uc3RhbnRzLkRFRkFVTFRfUFJPRF9ISUdIX0ZJREVMSVRZX0VORFBPSU5UfS8/dG9rZW49YDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHdlYlJUQ1NpZ25hbGluZ0FkZHJlc3MgPSB3ZWJSVENTaWduYWxpbmdBZGRyZXNzLnJlcGxhY2UoJyRTVEFDS05BTUUnLCAnYXBpLXN0YWdpbmctMDInKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fbWl4ZXJTZXNzaW9uLndlYlJUQ0FkZHJlc3MgPSBgJHt3ZWJSVENTaWduYWxpbmdBZGRyZXNzfSR7aGlmaUF1dGhKV1R9YDtcclxuXHJcbiAgICAgICAgICAgIEhpRmlMb2dnZXIubG9nKGBVc2luZyBXZWJSVEMgU2lnbmFsaW5nIEFkZHJlc3M6XFxuJHt3ZWJSVENTaWduYWxpbmdBZGRyZXNzfTx0b2tlbiByZWRhY3RlZD5gKTtcclxuXHJcbiAgICAgICAgICAgIG1peGVyQ29ubmVjdGlvblJlc3BvbnNlID0gYXdhaXQgdGhpcy5fbWl4ZXJTZXNzaW9uLmNvbm5lY3QoKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvckNvbm5lY3RpbmdUb01peGVyKSB7XHJcbiAgICAgICAgICAgIGxldCBlcnJNc2cgPSBgRXJyb3Igd2hlbiBjb25uZWN0aW5nIHRvIG1peGVyISBFcnJvcjpcXG4ke2Vycm9yQ29ubmVjdGluZ1RvTWl4ZXJ9YDtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHtcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyck1zZ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YVRvU2VydmVyKHRydWUpO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xyXG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICAgICAgICBhdWRpb25ldEluaXRSZXNwb25zZTogbWl4ZXJDb25uZWN0aW9uUmVzcG9uc2UuYXVkaW9uZXRJbml0UmVzcG9uc2VcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERpc2Nvbm5lY3RzIGZyb20gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJLiBBZnRlciB0aGlzIGNhbGwsIHVzZXIgZGF0YSB3aWxsIG5vIGxvbmdlciBiZSB0cmFuc21pdHRlZCB0byBIaWdoIEZpZGVsaXR5LCB0aGUgYXVkaW9cclxuICAgICAqIGlucHV0IHN0cmVhbSB3aWxsIG5vdCBiZSB0cmFuc21pdHRlZCB0byBIaWdoIEZpZGVsaXR5LCBhbmQgdGhlIHVzZXIgd2lsbCBubyBsb25nZXIgYmUgYWJsZSB0byBoZWFyIHRoZSBhdWRpbyBzdHJlYW0gZnJvbSBIaWdoIEZpZGVsaXR5LlxyXG4gICAgICovXHJcbiAgICBhc3luYyBkaXNjb25uZWN0RnJvbUhpRmlBdWRpb0FQSVNlcnZlcigpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgICAgIGlmICghdGhpcy5fbWl4ZXJTZXNzaW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYE5vIG1peGVyIHNlc3Npb24gZnJvbSB3aGljaCB3ZSBjYW4gZGlzY29ubmVjdCFgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl9taXhlclNlc3Npb24uZGlzY29ubmVjdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIGZpbmFsIG1peGVkIGF1ZGlvIGBNZWRpYVN0cmVhbWAgY29taW5nIGZyb20gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gU2VydmVyLlxyXG4gICAgICovXHJcbiAgICBnZXRPdXRwdXRBdWRpb01lZGlhU3RyZWFtKCk6IE1lZGlhU3RyZWFtIHtcclxuICAgICAgICBpZiAodGhpcy5fbWl4ZXJTZXNzaW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9taXhlclNlc3Npb24uZ2V0T3V0cHV0QXVkaW9NZWRpYVN0cmVhbSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIHNldCB0aGUgYE1lZGlhU3RyZWFtYCBhc3NvY2lhdGVkIHdpdGggdGhlIHVzZXIuIFRoaXMgYE1lZGlhU3RyZWFtYCB3aWxsIGJlIHNlbnQgdXAgdG8gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gU2VydmVycyBhbmRcclxuICAgICAqIG1peGVkIHdpdGggb3RoZXIgdXNlcnMnIGF1ZGlvIHN0cmVhbXMuIFRoZSByZXN1bHRhbnQgbWl4ZWQgc3RyZWFtIHdpbGwgYmUgc2VudCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogKipCZSBtaW5kZnVsKiogb2Ygc3VwcGx5aW5nIHRoaXMgc3RyZWFtIHVwb24gaW5pdGlhbCBjb25uZWN0aW9uIHdoZW4geW91IGFudGljaXBhdGUgdGhhdCB0aGUgdXNlciBpcyB1c2luZyBCbHVldG9vdGggYXVkaW9cclxuICAgICAqIGlucHV0IGFuZCBCbHVldG9vdGggYXVkaW8gb3V0cHV0IHNpbXVsdGFuZW91c2x5LiBNYW55IEJsdWV0b290aCBhdWRpbyBkZXZpY2VzIGRvIG5vdCBzdXBwb3J0IHN0ZXJlbyAoc3BhdGlhbGl6ZWQpIGF1ZGlvXHJcbiAgICAgKiBvdXRwdXQgYW5kIG1pY3JvcGhvbmUgYXVkaW8gaW5wdXQgc2ltdWx0YW5lb3VzbHksIGluY2x1ZGluZyB0aGUgcG9wdWxhciBjb21iaW5hdGlvbiBvZiBhbiBpUGhvbmUgYW5kIEFpclBvZHMuXHJcbiAgICAgKiBZb3VyIHVzZXJzIG1heSBoYXZlIGEgYmV0dGVyIGV4cGVyaWVuY2UgaWYgdGhleSBqb2luIHRoZSBTZXJ2ZXIgaW4gXCJsaXN0ZW4tb25seVwiIG1vZGUgLSBpLmUuIHdpdGhvdXQgbWljcm9waG9uZSBpbnB1dCAtIGFuZCB0aGVuXHJcbiAgICAgKiBhcmUgYXNrZWQgZm9yIG1pY3JvcGhvbmUgcGVybWlzc2lvbiBsYXRlciAod2hpY2ggd2lsbCBmb3JjZSB0aGVpciBCbHVldG9vdGggb3V0cHV0IGRldmljZSBpbnRvIGEgbG93ZXItcXVhbGl0eSwgdW5zcGF0aWFsaXplZCBtb25vIG1vZGUpLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0gbmV3SW5wdXRBdWRpb01lZGlhU3RyZWFtIC0gVGhlIG5ldyBgTWVkaWFTdHJlYW1gIHRvIHNlbmQgdG8gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gU2VydmVyLiBJZiB0aGlzXHJcbiAgICAgKiBpcyBzZXQgdG8gYW4gYHVuZGVmaW5lZGAgdmFsdWUsIHRoZSBleGlzdGluZyBpbnB1dCBzdHJlYW0gKGlmIG9uZSBpcyBzZXQpIHdpbGwgYmUgY2xlYXJlZC5cclxuICAgICAqIEBwYXJhbSBpc1N0ZXJlbyAtIGB0cnVlYCBpZiB0aGUgaW5wdXQgc3RyZWFtIHNob3VsZCBiZSB0cmVhdGVkIGFzIHN0ZXJlbywgYGZhbHNlYCBmb3IgbW9ubyAoZGVmYXVsdCkuXHJcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG5ldyBgTWVkaWFTdHJlYW1gIHdhcyBzdWNjZXNzZnVsbHkgc2V0LCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgc2V0SW5wdXRBdWRpb01lZGlhU3RyZWFtKG5ld0lucHV0QXVkaW9NZWRpYVN0cmVhbTogTWVkaWFTdHJlYW0sIGlzU3RlcmVvOiBib29sZWFuID0gZmFsc2UpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgICAgICBjb25zdCByZXR2YWwgPSBhd2FpdCB0aGlzLl9taXhlclNlc3Npb24uc2V0UkFWSUlucHV0QXVkaW8obmV3SW5wdXRBdWRpb01lZGlhU3RyZWFtLCBpc1N0ZXJlbyk7XHJcbiAgICAgICAgaWYgKHJldHZhbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pbnB1dEF1ZGlvTWVkaWFTdHJlYW0gPSBuZXdJbnB1dEF1ZGlvTWVkaWFTdHJlYW07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgSGlGaUxvZ2dlci53YXJuKGBFcnJvciB0cnlpbmcgdG8gc2V0UkFWSUlucHV0QXVkaW8gb24gdGhpcy5fbWl4ZXJTZXNzaW9uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2UgdGhpcyBmdW5jdGlvbiB0byBzZXQgd2hldGhlciBvciBub3QgdGhlIHVzZXIncyBpbnB1dCBhdWRpbyBgTWVkaWFTdHJlYW1gIHNob3VsZCBiZSBcIm11dGVkXCIuIFxyXG4gICAgICogQSBtdXRlZCBzdHJlYW0gd2lsbCBoYXZlIHRoZSBgZW5hYmxlZGAgcHJvcGVydHkgb2YgZWFjaCBvZiBpdHMgYE1lZGlhU3RyZWFtVHJhY2tgcyBzZXQgdG8gYGZhbHNlYFxyXG4gICAgICogKGFuZCBhbiB1bm11dGVkIHN0cmVhbSAtLSB0aGUgZGVmYXVsdCAtLSB3aWxsIGhhdmUgdGhlIGBlbmFibGVkYCBwcm9wZXJ0eSBzZXQgdG8gYHRydWVgKS4gQmVcclxuICAgICAqIGF3YXJlIHRoYXQgaWYgeW91IGFyZSB1c2luZyB0aGUgc2FtZSBgTWVkaWFTdHJlYW1gIG9iamVjdCBpbiBvdGhlciB3YXlzLCBpdCB3aWxsIGJlIGFmZmVjdGVkIGJ5XHJcbiAgICAgKiBjYWxsaW5nIHRoaXMgbWV0aG9kLiBTbywgaWYgeW91IHdvdWxkIGxpa2UgdG8gbXV0ZS91bm11dGUgdGhlIGlucHV0IGF1ZGlvIHN0cmVhbSBzZXBhcmF0ZWx5IGZvciB0aGVcclxuICAgICAqIEhpZ2ggRmlkZWxpdHkgYXVkaW8gdnMuIHNvbWUgb3RoZXIgdXNlIG9mIGl0LCBpdCBpcyByZWNvbW1lbmRlZCB0byBjbG9uZSB0aGUgYXVkaW8gc3RyZWFtIHNlcGFyYXRlbHlcclxuICAgICAqIGZvciBlYWNoIHVzZS5cclxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3RyZWFtIHdhcyBzdWNjZXNzZnVsbHkgbXV0ZWQvdW5tdXRlZCwgYGZhbHNlYCBpZiBpdCB3YXMgbm90LiAoVGhlIHVzZXIgc2hvdWxkXHJcbiAgICAgKiBhc3N1bWUgdGhhdCBpZiB0aGlzIHJldHVybnMgYGZhbHNlYCwgbm8gY2hhbmdlIHdhcyBtYWRlIHRvIHRoZSBtdXRlICh0cmFjayBlbmFibGVkKSBzdGF0ZSBvZiB0aGUgc3RyZWFtLilcclxuICAgICAqL1xyXG4gICAgYXN5bmMgc2V0SW5wdXRBdWRpb011dGVkKGlzTXV0ZWQ6IGJvb2xlYW4pOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgICAgICBpZiAodGhpcy5fbWl4ZXJTZXNzaW9uKSB7XHJcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZGVidWcoYFNldHRpbmcgbXV0ZSBzdGF0ZSB0byA6ICR7aXNNdXRlZH1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX21peGVyU2Vzc2lvbi5zZXRJbnB1dEF1ZGlvTXV0ZWQoaXNNdXRlZCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgSGlGaUxvZ2dlci53YXJuKGBDb3VsZG4ndCBzZXQgbXV0ZSBzdGF0ZTogTm8gXFxgX21peGVyU2Vzc2lvblxcYC5gKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIEEgYnVuY2ggb2YgaW5mbyBhYm91dCB0aGlzIGBIaUZpQ29tbXVuaWNhdG9yYCBpbnN0YW50aWF0aW9uLCBpbmNsdWRpbmcgU2VydmVyIFZlcnNpb24uXHJcbiAgICAgKi9cclxuICAgIGdldENvbW11bmljYXRvckluZm8oKTogYW55IHtcclxuICAgICAgICBsZXQgcmV0dmFsOiBhbnkgPSB7XHJcbiAgICAgICAgICAgIFwiY2xpZW50SW5mb1wiOiB7XHJcbiAgICAgICAgICAgICAgICBcImlucHV0QXVkaW9TdHJlYW1TZXRcIjogISF0aGlzLl9pbnB1dEF1ZGlvTWVkaWFTdHJlYW0sXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBsZXQgaXNCcm93c2VyQ29udGV4dCA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJztcclxuICAgICAgICBpZiAoaXNCcm93c2VyQ29udGV4dCAmJiBISUZJX0FQSV9WRVJTSU9OKSB7XHJcbiAgICAgICAgICAgIHJldHZhbC5jbGllbnRJbmZvW1wiYXBpVmVyc2lvblwiXSA9IEhJRklfQVBJX1ZFUlNJT047XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5fbWl4ZXJTZXNzaW9uICYmIHRoaXMuX21peGVyU2Vzc2lvbi5taXhlckluZm8pIHtcclxuICAgICAgICAgICAgcmV0dmFsW1wic2VydmVySW5mb1wiXSA9IHRoaXMuX21peGVyU2Vzc2lvbi5taXhlckluZm87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnQgY29sbGVjdGluZyBkYXRhIGFib3V0IHRoZSBXZWJSVEMgY29ubmVjdGlvbiBiZXR3ZWVuIENsaWVudCBhbmQgU2VydmVyLlxyXG4gICAgICogTm90ZSB0aGF0IHRoZSBkYXRhIGluc2lkZSB0aGUgcmVwb3J0cyBwZXJ0YWlucyBvbmx5IHRvIHBheWxvYWQgZGF0YSBpbnRlcm5hbCB0byB0aGUgV2ViUlRDIGNvbm5lY3Rpb25cclxuICAgICAqIGFuZCBkb2VzIG5vdCBpbmNsdWRlIF90b3RhbF8gZGF0YSBzZW50IG92ZXIgdGhlIHdpcmUgb3IgcmVjZWl2ZWQgb3ZlciB0aGUgd2lyZSBpbiB5b3VyIGFwcGxpY2F0aW9uLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25zIHdpbGwgYmUgcHJvdmlkZWQgdHdvIEFycmF5IGFyZ3VtZW50czogYHN0YXRzYCBhbmQgYHByZXZTdGF0c2AuXHJcbiAgICAgKiBFYWNoIG9mIHRob3NlIEFycmF5IGl0ZW1zIGNvbnRhaW5zIG9uZSBvciBtb3JlIE9iamVjdHMsIHdoaWNoIGFyZSByZXBvcnRzIG9mIFdlYlJUQyBzdGF0cyBkYXRhLFxyXG4gICAgICogaW5jbHVkaW5nIGRhdGEgc3VjaCBhcyBcImEgdGltZXN0YW1wXCIsIFwidGhlIG51bWJlciBvZiBieXRlcyByZWNlaXZlZCBzaW5jZSB0aGUgbGFzdCByZXBvcnRcIiBhbmQgXCJjdXJyZW50IGppdHRlciBidWZmZXIgZGVsYXlcIi5cclxuICAgICAqL1xyXG4gICAgc3RhcnRDb2xsZWN0aW5nV2ViUlRDU3RhdHMoY2FsbGJhY2s6IEZ1bmN0aW9uKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9taXhlclNlc3Npb24pIHtcclxuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgQ291bGRuJ3Qgc3RhcnQgY29sbGVjdGluZyBXZWJSVEMgU3RhdHM6IE5vIFxcYF9taXhlclNlc3Npb25cXGAhYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9taXhlclNlc3Npb24uc3RhcnRDb2xsZWN0aW5nV2ViUlRDU3RhdHMoY2FsbGJhY2spO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RvcCBjb2xsZWN0aW5nIGRhdGEgYWJvdXQgdGhlIFdlYlJUQyBjb25uZWN0aW9uIGJldHdlZW4gQ2xpZW50IGFuZCBTZXJ2ZXIuXHJcbiAgICAgKi9cclxuICAgIHN0b3BDb2xsZWN0aW5nV2ViUlRDU3RhdHMoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9taXhlclNlc3Npb24pIHtcclxuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgQ291bGRuJ3Qgc3RvcCBjb2xsZWN0aW5nIFdlYlJUQyBTdGF0czogTm8gXFxgX21peGVyU2Vzc2lvblxcYCFgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX21peGVyU2Vzc2lvbi5zdG9wQ29sbGVjdGluZ1dlYlJUQ1N0YXRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBpbnRlcm5hbCBjb3B5IG9mIHRoZSBVc2VyIERhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSB1c2VyIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNsaWVudC4gRG9lcyAqKk5PVCoqIHVwZGF0ZVxyXG4gICAgICogdGhlIHVzZXIgZGF0YSBvbiB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBBUEkgc2VydmVyLiBUaGVyZSBhcmUgbm8gZ29vZCByZWFzb25zIGZvciBhIGNsaWVudCB0byBjYWxsIHRoaXMgZnVuY3Rpb25cclxuICAgICAqIGFuZCBfbm90XyB1cGRhdGUgdGhlIHNlcnZlciBVc2VyIERhdGEsIGFuZCB0aHVzIHRoaXMgZnVuY3Rpb24gaXMgYHByaXZhdGVgLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0gX19uYW1lZFBhcmFtZXRlcnNcclxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiAtIFRoZSBuZXcgcG9zaXRpb24gb2YgdGhlIHVzZXIuXHJcbiAgICAgKiBAcGFyYW0gb3JpZW50YXRpb25FdWxlciAtIFRoZSBuZXcgb3JpZW50YXRpb25FdWxlciBvZiB0aGUgdXNlci5cclxuICAgICAqIEBwYXJhbSBvcmllbnRhdGlvblF1YXQgLSBUaGUgbmV3IG9yaWVudGF0aW9uUXVhdCBvZiB0aGUgdXNlci5cclxuICAgICAqIEBwYXJhbSBoaUZpR2FpbiAtIFRoaXMgdmFsdWUgYWZmZWN0cyBob3cgbG91ZCBVc2VyIEEgd2lsbCBzb3VuZCB0byBVc2VyIEIgYXQgYSBnaXZlbiBkaXN0YW5jZSBpbiAzRCBzcGFjZS5cclxuICAgICAqIFRoaXMgdmFsdWUgYWxzbyBhZmZlY3RzIHRoZSBkaXN0YW5jZSBhdCB3aGljaCBVc2VyIEEgY2FuIGJlIGhlYXJkIGluIDNEIHNwYWNlLlxyXG4gICAgICogSGlnaGVyIHZhbHVlcyBmb3IgVXNlciBBIG1lYW5zIHRoYXQgVXNlciBBIHdpbGwgc291bmQgbG91ZGVyIHRvIG90aGVyIHVzZXJzIGFyb3VuZCBVc2VyIEEsIGFuZCBpdCBhbHNvIG1lYW5zIHRoYXQgVXNlciBBIHdpbGwgYmUgYXVkaWJsZSBmcm9tIGEgZ3JlYXRlciBkaXN0YW5jZS5cclxuICAgICAqIFRoZSBuZXcgaGlGaUdhaW4gb2YgdGhlIHVzZXIuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX3VwZGF0ZVVzZXJEYXRhKHsgcG9zaXRpb24sIG9yaWVudGF0aW9uRXVsZXIsIG9yaWVudGF0aW9uUXVhdCwgaGlGaUdhaW4gfTogeyBwb3NpdGlvbj86IFBvaW50M0QsIG9yaWVudGF0aW9uRXVsZXI/OiBPcmllbnRhdGlvbkV1bGVyM0QsIG9yaWVudGF0aW9uUXVhdD86IE9yaWVudGF0aW9uUXVhdDNELCBoaUZpR2Fpbj86IG51bWJlciB9ID0ge30pOiB2b2lkIHtcclxuICAgICAgICBpZiAocG9zaXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEucG9zaXRpb24gPSBuZXcgUG9pbnQzRCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi54ID0gcG9zaXRpb24ueCA/PyB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi54O1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi55ID0gcG9zaXRpb24ueSA/PyB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi55O1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi56ID0gcG9zaXRpb24ueiA/PyB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi56O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uRXVsZXIpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvbkV1bGVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvbkV1bGVyID0gbmV3IE9yaWVudGF0aW9uRXVsZXIzRCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvbkV1bGVyLnBpdGNoRGVncmVlcyA9IG9yaWVudGF0aW9uRXVsZXIucGl0Y2hEZWdyZWVzID8/IHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uRXVsZXIucGl0Y2hEZWdyZWVzO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvbkV1bGVyLnlhd0RlZ3JlZXMgPSBvcmllbnRhdGlvbkV1bGVyLnlhd0RlZ3JlZXMgPz8gdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25FdWxlci55YXdEZWdyZWVzO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvbkV1bGVyLnJvbGxEZWdyZWVzID0gb3JpZW50YXRpb25FdWxlci5yb2xsRGVncmVlcyA/PyB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvbkV1bGVyLnJvbGxEZWdyZWVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uUXVhdCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQudyA9IG9yaWVudGF0aW9uUXVhdC53ID8/IHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC53O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0LnggPSBvcmllbnRhdGlvblF1YXQueCA/PyB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQueDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC55ID0gb3JpZW50YXRpb25RdWF0LnkgPz8gdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0Lnk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQueiA9IG9yaWVudGF0aW9uUXVhdC56ID8/IHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC56O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0ID0gbmV3IE9yaWVudGF0aW9uUXVhdDNEKHtcclxuICAgICAgICAgICAgICAgICAgICBcIndcIjogb3JpZW50YXRpb25RdWF0LncsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ4XCI6IG9yaWVudGF0aW9uUXVhdC54LFxyXG4gICAgICAgICAgICAgICAgICAgIFwieVwiOiBvcmllbnRhdGlvblF1YXQueSxcclxuICAgICAgICAgICAgICAgICAgICBcInpcIjogb3JpZW50YXRpb25RdWF0LnosXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiAoaGlGaUdhaW4pID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhLmhpRmlHYWluID0gTWF0aC5tYXgoMCwgaGlGaUdhaW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyB0aGUgY2xpZW50c2lkZSByYXRlIGxpbWl0IHRpbWVvdXQgdXNlZCB0byBwcmV2ZW50IHVzZXIgZGF0YSBmcm9tIGJlaW5nIHNlbnQgdG8gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJIHNlcnZlciB0b28gb2Z0ZW4uXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX21heWJlQ2xlYXJSYXRlTGltaXRUaW1lb3V0KCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl90aW1lcnMudHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcnMudHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3RpbWVycy50cmFuc21pdFJhdGVMaW1pdFRpbWVvdXQgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2Uga2VlcCBhIGNsaWVudHNpZGUgY29weSBvZiB0aGUgZGF0YSB0aGF0IHdlIGxhc3QgdHJhbnNtaXR0ZWQgdG8gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJIHNlcnZlci4gV2UgdXNlIHRoaXMgZGF0YSB0b1xyXG4gICAgICogZW5zdXJlIHRoYXQgd2Ugb25seSBzZW5kIHRvIHRoZSBzZXJ2ZXIgdGhlIG1pbmltdW0gc2V0IG9mIGRhdGEgbmVjZXNzYXJ5IC0gaS5lLiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBkYXRhIGNvbnRhaW5lZCBvbiB0aGUgc2VydmVyXHJcbiAgICAgKiBhYm91dCB0aGUgdXNlciBhbmQgdGhlIG5ldyBkYXRhIHRoYXQgdGhlIGNsaWVudCBoYXMgbG9jYWxseS4gV2UgdXNlIHRoaXMgZnVuY3Rpb24gaGVyZSB0byB1cGRhdGUgdGhlIGNsaWVudHNpZGUgY29weSBvZiB0aGUgZGF0YVxyXG4gICAgICogdGhhdCB3ZSBsYXN0IHRyYW5zbWl0dGVkLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0gZGF0YUp1c3RUcmFuc21pdHRlZCAtIFRoZSBkYXRhIHRoYXQgd2UganVzdCB0cmFuc21pdHRlZCB0byB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBBUEkgc2VydmVyLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF91cGRhdGVMYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhKGRhdGFKdXN0VHJhbnNtaXR0ZWQ6IEhpRmlBdWRpb0FQSURhdGEpOiB2b2lkIHtcclxuICAgICAgICBpZiAoZGF0YUp1c3RUcmFuc21pdHRlZC5wb3NpdGlvbikge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEucG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEucG9zaXRpb24gPSBuZXcgUG9pbnQzRCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLnBvc2l0aW9uLnggPSBkYXRhSnVzdFRyYW5zbWl0dGVkLnBvc2l0aW9uLnggPz8gdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi54O1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLnBvc2l0aW9uLnkgPSBkYXRhSnVzdFRyYW5zbWl0dGVkLnBvc2l0aW9uLnkgPz8gdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi55O1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLnBvc2l0aW9uLnogPSBkYXRhSnVzdFRyYW5zbWl0dGVkLnBvc2l0aW9uLnogPz8gdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi56O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRhdGFKdXN0VHJhbnNtaXR0ZWQub3JpZW50YXRpb25FdWxlcikge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25FdWxlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvbkV1bGVyID0gbmV3IE9yaWVudGF0aW9uRXVsZXIzRCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uRXVsZXIucGl0Y2hEZWdyZWVzID0gZGF0YUp1c3RUcmFuc21pdHRlZC5vcmllbnRhdGlvbkV1bGVyLnBpdGNoRGVncmVlcyA/PyB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uRXVsZXIucGl0Y2hEZWdyZWVzO1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uRXVsZXIueWF3RGVncmVlcyA9IGRhdGFKdXN0VHJhbnNtaXR0ZWQub3JpZW50YXRpb25FdWxlci55YXdEZWdyZWVzID8/IHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25FdWxlci55YXdEZWdyZWVzO1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uRXVsZXIucm9sbERlZ3JlZXMgPSBkYXRhSnVzdFRyYW5zbWl0dGVkLm9yaWVudGF0aW9uRXVsZXIucm9sbERlZ3JlZXMgPz8gdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvbkV1bGVyLnJvbGxEZWdyZWVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRhdGFKdXN0VHJhbnNtaXR0ZWQub3JpZW50YXRpb25RdWF0KSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0ID0gbmV3IE9yaWVudGF0aW9uUXVhdDNEKHtcclxuICAgICAgICAgICAgICAgICAgICBcIndcIjogZGF0YUp1c3RUcmFuc21pdHRlZC5vcmllbnRhdGlvblF1YXQudyxcclxuICAgICAgICAgICAgICAgICAgICBcInhcIjogZGF0YUp1c3RUcmFuc21pdHRlZC5vcmllbnRhdGlvblF1YXQueCxcclxuICAgICAgICAgICAgICAgICAgICBcInlcIjogZGF0YUp1c3RUcmFuc21pdHRlZC5vcmllbnRhdGlvblF1YXQueSxcclxuICAgICAgICAgICAgICAgICAgICBcInpcIjogZGF0YUp1c3RUcmFuc21pdHRlZC5vcmllbnRhdGlvblF1YXQueixcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQudyA9IGRhdGFKdXN0VHJhbnNtaXR0ZWQub3JpZW50YXRpb25RdWF0Lnc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC54ID0gZGF0YUp1c3RUcmFuc21pdHRlZC5vcmllbnRhdGlvblF1YXQueDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0LnkgPSBkYXRhSnVzdFRyYW5zbWl0dGVkLm9yaWVudGF0aW9uUXVhdC55O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQueiA9IGRhdGFKdXN0VHJhbnNtaXR0ZWQub3JpZW50YXRpb25RdWF0Lno7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgKGRhdGFKdXN0VHJhbnNtaXR0ZWQuaGlGaUdhaW4pID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGFbXCJoaUZpR2FpblwiXSA9IGRhdGFKdXN0VHJhbnNtaXR0ZWQuaGlGaUdhaW47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRm9ybWF0cyB0aGUgbG9jYWwgdXNlciBkYXRhIHByb3Blcmx5LCB0aGVuIHNlbmRzIHRoYXQgdXNlciBkYXRhIHRvIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIEFQSSBzZXJ2ZXIuIFRoaXMgdHJhbnNmZXIgaXMgcmF0ZSBsaW1pdGVkLlxyXG4gICAgICogXHJcbiAgICAgKiBUaGVyZSBpcyBubyByZWFzb24gYSBsaWJyYXJ5IHVzZXIgd291bGQgbmVlZCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gd2l0aG91dCBhbHNvIHNpbXVsdGFuZW91c2x5IHVwZGF0aW5nIFVzZXIgRGF0YSwgc28gdGhpcyBmdW5jdGlvbiBpcyBgcHJpdmF0ZWAuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSBmb3JjZVRyYW5zbWl0IC0gYHRydWVgIGlmIHdlIHNob3VsZCBpZ25vcmUgdGhlIGNsaWVudHNpZGUgcmF0ZSBsaW1pdGVyIGFuZCBzZW5kIHRoZSBkYXRhIHJlZ2FyZGxlc3Mgb2YgaXRzIHN0YXR1czsgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAgICAgKiBAcmV0dXJucyBJZiB0aGlzIG9wZXJhdGlvbiBpcyBzdWNjZXNzZnVsLCByZXR1cm5zIGB7IHN1Y2Nlc3M6IHRydWUsIHJhd0RhdGFUcmFuc21pdHRlZDogPHRoZSByYXcgZGF0YSB0aGF0IHdhcyB0cmFuc21pdHRlZCB0byB0aGUgc2VydmVyPn1gLiBJZiB1bnN1Y2Nlc3NmdWwsIHJldHVybnNcclxuICAgICAqIGB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogPGFuIGVycm9yIG1lc3NhZ2U+IH1gLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF90cmFuc21pdEhpRmlBdWRpb0FQSURhdGFUb1NlcnZlcihmb3JjZVRyYW5zbWl0PzogYm9vbGVhbik6IGFueSB7XHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgYSBjYWxsZXIgY2FuJ3QgdHJhbnNtaXQgZGF0YSBmb3IgYW5vdGhlciBgdGhpcy50cmFuc21pdFJhdGVMaW1pdFRpbWVvdXRNU2AgbWlsbGlzZWNvbmRzLlxyXG4gICAgICAgIGlmICh0aGlzLl9taXhlclNlc3Npb24gJiYgKCF0aGlzLl90aW1lcnMudHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0IHx8IGZvcmNlVHJhbnNtaXQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbWVycy53YW50ZWRUb1RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9tYXliZUNsZWFyUmF0ZUxpbWl0VGltZW91dCgpO1xyXG4gICAgICAgICAgICBpZiAoIWZvcmNlVHJhbnNtaXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVycy50cmFuc21pdFJhdGVMaW1pdFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXliZUNsZWFyUmF0ZUxpbWl0VGltZW91dCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdGltZXJzLndhbnRlZFRvVHJhbnNtaXRIaUZpQXVkaW9BUElEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YVRvU2VydmVyKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIHRoaXMudHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0TVMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgZGF0YSB0byB0cmFuc21pdCwgd2hpY2ggaXMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbGFzdCBkYXRhIHdlIHRyYW5zbWl0dGVkXHJcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgY3VycmVudCBkYXRhIHdlIGhhdmUgc3RvcmVkLlxyXG4gICAgICAgICAgICBsZXQgZGVsdGEgPSB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLmRpZmYodGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEpO1xyXG4gICAgICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgdHJhbnNsYXRlIHRoZSBuZXcgYEhpRmlBdWRpb0FQSURhdGFgIG9iamVjdCBmcm9tIGFib3ZlIGludG8gc3RyaW5naWZpZWQgSlNPTiBkYXRhIGluIHRoZSBwcm9wZXIgZm9ybWF0LFxyXG4gICAgICAgICAgICAvLyB0aGVuIHNlbmQgdGhhdCBkYXRhIHRvIHRoZSBtaXhlci5cclxuICAgICAgICAgICAgLy8gVGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSByYXcgZGF0YSB0aGF0IGl0IHNlbnQgdG8gdGhlIG1peGVyLlxyXG4gICAgICAgICAgICBsZXQgdHJhbnNtaXRSZXR2YWwgPSB0aGlzLl9taXhlclNlc3Npb24uX3RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YVRvU2VydmVyKGRlbHRhKTtcclxuICAgICAgICAgICAgaWYgKHRyYW5zbWl0UmV0dmFsLnN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vdyB3ZSBoYXZlIHRvIHVwZGF0ZSBvdXIgXCJsYXN0IHRyYW5zbWl0dGVkXCIgYEhpRmlBdWRpb0FQSURhdGFgIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgLy8gdG8gY29udGFpbiB0aGUgZGF0YSB0aGF0IHdlIGp1c3QgdHJhbnNtaXR0ZWQuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVMYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhKGRlbHRhKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgcmF3RGF0YVRyYW5zbWl0dGVkOiB0cmFuc21pdFJldHZhbC5zdHJpbmdpZmllZERhdGFGb3JNaXhlclxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHRyYW5zbWl0UmV0dmFsLmVycm9yXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9taXhlclNlc3Npb24gJiYgdGhpcy5fdGltZXJzLnRyYW5zbWl0UmF0ZUxpbWl0VGltZW91dCAmJiAhZm9yY2VUcmFuc21pdCkge1xyXG4gICAgICAgICAgICB0aGlzLl90aW1lcnMud2FudGVkVG9UcmFuc21pdEhpRmlBdWRpb0FQSURhdGEgPSB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGVycm9yOiBgVHJhbnNmZXIgaXMgcmF0ZSBsaW1pdGVkLiBUcmFuc2ZlciB3aWxsIG9jY3VyIHNob3J0bHkgYXV0b21hdGljYWxseS5gXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fbWl4ZXJTZXNzaW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGVycm9yOiBgTm8gc2VydmVyIGNvbm5lY3Rpb24geWV0OyBjYW4ndCB0cmFuc21pdCB1c2VyIGRhdGEuYFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgc2ltcGxlIGZ1bmN0aW9uIHRoYXQgY2FsbHMge0BsaW5rIF91cGRhdGVVc2VyRGF0YX0sIGZvbGxvd2VkIGJ5IHtAbGluayBfdHJhbnNtaXRIaUZpQXVkaW9BUElEYXRhVG9TZXJ2ZXJ9LlxyXG4gICAgICogRGV2ZWxvcGVycyBjYW4gY2FsbCB0aGlzIGZ1bmN0aW9uIGFzIG9mdGVuIGFzIHRoZXkgd2FudC4gVGhpcyBmdW5jdGlvbiB3aWxsIHVwZGF0ZSB0aGUgaW50ZXJuYWwgZGF0YSBzdG9yZSBvZiB0aGUgdXNlcidzXHJcbiAgICAgKiBwb3NpdGlvbiwgb3JpZW50YXRpb24sIGV0Yy4gTm8gbWF0dGVyIGhvdyBvZnRlbiBkZXZlbG9wZXJzIGNhbGwgdGhpcyBmdW5jdGlvbiwgdGhlIGludGVybmFsIGRhdGEgc3RvcmUgdHJhbnNtaXNzaW9uIGlzIHJhdGUtbGltaXRlZFxyXG4gICAgICogYW5kIHdpbGwgb25seSBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIgb25jZSBldmVyeSBgdHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0TVNgIG1pbGxpc2Vjb25kcy4gV2hlbiB0aGUgaW50ZXJuYWwgZGF0YSBzdG9yZSBpcyB0cmFuc21pdHRlZCxcclxuICAgICAqIHRoZSBtb3N0IHVwLXRvLWRhdGUgZGF0YSB3aWxsIGJlIHRyYW5zbWl0dGVkLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0gbmV3VXNlckRhdGEgLSBUaGUgbmV3IHVzZXIgZGF0YSB0aGF0IHdlIHdhbnQgdG8gc2VuZCB0byB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBBUEkgc2VydmVyLlxyXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgcmV0dXJuIHZhbHVlIG9mIHtAbGluayBfdHJhbnNtaXRIaUZpQXVkaW9BUElEYXRhVG9TZXJ2ZXJ9LlxyXG4gICAgICovXHJcbiAgICB1cGRhdGVVc2VyRGF0YUFuZFRyYW5zbWl0KG5ld1VzZXJEYXRhOiBhbnkpOiBzdHJpbmcge1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVVzZXJEYXRhKG5ld1VzZXJEYXRhKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YVRvU2VydmVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmdlc3RzIHVzZXIgZGF0YSB1cGRhdGVzIGZyb20gdGhlIHNlcnZlciBhbmQsIGlmIHJlbGV2YW50LCBjYWxscyB0aGUgcmVsZXZhbnQgY2FsbGJhY2sgZnVuY3Rpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGVcclxuICAgICAqIFVzZXIgRGF0YSBTdWJzY3JpcHRpb25zLiBTZWUge0BsaW5rIGFkZFVzZXJEYXRhU3Vic2NyaXB0aW9ufS5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIG5ld1VzZXJEYXRhRnJvbVNlcnZlciAtIENvbnRhaW5zIGFsbCBvZiB0aGUgbmV3IHVzZXIgZGF0YSBtb3N0IHJlY2VudGx5IHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci4gXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX2hhbmRsZVVzZXJEYXRhVXBkYXRlcyhuZXdVc2VyRGF0YUZyb21TZXJ2ZXI6IEFycmF5PFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YT4pOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fdXNlckRhdGFTdWJzY3JpcHRpb25zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGxldCBzdWJJdHIgPSAwOyBzdWJJdHIgPCB0aGlzLl91c2VyRGF0YVN1YnNjcmlwdGlvbnMubGVuZ3RoOyBzdWJJdHIrKykge1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudFN1YnNjcmlwdGlvbiA9IHRoaXMuX3VzZXJEYXRhU3Vic2NyaXB0aW9uc1tzdWJJdHJdO1xyXG5cclxuICAgICAgICAgICAgLy8gRG9uJ3QgYm90aGVyIGNvbnRpbnVpbmcgdG8gZG8gYW55dGhpbmcgaWYgdGhlIGRldmVsb3BlciBkaWRuJ3Qgc3BlY2lmeSBhIGNhbGxiYWNrIGFzc29jaWF0ZWRcclxuICAgICAgICAgICAgLy8gd2l0aCB0aGUgY3VycmVudCBTdWJzY3JpcHRpb24gdGhhdCB3ZSBhcmUgcHJvY2Vzc2luZy5cclxuICAgICAgICAgICAgaWYgKCFjdXJyZW50U3Vic2NyaXB0aW9uLmNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRTdWJzY3JpcHRpb25DYWxsYmFja0RhdGE6IEFycmF5PFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YT4gPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGRhdGFJdHIgPSAwOyBkYXRhSXRyIDwgbmV3VXNlckRhdGFGcm9tU2VydmVyLmxlbmd0aDsgZGF0YUl0cisrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudERhdGFGcm9tU2VydmVyID0gbmV3VXNlckRhdGFGcm9tU2VydmVyW2RhdGFJdHJdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3Vic2NyaXB0aW9uLnByb3ZpZGVkVXNlcklEICYmIGN1cnJlbnREYXRhRnJvbVNlcnZlci5wcm92aWRlZFVzZXJJRCAhPT0gY3VycmVudFN1YnNjcmlwdGlvbi5wcm92aWRlZFVzZXJJRCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGxldCBuZXdDYWxsYmFja0RhdGEgPSBuZXcgUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoY3VycmVudERhdGFGcm9tU2VydmVyLnByb3ZpZGVkVXNlcklEKSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0NhbGxiYWNrRGF0YS5wcm92aWRlZFVzZXJJRCA9IGN1cnJlbnREYXRhRnJvbVNlcnZlci5wcm92aWRlZFVzZXJJRDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChjdXJyZW50RGF0YUZyb21TZXJ2ZXIuaGFzaGVkVmlzaXRJRCkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdDYWxsYmFja0RhdGEuaGFzaGVkVmlzaXRJRCA9IGN1cnJlbnREYXRhRnJvbVNlcnZlci5oYXNoZWRWaXNpdElEO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGxldCBzaG91bGRQdXNoTmV3Q2FsbGJhY2tEYXRhID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY29tcG9uZW50SXRyID0gMDsgY29tcG9uZW50SXRyIDwgY3VycmVudFN1YnNjcmlwdGlvbi5jb21wb25lbnRzLmxlbmd0aDsgY29tcG9uZW50SXRyKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudENvbXBvbmVudCA9IGN1cnJlbnRTdWJzY3JpcHRpb24uY29tcG9uZW50c1tjb21wb25lbnRJdHJdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGN1cnJlbnRDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdmFpbGFibGVVc2VyRGF0YVN1YnNjcmlwdGlvbkNvbXBvbmVudHMuUG9zaXRpb246XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudERhdGFGcm9tU2VydmVyLnBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2FsbGJhY2tEYXRhLnBvc2l0aW9uID0gY3VycmVudERhdGFGcm9tU2VydmVyLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFB1c2hOZXdDYWxsYmFja0RhdGEgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEF2YWlsYWJsZVVzZXJEYXRhU3Vic2NyaXB0aW9uQ29tcG9uZW50cy5PcmllbnRhdGlvbkV1bGVyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnREYXRhRnJvbVNlcnZlci5vcmllbnRhdGlvbkV1bGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2FsbGJhY2tEYXRhLm9yaWVudGF0aW9uRXVsZXIgPSBjdXJyZW50RGF0YUZyb21TZXJ2ZXIub3JpZW50YXRpb25FdWxlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRQdXNoTmV3Q2FsbGJhY2tEYXRhID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdmFpbGFibGVVc2VyRGF0YVN1YnNjcmlwdGlvbkNvbXBvbmVudHMuT3JpZW50YXRpb25RdWF0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnREYXRhRnJvbVNlcnZlci5vcmllbnRhdGlvblF1YXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDYWxsYmFja0RhdGEub3JpZW50YXRpb25RdWF0ID0gY3VycmVudERhdGFGcm9tU2VydmVyLm9yaWVudGF0aW9uUXVhdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRQdXNoTmV3Q2FsbGJhY2tEYXRhID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdmFpbGFibGVVc2VyRGF0YVN1YnNjcmlwdGlvbkNvbXBvbmVudHMuVm9sdW1lRGVjaWJlbHM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChjdXJyZW50RGF0YUZyb21TZXJ2ZXIudm9sdW1lRGVjaWJlbHMpID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2FsbGJhY2tEYXRhLnZvbHVtZURlY2liZWxzID0gY3VycmVudERhdGFGcm9tU2VydmVyLnZvbHVtZURlY2liZWxzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFB1c2hOZXdDYWxsYmFja0RhdGEgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEF2YWlsYWJsZVVzZXJEYXRhU3Vic2NyaXB0aW9uQ29tcG9uZW50cy5IaUZpR2FpbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGN1cnJlbnREYXRhRnJvbVNlcnZlci5oaUZpR2FpbikgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDYWxsYmFja0RhdGEuaGlGaUdhaW4gPSBjdXJyZW50RGF0YUZyb21TZXJ2ZXIuaGlGaUdhaW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkUHVzaE5ld0NhbGxiYWNrRGF0YSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFB1c2hOZXdDYWxsYmFja0RhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3Vic2NyaXB0aW9uQ2FsbGJhY2tEYXRhLnB1c2gobmV3Q2FsbGJhY2tEYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdWJzY3JpcHRpb24uY2FsbGJhY2sgJiYgY3VycmVudFN1YnNjcmlwdGlvbkNhbGxiYWNrRGF0YS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50U3Vic2NyaXB0aW9uLmNhbGxiYWNrKGN1cnJlbnRTdWJzY3JpcHRpb25DYWxsYmFja0RhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBzaW1wbGUgd3JhcHBlciBmdW5jdGlvbiBjYWxsZWQgYnkgb3VyIGluc3RhbnRpYXRpb24gb2YgYEhpRmlNaXhlclNlc3Npb25gIHRoYXQgY2FsbHMgdGhlIHVzZXItcHJvdmlkZWQgYG9uVXNlcnNEaXNjb25uZWN0ZWQoKWBcclxuICAgICAqIGZ1bmN0aW9uIGlmIG9uZSBleGlzdHMuXHJcbiAgICAgKiBMaWJyYXJ5IHVzZXJzIGNhbiBwcm92aWRlIGFuIGBvblVzZXJzRGlzY29ubmVjdGVkKClgIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gaW5zdGFudGlhdGluZyB0aGUgYEhpRmlDb21tdW5pY2F0b3JgIG9iamVjdCwgb3IgYnkgc2V0dGluZ1xyXG4gICAgICogYEhpRmlDb21tdW5pY2F0b3Iub25Vc2Vyc0Rpc2Nvbm5lY3RlZGAgYWZ0ZXIgaW5zdGFudGlhdGlvbi5cclxuICAgICAqIEBwYXJhbSB1c2Vyc0Rpc2Nvbm5lY3RlZCBcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfb25Vc2Vyc0Rpc2Nvbm5lY3RlZCh1c2Vyc0Rpc2Nvbm5lY3RlZDogQXJyYXk8UmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhPik6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLm9uVXNlcnNEaXNjb25uZWN0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5vblVzZXJzRGlzY29ubmVjdGVkKHVzZXJzRGlzY29ubmVjdGVkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IFVzZXIgRGF0YSBTdWJzY3JpcHRpb24gdG8gdGhlIGxpc3Qgb2YgY2xpZW50c2lkZSBTdWJzY3JpcHRpb25zLiBVc2VyIERhdGEgU3Vic2NyaXB0aW9ucyBhcmUgdXNlZCB0byBvYnRhaW5cclxuICAgICAqIFVzZXIgRGF0YSBhYm91dCBvdGhlciBVc2Vycy4gRm9yIGV4YW1wbGUsIGlmIHlvdSBzZXQgdXAgYSBVc2VyIERhdGEgU3Vic2NyaXB0aW9uIGZvciB5b3VyIG93biBVc2VyIERhdGEsIHlvdSBjYW4gdXNlIHRoYXQgc3Vic2NyaXB0aW9uIFxyXG4gICAgICogdG8gZW5zdXJlIHRoYXQgdGhlIGRhdGEgb24gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJIFNlcnZlciBpcyB0aGUgc2FtZSBhcyB0aGUgZGF0YSB5b3UgYXJlIHNlbmRpbmdcclxuICAgICAqIHRvIGl0IGZyb20gdGhlIGNsaWVudC4gXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSBuZXdTdWJzY3JpcHRpb24gLSBUaGUgbmV3IFVzZXIgRGF0YSBTdWJzY3JpcHRpb24gYXNzb2NpYXRlZCB3aXRoIGEgdXNlci4gXHJcbiAgICAgKi9cclxuICAgIGFkZFVzZXJEYXRhU3Vic2NyaXB0aW9uKG5ld1N1YnNjcmlwdGlvbjogVXNlckRhdGFTdWJzY3JpcHRpb24pOiB2b2lkIHtcclxuICAgICAgICBpZiAoIXRoaXMuX21peGVyU2Vzc2lvbikge1xyXG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBObyBcXGBfbWl4ZXJTZXNzaW9uXFxgISBEYXRhIHN1YnNjcmlwdGlvbiBub3QgYWRkZWQuYCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9taXhlclNlc3Npb24udXNlckRhdGFTdHJlYW1pbmdTY29wZSA9PT0gSGlGaVVzZXJEYXRhU3RyZWFtaW5nU2NvcGVzLk5vbmUpIHtcclxuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgRHVyaW5nIFxcYEhpRmlDb21tdW5pY2F0b3JcXGAgY29uc3RydWN0aW9uLCB0aGUgc2VydmVyIHdhcyBzZXQgdXAgdG8gKipub3QqKiBzZW5kIHVzZXIgZGF0YSEgRGF0YSBzdWJzY3JpcHRpb24gbm90IGFkZGVkLmApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBIaUZpTG9nZ2VyLmxvZyhgQWRkaW5nIG5ldyBVc2VyIERhdGEgU3Vic2NyaXB0aW9uOlxcbiR7SlNPTi5zdHJpbmdpZnkobmV3U3Vic2NyaXB0aW9uKX1gKTtcclxuICAgICAgICB0aGlzLl91c2VyRGF0YVN1YnNjcmlwdGlvbnMucHVzaChuZXdTdWJzY3JpcHRpb24pO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBDb2RlIGluIHRoaXMgbW9kdWxlIGlzIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgW1tIaUZpQ29tbXVuaWNhdG9yXV0gb2JqZWN0IHRvIG1hbmFnZSB0aGUgY29ubmVjdGlvbiBiZXR3ZWVuIGNsaWVudCBhbmQgc2VydmVyLlxyXG4gKiBEZXZlbG9wZXJzIGRvIG5vdCBuZWVkIHRvIGFuZCBzaG91bGQgbm90IGNvbnNpZGVyIHRoaXMgbW9kdWxlIHdoZW4gd3JpdGluZyB0aGVpciBhcHBsaWNhdGlvbnMuXHJcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxyXG4gKi9cclxuXHJcbmltcG9ydCB7IEhpRmlBdWRpb0FQSURhdGEsIE9yaWVudGF0aW9uRXVsZXIzRCwgT3JpZW50YXRpb25RdWF0M0QsIFBvaW50M0QsIFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YSB9IGZyb20gXCIuL0hpRmlBdWRpb0FQSURhdGFcIjtcclxuaW1wb3J0IHsgSGlGaUxvZ2dlciB9IGZyb20gXCIuLi91dGlsaXRpZXMvSGlGaUxvZ2dlclwiO1xyXG5pbXBvcnQgeyBIaUZpQ29ubmVjdGlvblN0YXRlcywgSGlGaVVzZXJEYXRhU3RyZWFtaW5nU2NvcGVzIH0gZnJvbSBcIi4vSGlGaUNvbW11bmljYXRvclwiO1xyXG5cclxuLy8gV2UgdXNlIEB0cy1pZ25vcmUgaGVyZSBzbyBUeXBlU2NyaXB0IGRvZXNuJ3QgY29tcGxhaW4gYWJvdXQgaW1wb3J0aW5nIHRoZXNlIHBsYWluIEpTIG1vZHVsZXMuXHJcbi8vIEB0cy1pZ25vcmVcclxuaW1wb3J0IHsgUmF2aVV0aWxzIH0gZnJvbSBcIi4uL2xpYnJhdmkvUmF2aVV0aWxzXCI7XHJcbi8vIEB0cy1pZ25vcmVcclxuaW1wb3J0IHsgUmF2aVNlc3Npb24sIFJhdmlTZXNzaW9uU3RhdGVzIH0gZnJvbSBcIi4uL2xpYnJhdmkvUmF2aVNlc3Npb25cIjtcclxuLy8gQHRzLWlnbm9yZVxyXG5pbXBvcnQgeyBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbiwgU2lnbmFsaW5nU3RhdGVzIH0gZnJvbSBcIi4uL2xpYnJhdmkvUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb25cIjtcclxuaW1wb3J0IHsgSGlGaUF4aXNVdGlsaXRpZXMsIG91ckhpRmlBeGlzQ29uZmlndXJhdGlvbiB9IGZyb20gXCIuL0hpRmlBeGlzQ29uZmlndXJhdGlvblwiO1xyXG5jb25zdCBwYWtvID0gcmVxdWlyZSgncGFrbycpO1xyXG5cclxuY29uc3QgSU5JVF9USU1FT1VUX01TID0gNTAwMDtcclxuXHJcbi8qKlxyXG4gKiBJbnN0YW50aWF0aW9ucyBvZiB0aGlzIGNsYXNzIGNvbnRhaW4gZGF0YSBhYm91dCBhIGNvbm5lY3Rpb24gYmV0d2VlbiBhIGNsaWVudCBhbmQgYSBtaXhlci5cclxuICogQ2xpZW50IGxpYnJhcnkgdXNlcnMgc2hvdWxkbid0IGhhdmUgdG8gY2FyZSBhdCBhbGwgYWJvdXQgdGhlIHZhcmlhYmxlcyBhbmQgbWV0aG9kcyBjb250YWluZWQgaW4gdGhpcyBjbGFzcy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBIaUZpTWl4ZXJTZXNzaW9uIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIFJBVkkgU2lnbmFsaW5nIENvbm5lY3Rpb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgTWl4ZXIgU2Vzc2lvbi5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfcmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb246IFJhdmlTaWduYWxpbmdDb25uZWN0aW9uO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgUkFWSSBTZXNzaW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIE1peGVyIFNlc3Npb24uXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX3JhdmlTZXNzaW9uOiBSYXZpU2Vzc2lvbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0b3JlcyB0aGUgY3VycmVudCBIaUZpIENvbm5lY3Rpb24gU3RhdGUsIHdoaWNoIGlzIGFuIGFic3RyYWN0aW9uIHNlcGFyYXRlIGZyb20gdGhlIFJBVkkgU2Vzc2lvbiBTdGF0ZSBhbmQgUkFWSSBTaWduYWxpbmcgU3RhdGUuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX2N1cnJlbnRIaUZpQ29ubmVjdGlvblN0YXRlOiBIaUZpQ29ubmVjdGlvblN0YXRlcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgd2hlbiBtdXRpbmcgYW5kIHVubXV0aW5nIHRvIHNhdmUgdGhlIHN0YXRlIG9mIHRoZSB1c2VyJ3MgaW5wdXQgZGV2aWNlJ3MgYE1lZGlhVHJhY2tDb25zdHJhaW50c2AuXHJcbiAgICAgKiBXaGVuIGEgdXNlciBtdXRlcywgd2UgZXhwbGljaXRseSBjYWxsIGBzdG9wKClgIG9uIGFsbCBhdWRpbyB0cmFja3MgYXNzb2NpYXRlZCB3aXRoIHRoZSB1c2VyJ3MgaW5wdXQgZGV2aWNlLlxyXG4gICAgICogV2hlbiBhIHVzZXIgdW5tdXRlcywgd2UgbXVzdCBjYWxsIGBnZXRVc2VyTWVkaWEoKWAgdG8gcmUtb2J0YWluIHRob3NlIGF1ZGlvIHRyYWNrcy4gV2Ugd2FudCB0byBjYWxsIGBnZXRVc2VyTWVkaWEoKWBcclxuICAgICAqIHdpdGggdGhlIHNhbWUgY29uc3RyYWludHMgdXNlZCBieSB0aGUgYXBwbGljYXRpb24gd2hlbiBfaXRfIGZpcnN0IGNhbGxzIGBnZXRVc2VyTWVkaWEoKWAuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX2NhY2hlZE1lZGlhVHJhY2tDb25zdHJhaW50czogTWVkaWFUcmFja0NvbnN0cmFpbnRzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hlbiB3ZSByZWNlaXZlIHBlZXIgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIsIGl0J3MgaW4gYSBmb3JtYXQgbGlrZSB0aGlzOlxyXG4gICAgICoge1xyXG4gICAgICogICAgIDMxODoge2M6IFwiIzVkZjFmNVwiLCBkOiBcIkhvd2FyZFwiLCBlOiBcIjg3M2M0ZDQzLWNjZDktNGNlNC05YWM3LWQ1ZmFkZTRkZWY5MjlhXCIsIGk6IFwie2YwY2UyMmJiLThiNjctNDA0NC1hOGM1LTY1YWVmYmNlNDA2MH1cIiwgbzogMCwg4oCmfVxyXG4gICAgICogICAgIDM0MToge2U6IFwiOWM1YWY0NGItN2UzZi04ZjY1LTU0MjEtMzc0YjQzYmViYzRhXCIsIGk6IFwie2JlMzhhMjU2LTg1MGEtNGM4ZC1iZGRkLWNmZTgwYWFkZGZlOX1cIiwgbzogMCwgcDogdHJ1ZSwgdjogLTEyMCwg4oCmfVxyXG4gICAgICogfVxyXG4gICAgICogVGhlIHBlZXIgZGF0YSBkb2VzIG5vdCBhbHdheXMgY29udGFpbiBhbGwgcG9zc2libGUga2V5L3ZhbHVlIHBhaXJzIGFzc29jaWF0ZWQgd2l0aCBlYWNoIGtleSBpbiB0aGlzIE9iamVjdC4gSW4gZmFjdCwgbW9zdCBvZiB0aGUgdGltZSwgaXQgY29udGFpbnNcclxuICAgICAqIG9ubHkgYSBmcmFjdGlvbiBvZiB0aGUgZGF0YS4gRm9yIGV4YW1wbGUsIHdlIG1pZ2h0IHJlY2VpdmUgYHsgMzQxOiB7djogLTQwfSB9YCBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICAgKiBXaGVuIHRoZSBIaUZpIEF1ZGlvIExpYnJhcnkgdXNlciBzZXRzIHVwIGEgVXNlciBEYXRhIFN1YnNjcmlwdGlvbiwgdGhleSBjYW4gb3B0aW9uYWxseSBhc3NvY2lhdGUgdGhlIFN1YnNjcmlwdGlvbiB3aXRoIGEgXCJQcm92aWRlZCBVc2VyIElEXCIuXHJcbiAgICAgKiBTaW5jZSB0aGUgc2VydmVyIGRvZXNuJ3QgYWx3YXlzIHNlbmQgdGhlIFwiUHJvdmlkZWQgVXNlciBJRFwiIGluIHRoZXNlIHBlZXIgdXBkYXRlcywgd2UgaGF2ZSB0byBrZWVwIHRyYWNrIG9mIHRoZSAocHJlc3VtYWJseSBzdGFibGUpIGtleSBpbiBganNvbkRhdGEucGVlcnNgXHJcbiAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhhdCBcIlByb3ZpZGVkIFVzZXIgSURcIiBpbiBvcmRlciB0byBmb3J3YXJkIHRoYXQgXCJQcm92aWRlZCBVc2VyIElEXCIgdG8gdGhlIFN1YnNjcmlwdGlvbiBoYW5kbGVyIGFuZCB0aHVzIHRvIHRoZSBMaWJyYXJ5IHVzZXIuXHJcbiAgICAgKiBUaHVzLCB0aGUgTGlicmFyeSB1c2VyIHNob3VsZCBuZXZlciBoYXZlIHRvIGNhcmUgYWJvdXQgdGhlIGBfbWl4ZXJQZWVyS2V5VG9Qcm92aWRlZFVzZXJJRERpY3RgLlxyXG4gICAgICogU2ltaWxhcmx5LCB3ZSBrZWVwIGEgYF9taXhlclBlZXJLZXlUb0hhc2hlZFZpc2l0SUREaWN0YC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfbWl4ZXJQZWVyS2V5VG9Qcm92aWRlZFVzZXJJRERpY3Q6IGFueTtcclxuICAgIHByaXZhdGUgX21peGVyUGVlcktleVRvSGFzaGVkVmlzaXRJRERpY3Q6IGFueTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdlIHdpbGwgdHJhY2sgd2hldGhlciBvciBub3QgdGhlIGlucHV0IHN0cmVhbSBpcyBzdGVyZW8sIHNvIHRoYXRcclxuICAgICAqIHdlIGNhbiBhZHZpc2UgdGhlIHNlcnZlciB0byBtaXggaXQgYXBwcm9wcmlhdGVseVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9pbnB1dEF1ZGlvTWVkaWFTdHJlYW1Jc1N0ZXJlbzogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBXZWJSVEMgU3RhdHMgT2JzZXJ2ZXIgY2FsbGJhY2tcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfc3RhdHNPYnNlcnZlckNhbGxiYWNrOiBGdW5jdGlvbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlZSB7QGxpbmsgSGlGaVVzZXJEYXRhU3RyZWFtaW5nU2NvcGVzfS5cclxuICAgICAqL1xyXG4gICAgdXNlckRhdGFTdHJlYW1pbmdTY29wZTogSGlGaVVzZXJEYXRhU3RyZWFtaW5nU2NvcGVzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIFdlYlJUQyBBZGRyZXNzIHRvIHdoaWNoIHdlIHdhbnQgdG8gY29ubmVjdCBhcyBhIHBhcnQgb2YgdGhpcyBTZXNzaW9uLiBUaGlzIFdlYlJUQyBBZGRyZXNzIGlzIG9idGFpbmVkIGZyb20gdGhlIE1peGVyIERpc2NvdmVyeSBBZGRyZXNzIGR1cmluZ1xyXG4gICAgICogdGhlIGBIaUZpQ29tbXVuaWNhdG9yLmNvbm5lY3RUb0hpRmlBdWRpb0FQSVNlcnZlcigpYCBjYWxsLlxyXG4gICAgICovXHJcbiAgICB3ZWJSVENBZGRyZXNzOiBzdHJpbmc7XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gUGVlciBkYXRhIGlzIHJldHVybmVkIGZyb20gdGhlIFNlcnZlci5cclxuICAgICAqL1xyXG4gICAgb25Vc2VyRGF0YVVwZGF0ZWQ6IEZ1bmN0aW9uO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIGEgUGVlciBkaXNjb25uZWN0cyBmcm9tIHRoZSBTZXJ2ZXIuXHJcbiAgICAgKi9cclxuICAgIG9uVXNlcnNEaXNjb25uZWN0ZWQ6IEZ1bmN0aW9uO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIHRoZSBcImNvbm5lY3Rpb24gc3RhdGVcIiBjaGFuZ2VzLlxyXG4gICAgICogUmlnaHQgbm93LCB0aGlzIGlzIGNhbGxlZCB3aGVuIHRoZSB0aGUgUkFWSSBzZXNzaW9uIHN0YXRlIGNoYW5nZXMgdG9cclxuICAgICAqIGBSYXZpU2Vzc2lvblN0YXRlcy5DT05ORUNURURgLCBgUmF2aVNlc3Npb25TdGF0ZXMuRElTQ09OTkVDVEVEYCwgYW5kIGBSYXZpU2Vzc2lvblN0YXRlcy5GQUlMRURgLlxyXG4gICAgICovXHJcbiAgICBvbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQ6IEZ1bmN0aW9uO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG1peGVyIHRvIHdoaWNoIHdlIGFyZSBjdXJyZW50bHkgY29ubmVjdGVkLlxyXG4gICAgICovXHJcbiAgICBtaXhlckluZm86IGFueTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIF9fbmFtZWRQYXJhbWV0ZXJzXHJcbiAgICAgKiBAcGFyYW0gdXNlckRhdGFTdHJlYW1pbmdTY29wZSAtIFNlZSB7QGxpbmsgSGlGaVVzZXJEYXRhU3RyZWFtaW5nU2NvcGVzfS5cclxuICAgICAqIFxyXG4gICAgICogSWYgc2V0IHRvIGBmYWxzZWAsIFVzZXIgRGF0YSBTdWJzY3JpcHRpb25zIHdpbGwgc2VydmUgbm8gcHVycG9zZS5cclxuICAgICAqIEBwYXJhbSBvblVzZXJEYXRhVXBkYXRlZCAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHNlcnZlciBzZW5kcyB1c2VyIGRhdGEgdG8gdGhlIGNsaWVudC4gSXJyZWxldmFudCBpZiBgdXNlckRhdGFTdHJlYW1pbmdTY29wZWAgaXMgYEhpRmlVc2VyRGF0YVN0cmVhbWluZ1Njb3Blcy5Ob25lYC5cclxuICAgICAqIEBwYXJhbSBvblVzZXJzRGlzY29ubmVjdGVkIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgc2VydmVyIHNlbmRzIHVzZXIgZGF0YSBhYm91dCBwZWVycyB3aG8ganVzdCBkaXNjb25uZWN0ZWQgdG8gdGhlIGNsaWVudC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoeyB1c2VyRGF0YVN0cmVhbWluZ1Njb3BlID0gSGlGaVVzZXJEYXRhU3RyZWFtaW5nU2NvcGVzLkFsbCwgb25Vc2VyRGF0YVVwZGF0ZWQsIG9uVXNlcnNEaXNjb25uZWN0ZWQsIG9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCB9OiB7IHVzZXJEYXRhU3RyZWFtaW5nU2NvcGU/OiBIaUZpVXNlckRhdGFTdHJlYW1pbmdTY29wZXMsIG9uVXNlckRhdGFVcGRhdGVkPzogRnVuY3Rpb24sIG9uVXNlcnNEaXNjb25uZWN0ZWQ/OiBGdW5jdGlvbiwgb25Db25uZWN0aW9uU3RhdGVDaGFuZ2VkPzogRnVuY3Rpb24gfSkge1xyXG4gICAgICAgIHRoaXMud2ViUlRDQWRkcmVzcyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnVzZXJEYXRhU3RyZWFtaW5nU2NvcGUgPSB1c2VyRGF0YVN0cmVhbWluZ1Njb3BlO1xyXG4gICAgICAgIHRoaXMub25Vc2VyRGF0YVVwZGF0ZWQgPSBvblVzZXJEYXRhVXBkYXRlZDtcclxuICAgICAgICB0aGlzLm9uVXNlcnNEaXNjb25uZWN0ZWQgPSBvblVzZXJzRGlzY29ubmVjdGVkO1xyXG4gICAgICAgIHRoaXMuX21peGVyUGVlcktleVRvUHJvdmlkZWRVc2VySUREaWN0ID0ge307XHJcbiAgICAgICAgdGhpcy5fbWl4ZXJQZWVyS2V5VG9IYXNoZWRWaXNpdElERGljdCA9IHt9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIFJhdmlVdGlscy5zZXREZWJ1ZyhmYWxzZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5fcmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24gPSBuZXcgUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24oKTtcclxuICAgICAgICB0aGlzLl9yYXZpU2lnbmFsaW5nQ29ubmVjdGlvbi5hZGRTdGF0ZUNoYW5nZUhhbmRsZXIoKGV2ZW50OiBhbnkpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5vblJBVklTaWduYWxpbmdTdGF0ZUNoYW5nZWQoZXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuX3JhdmlTZXNzaW9uID0gbmV3IFJhdmlTZXNzaW9uKCk7XHJcbiAgICAgICAgdGhpcy5fcmF2aVNlc3Npb24uYWRkU3RhdGVDaGFuZ2VIYW5kbGVyKChldmVudDogYW55KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMub25SQVZJU2Vzc2lvblN0YXRlQ2hhbmdlZChldmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQgPSBvbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5fcmVzZXRNaXhlckluZm8oKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbmRzIHRoZSBjb21tYW5kIGBhdWRpb25ldC5pbml0YCB0byB0aGUgbWl4ZXIuXHJcbiAgICAgKiBcclxuICAgICAqIEByZXR1cm5zIElmIHRoaXMgb3BlcmF0aW9uIGlzIHN1Y2Nlc3NmdWwsIHRoZSBQcm9taXNlIHdpbGwgcmVzb2x2ZSB3aXRoIGB7IHN1Y2Nlc3M6IHRydWUsIGF1ZGlvbmV0SW5pdFJlc3BvbnNlOiA8VGhlIHJlc3BvbnNlIHRvIGBhdWRpb25ldC5pbml0YCBmcm9tIHRoZSBzZXJ2ZXIgaW4gT2JqZWN0IGZvcm1hdD59YC5cclxuICAgICAqIElmIHVuc3VjY2Vzc2Z1bCwgdGhlIFByb21pc2Ugd2lsbCByZWplY3Qgd2l0aCBgeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IDxhbiBlcnJvciBtZXNzYWdlPiB9YC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgcHJvbWlzZVRvUnVuQXVkaW9Jbml0KCk6IFByb21pc2U8YW55PiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgbGV0IGluaXREYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgcHJpbWFyeTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBtaXhlciB3aWxsIGhhc2ggdGhpcyByYW5kb21seS1nZW5lcmF0ZWQgVVVJRCwgdGhlbiBkaXNzZW1pbmF0ZSBpdCB0byBhbGwgY2xpZW50cyB2aWEgYHBlZXJEYXRhLmVgLlxyXG4gICAgICAgICAgICAgICAgdmlzaXRfaWQ6IHRoaXMuX3JhdmlTZXNzaW9uLmdldFVVSUQoKSxcclxuICAgICAgICAgICAgICAgIHNlc3Npb246IHRoaXMuX3JhdmlTZXNzaW9uLmdldFVVSUQoKSwgLy8gU3RpbGwgcmVxdWlyZWQgZm9yIG9sZCBtaXhlcnMuIFdpbGwgZXZlbnR1YWxseSBnbyBhd2F5LlxyXG4gICAgICAgICAgICAgICAgc3RyZWFtaW5nX3Njb3BlOiB0aGlzLnVzZXJEYXRhU3RyZWFtaW5nU2NvcGUsXHJcbiAgICAgICAgICAgICAgICBpc19pbnB1dF9zdHJlYW1fc3RlcmVvOiB0aGlzLl9pbnB1dEF1ZGlvTWVkaWFTdHJlYW1Jc1N0ZXJlb1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBsZXQgY29tbWFuZENvbnRyb2xsZXIgPSB0aGlzLl9yYXZpU2Vzc2lvbi5nZXRDb21tYW5kQ29udHJvbGxlcigpO1xyXG4gICAgICAgICAgICBpZiAoIWNvbW1hbmRDb250cm9sbGVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBgQ291bGRuJ3QgY29ubmVjdCB0byBtaXhlcjogbm8gXFxgY29tbWFuZENvbnRyb2xsZXJcXGAhYFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCBpbml0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBgQ291bGRuJ3QgY29ubmVjdCB0byBtaXhlcjogQ2FsbCB0byBcXGBpbml0XFxgIHRpbWVkIG91dCFgXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSwgSU5JVF9USU1FT1VUX01TKTtcclxuXHJcbiAgICAgICAgICAgIGNvbW1hbmRDb250cm9sbGVyLnF1ZXVlQ29tbWFuZChcImF1ZGlvbmV0LmluaXRcIiwgaW5pdERhdGEsIGFzeW5jIChyZXNwb25zZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaW5pdFRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlZFJlc3BvbnNlOiBhbnk7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZFJlc3BvbnNlID0gSlNPTi5wYXJzZShyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taXhlckluZm9bXCJjb25uZWN0ZWRcIl0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWl4ZXJJbmZvW1wiYnVpbGRfbnVtYmVyXCJdID0gcGFyc2VkUmVzcG9uc2UuYnVpbGRfbnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWl4ZXJJbmZvW1wiYnVpbGRfdHlwZVwiXSA9IHBhcnNlZFJlc3BvbnNlLmJ1aWxkX3R5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taXhlckluZm9bXCJidWlsZF92ZXJzaW9uXCJdID0gcGFyc2VkUmVzcG9uc2UuYnVpbGRfdmVyc2lvbjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1peGVySW5mb1tcInZpc2l0X2lkX2hhc2hcIl0gPSBwYXJzZWRSZXNwb25zZS52aXNpdF9pZF9oYXNoO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZFJlc3BvbnNlW1widW5oYXNoZWRWaXNpdElEXCJdID0gdGhpcy5fcmF2aVNlc3Npb24uZ2V0VVVJRCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdWRpb25ldEluaXRSZXNwb25zZTogcGFyc2VkUmVzcG9uc2VcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGBDb3VsZG4ndCBwYXJzZSBpbml0IHJlc3BvbnNlISBQYXJzZSBlcnJvcjpcXG4ke2V9YFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIGBtaXhlcmAgYW5kIGBwZWVyYCBkYXRhIGlzIHNlbnQgZnJvbSB0aGUgTWl4ZXIgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzIHdoZW4gbmVjZXNzYXJ5LlxyXG4gICAgICogQHBhcmFtIGRhdGEgVGhlIGBnemlwcGVkYCBkYXRhIGZyb20gdGhlIE1peGVyLlxyXG4gICAgICovXHJcbiAgICBoYW5kbGVSQVZJU2Vzc2lvbkJpbmFyeURhdGEoZGF0YTogYW55KSB7XHJcbiAgICAgICAgbGV0IHVuR1ppcHBlZERhdGEgPSBwYWtvLnVuZ3ppcChkYXRhLCB7IHRvOiAnc3RyaW5nJyB9KTtcclxuICAgICAgICBsZXQganNvbkRhdGEgPSBKU09OLnBhcnNlKHVuR1ppcHBlZERhdGEpO1xyXG5cclxuICAgICAgICAvLyBXYWl0IGZvciBtZXJnZSBhbmQgZGVwbG95IG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9oaWdoZmlkZWxpdHkvYXVkaW9uZXQtaGlmaS9wdWxsLzI1OFxyXG4gICAgICAgIGlmIChqc29uRGF0YS5kZWxldGVkX3Zpc2l0X2lkcykgeyAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBsZXQgYWxsRGVsZXRlZFVzZXJEYXRhOiBBcnJheTxSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGE+ID0gW107XHJcblxyXG4gICAgICAgICAgICBsZXQgZGVsZXRlZFZpc2l0SURzID0ganNvbkRhdGEuZGVsZXRlZF92aXNpdF9pZHM7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGVsZXRlZFZpc2l0SUQgb2YgZGVsZXRlZFZpc2l0SURzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaGFzaGVkVmlzaXRJRCA9IGRlbGV0ZWRWaXNpdElEO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBkZWxldGVkVXNlckRhdGEgPSBuZXcgUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhKHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNoZWRWaXNpdElEOiBoYXNoZWRWaXNpdElEXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgbWl4ZXJQZWVyS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX21peGVyUGVlcktleVRvSGFzaGVkVmlzaXRJRERpY3QpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBtaXhlclBlZXJLZXkgb2YgbWl4ZXJQZWVyS2V5cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9taXhlclBlZXJLZXlUb0hhc2hlZFZpc2l0SUREaWN0W21peGVyUGVlcktleV0gPT09IGhhc2hlZFZpc2l0SUQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX21peGVyUGVlcktleVRvUHJvdmlkZWRVc2VySUREaWN0W21peGVyUGVlcktleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRVc2VyRGF0YS5wcm92aWRlZFVzZXJJRCA9IHRoaXMuX21peGVyUGVlcktleVRvUHJvdmlkZWRVc2VySUREaWN0W21peGVyUGVlcktleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGFsbERlbGV0ZWRVc2VyRGF0YS5wdXNoKGRlbGV0ZWRVc2VyRGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9uVXNlcnNEaXNjb25uZWN0ZWQgJiYgYWxsRGVsZXRlZFVzZXJEYXRhLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25Vc2Vyc0Rpc2Nvbm5lY3RlZChhbGxEZWxldGVkVXNlckRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgaWYgKGpzb25EYXRhLnBlZXJzKSB7XHJcbiAgICAgICAgICAgIGxldCBhbGxOZXdVc2VyRGF0YTogQXJyYXk8UmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhPiA9IFtdO1xyXG5cclxuICAgICAgICAgICAgbGV0IHBlZXJLZXlzID0gT2JqZWN0LmtleXMoanNvbkRhdGEucGVlcnMpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpdHIgPSAwOyBpdHIgPCBwZWVyS2V5cy5sZW5ndGg7IGl0cisrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcGVlckRhdGFGcm9tTWl4ZXIgPSBqc29uRGF0YS5wZWVyc1twZWVyS2V5c1tpdHJdXTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3VXNlckRhdGEgPSBuZXcgUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2VlIHtAbGluayB0aGlzLl9taXhlclBlZXJLZXlUb1Byb3ZpZGVkVXNlcklERGljdH0uXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWl4ZXJQZWVyS2V5VG9Qcm92aWRlZFVzZXJJRERpY3RbcGVlcktleXNbaXRyXV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdVc2VyRGF0YS5wcm92aWRlZFVzZXJJRCA9IHRoaXMuX21peGVyUGVlcktleVRvUHJvdmlkZWRVc2VySUREaWN0W3BlZXJLZXlzW2l0cl1dO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgKHBlZXJEYXRhRnJvbU1peGVyLkopID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VXNlckRhdGEucHJvdmlkZWRVc2VySUQgPSBwZWVyRGF0YUZyb21NaXhlci5KO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21peGVyUGVlcktleVRvUHJvdmlkZWRVc2VySUREaWN0W3BlZXJLZXlzW2l0cl1dID0gbmV3VXNlckRhdGEucHJvdmlkZWRVc2VySUQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gYC5lYCBpcyB0aGUgYGhhc2hlZFZpc2l0SURgLCB3aGljaCBpcyBhIGhhc2hlZCB2ZXJzaW9uIG9mIHRoZSByYW5kb20gVVVJRCB0aGF0IGEgY29ubmVjdGluZyBjbGllbnRcclxuICAgICAgICAgICAgICAgIC8vIHNlbmRzIGFzIHRoZSBgc2Vzc2lvbmAga2V5IGluc2lkZSB0aGUgYXJndW1lbnQgdG8gdGhlIGBhdWRpb25ldC5pbml0YCBjb21tYW5kLlxyXG4gICAgICAgICAgICAgICAgLy8gSXQgaXMgdXNlZCB0byBpZGVudGlmeSBhIGdpdmVuIGNsaWVudCBhY3Jvc3MgYSBjbG91ZCBvZiBtaXhlcnMuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWl4ZXJQZWVyS2V5VG9IYXNoZWRWaXNpdElERGljdFtwZWVyS2V5c1tpdHJdXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1VzZXJEYXRhLmhhc2hlZFZpc2l0SUQgPSB0aGlzLl9taXhlclBlZXJLZXlUb0hhc2hlZFZpc2l0SUREaWN0W3BlZXJLZXlzW2l0cl1dO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgKHBlZXJEYXRhRnJvbU1peGVyLmUpID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VXNlckRhdGEuaGFzaGVkVmlzaXRJRCA9IHBlZXJEYXRhRnJvbU1peGVyLmU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWl4ZXJQZWVyS2V5VG9IYXNoZWRWaXNpdElERGljdFtwZWVyS2V5c1tpdHJdXSA9IG5ld1VzZXJEYXRhLmhhc2hlZFZpc2l0SUQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IHNlcnZlclNlbnROZXdVc2VyRGF0YSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGBSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGEucG9zaXRpb24ueGBcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHBlZXJEYXRhRnJvbU1peGVyLngpID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdVc2VyRGF0YS5wb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdVc2VyRGF0YS5wb3NpdGlvbiA9IG5ldyBQb2ludDNEKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1peGVyIHNlbmRzIHBvc2l0aW9uIGRhdGEgaW4gbWlsbGltZXRlcnNcclxuICAgICAgICAgICAgICAgICAgICBuZXdVc2VyRGF0YS5wb3NpdGlvbi54ID0gcGVlckRhdGFGcm9tTWl4ZXIueCAvIDEwMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyU2VudE5ld1VzZXJEYXRhID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGBSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGEucG9zaXRpb24ueWBcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHBlZXJEYXRhRnJvbU1peGVyLnkpID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdVc2VyRGF0YS5wb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdVc2VyRGF0YS5wb3NpdGlvbiA9IG5ldyBQb2ludDNEKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1peGVyIHNlbmRzIHBvc2l0aW9uIGRhdGEgaW4gbWlsbGltZXRlcnNcclxuICAgICAgICAgICAgICAgICAgICBuZXdVc2VyRGF0YS5wb3NpdGlvbi55ID0gcGVlckRhdGFGcm9tTWl4ZXIueSAvIDEwMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyU2VudE5ld1VzZXJEYXRhID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGBSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGEucG9zaXRpb24uemBcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHBlZXJEYXRhRnJvbU1peGVyLnopID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdVc2VyRGF0YS5wb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdVc2VyRGF0YS5wb3NpdGlvbiA9IG5ldyBQb2ludDNEKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1peGVyIHNlbmRzIHBvc2l0aW9uIGRhdGEgaW4gbWlsbGltZXRlcnNcclxuICAgICAgICAgICAgICAgICAgICBuZXdVc2VyRGF0YS5wb3NpdGlvbi56ID0gcGVlckRhdGFGcm9tTWl4ZXIueiAvIDEwMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyU2VudE5ld1VzZXJEYXRhID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBgUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uRXVsZXIucGl0Y2hEZWdyZWVzYFxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocGVlckRhdGFGcm9tTWl4ZXIuaykgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1VzZXJEYXRhLm9yaWVudGF0aW9uRXVsZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VXNlckRhdGEub3JpZW50YXRpb25FdWxlciA9IG5ldyBPcmllbnRhdGlvbkV1bGVyM0QoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VXNlckRhdGEub3JpZW50YXRpb25FdWxlci5waXRjaERlZ3JlZXMgPSBwZWVyRGF0YUZyb21NaXhlci5rO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclNlbnROZXdVc2VyRGF0YSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBgUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uRXVsZXIueWF3RGVncmVlc2BcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHBlZXJEYXRhRnJvbU1peGVyLm8pID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdVc2VyRGF0YS5vcmllbnRhdGlvbkV1bGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1VzZXJEYXRhLm9yaWVudGF0aW9uRXVsZXIgPSBuZXcgT3JpZW50YXRpb25FdWxlcjNEKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG5ld1VzZXJEYXRhLm9yaWVudGF0aW9uRXVsZXIueWF3RGVncmVlcyA9IHBlZXJEYXRhRnJvbU1peGVyLm87XHJcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyU2VudE5ld1VzZXJEYXRhID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGBSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25FdWxlci5yb2xsRGVncmVlc2BcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHBlZXJEYXRhRnJvbU1peGVyLmwpID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdVc2VyRGF0YS5vcmllbnRhdGlvbkV1bGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1VzZXJEYXRhLm9yaWVudGF0aW9uRXVsZXIgPSBuZXcgT3JpZW50YXRpb25FdWxlcjNEKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG5ld1VzZXJEYXRhLm9yaWVudGF0aW9uRXVsZXIucm9sbERlZ3JlZXMgPSBwZWVyRGF0YUZyb21NaXhlci5sO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclNlbnROZXdVc2VyRGF0YSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gYFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQuKmBcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHBlZXJEYXRhRnJvbU1peGVyLlcpID09PSBcIm51bWJlclwiICYmIHR5cGVvZiAocGVlckRhdGFGcm9tTWl4ZXIuWCkgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIChwZWVyRGF0YUZyb21NaXhlci5ZKSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgKHBlZXJEYXRhRnJvbU1peGVyLlopID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VXNlckRhdGEub3JpZW50YXRpb25RdWF0ID0gbmV3IE9yaWVudGF0aW9uUXVhdDNEKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWl4ZXIgc2VuZHMgUXVhdGVybmlvbiBjb21wb25lbnQgZGF0YSBtdWx0aXBsaWVkIGJ5IDEwMDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgdzogcGVlckRhdGFGcm9tTWl4ZXIuVyAvIDEwMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHBlZXJEYXRhRnJvbU1peGVyLlggLyAxMDAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBwZWVyRGF0YUZyb21NaXhlci5ZIC8gMTAwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgejogcGVlckRhdGFGcm9tTWl4ZXIuWiAvIDEwMDBcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJTZW50TmV3VXNlckRhdGEgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGBSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGEuaGlGaUdhaW5gXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwZWVyRGF0YUZyb21NaXhlci5nKSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1VzZXJEYXRhLmhpRmlHYWluID0gcGVlckRhdGFGcm9tTWl4ZXIuZztcclxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJTZW50TmV3VXNlckRhdGEgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGBSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGEudm9sdW1lRGVjaWJlbHNgXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwZWVyRGF0YUZyb21NaXhlci52KSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1VzZXJEYXRhLnZvbHVtZURlY2liZWxzID0gcGVlckRhdGFGcm9tTWl4ZXIudjtcclxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJTZW50TmV3VXNlckRhdGEgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzZXJ2ZXJTZW50TmV3VXNlckRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxOZXdVc2VyRGF0YS5wdXNoKG5ld1VzZXJEYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMub25Vc2VyRGF0YVVwZGF0ZWQgJiYgYWxsTmV3VXNlckRhdGEubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vblVzZXJEYXRhVXBkYXRlZChhbGxOZXdVc2VyRGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25uZWN0IHRvIHRoZSBNaXhlciBnaXZlbiBgdGhpcy53ZWJSVENBZGRyZXNzYC5cclxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlamVjdHMgd2l0aCBhbiBlcnJvciBtZXNzYWdlIHN0cmluZyB1cG9uIGZhaWx1cmUsIG9yIHJlc29sdmVzIHdpdGggdGhlIHJlc3BvbnNlIGZyb20gYGF1ZGlvbmV0LmluaXRgIGFzIGEgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBjb25uZWN0KCk6IFByb21pc2U8YW55PiB7XHJcbiAgICAgICAgaWYgKCF0aGlzLndlYlJUQ0FkZHJlc3MpIHtcclxuICAgICAgICAgICAgbGV0IGVyck1zZyA9IGBDb3VsZG4ndCBjb25uZWN0OiBcXGB0aGlzLndlYlJUQ0FkZHJlc3NcXGAgaXMgZmFsc2V5IWA7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyTXNnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRIaUZpQ29ubmVjdGlvblN0YXRlID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9yYXZpU2lnbmFsaW5nQ29ubmVjdGlvbi5vcGVuKHRoaXMud2ViUlRDQWRkcmVzcylcclxuICAgICAgICB9IGNhdGNoIChlcnJvck9wZW5pbmdTaWduYWxpbmdDb25uZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGxldCBlcnJNc2cgPSBgQ291bGRuJ3Qgb3BlbiBzaWduYWxpbmcgY29ubmVjdGlvbiB0byBcXGAke3RoaXMud2ViUlRDQWRkcmVzcy5zbGljZSgwLCB0aGlzLndlYlJUQ0FkZHJlc3MuaW5kZXhPZihcInRva2VuPVwiKSl9PHRva2VuIHJlZGFjdGVkPlxcYCEgRXJyb3I6XFxuJHtlcnJvck9wZW5pbmdTaWduYWxpbmdDb25uZWN0aW9ufWA7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyTXNnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JhdmlTZXNzaW9uLm9wZW4odGhpcy5fcmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yT3BlbmluZ1JBVklTZXNzaW9uKSB7XHJcbiAgICAgICAgICAgIGxldCBlcnJNc2cgPSBgQ291bGRuJ3Qgb3BlbiBSQVZJIHNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIFxcYCR7dGhpcy53ZWJSVENBZGRyZXNzLnNsaWNlKDAsIHRoaXMud2ViUlRDQWRkcmVzcy5pbmRleE9mKFwidG9rZW49XCIpKX08dG9rZW4gcmVkYWN0ZWQ+XFxgISBFcnJvcjpcXG4ke2Vycm9yT3BlbmluZ1JBVklTZXNzaW9ufWA7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyTXNnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBhdWRpb25ldEluaXRSZXNwb25zZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhdWRpb25ldEluaXRSZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvbWlzZVRvUnVuQXVkaW9Jbml0KCk7XHJcbiAgICAgICAgfSBjYXRjaCAoaW5pdEVycm9yKSB7XHJcbiAgICAgICAgICAgIGxldCBlcnJNc2cgPSBgXFxgYXVkaW9uZXQuaW5pdFxcYCBjb21tYW5kIGZhaWxlZCEgRXJyb3I6XFxuJHtpbml0RXJyb3IuZXJyb3J9YDtcclxuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJNc2cpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fcmF2aVNlc3Npb24uZ2V0Q29tbWFuZENvbnRyb2xsZXIoKS5hZGRCaW5hcnlIYW5kbGVyKChkYXRhOiBhbnkpID0+IHsgdGhpcy5oYW5kbGVSQVZJU2Vzc2lvbkJpbmFyeURhdGEoZGF0YSkgfSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYXVkaW9uZXRJbml0UmVzcG9uc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGlzY29ubmVjdHMgZnJvbSB0aGUgTWl4ZXIuIENsb3NlcyB0aGUgUkFWSSBTaWduYWxpbmcgQ29ubmVjdGlvbiBhbmQgdGhlIFJBVkkgU2Vzc2lvbi5cclxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IF9hbHdheXNfIFJlc29sdmVzIHdpdGggYSBcInN1Y2Nlc3NcIiBzdGF0dXMgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBkaXNjb25uZWN0KCk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY2xvc2UodGhpbmdUb0Nsb3NlOiAoUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24gfCBSYXZpU2Vzc2lvbiksIG5hbWVPZlRoaW5nVG9DbG9zZTogc3RyaW5nLCBjbG9zZWRTdGF0ZTogc3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGluZ1RvQ2xvc2UpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzdGF0ZSA9IHRoaW5nVG9DbG9zZS5nZXRTdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGluZ1RvQ2xvc2UgfHwgc3RhdGUgPT09IGNsb3NlZFN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgSGlGaUxvZ2dlci5sb2coYFRoZSBSQVZJICR7bmFtZU9mVGhpbmdUb0Nsb3NlfSB3YXMgYWxyZWFkeSBjbG9zZWQuYCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaW5nVG9DbG9zZS5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBIaUZpTG9nZ2VyLmxvZyhgVGhlIFJBVkkgJHtuYW1lT2ZUaGluZ1RvQ2xvc2V9IGNsb3NlZCBzdWNjZXNzZnVsbHkgZnJvbSBzdGF0ZSAke3N0YXRlfS5gKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEhpRmlMb2dnZXIud2FybihgVGhlIFJBVkkgJHtuYW1lT2ZUaGluZ1RvQ2xvc2V9IGRpZG4ndCBjbG9zZSBzdWNjZXNzZnVsbHkgZnJvbSBzdGF0ZSAke3N0YXRlfSEgRXJyb3I6XFxuJHtlfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIEhpRmlMb2dnZXIud2FybihgVGhlIFJBVkkgJHtuYW1lT2ZUaGluZ1RvQ2xvc2V9IHdhcyBtaXNzaW5nLmApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGluZ1RvQ2xvc2UgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYXdhaXQgY2xvc2UodGhpcy5fcmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24sIFwiU2lnbmFsaW5nIENvbm5lY3Rpb25cIiwgU2lnbmFsaW5nU3RhdGVzLkNMT1NFRCk7XHJcbiAgICAgICAgYXdhaXQgY2xvc2UodGhpcy5fcmF2aVNlc3Npb24sIFwiU2Vzc2lvblwiLCBSYXZpU2Vzc2lvblN0YXRlcy5DTE9TRUQpO1xyXG5cclxuICAgICAgICB0aGlzLl9yZXNldE1peGVySW5mbygpO1xyXG5cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGBTdWNjZXNzZnVsbHkgZGlzY29ubmVjdGVkLmApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYXVkaW8gYE1lZGlhU3RyZWFtYCB0aGF0IGlzIHNlbnQgdG8gUkFWSSB0byBiZSBtaXhlZC5cclxuICAgICAqIEBwYXJhbSBpbnB1dEF1ZGlvTWVkaWFTdHJlYW0gVGhlIGBNZWRpYVN0cmVhbWAgdGhhdCBpcyBzZW50IHRvIFJBVkkgdG8gYmUgbWl4ZWQuXHJcbiAgICAgKiBAcGFyYW0gaXNTdGVyZW8gLSBgdHJ1ZWAgaWYgdGhlIGlucHV0IHN0cmVhbSBzaG91bGQgYmUgdHJlYXRlZCBhcyBzdGVyZW8uIERlZmF1bHRzIHRvIGBmYWxzZWAuXHJcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG5ldyBzdHJlYW0gd2FzIHN1Y2Nlc3NmdWxseSBzZXQ7IGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBzZXRSQVZJSW5wdXRBdWRpbyhpbnB1dEF1ZGlvTWVkaWFTdHJlYW06IE1lZGlhU3RyZWFtLCBpc1N0ZXJlbzogYm9vbGVhbiA9IGZhbHNlKTogUHJvbWlzZTxib29sZWFuPiB7XHJcblxyXG4gICAgICAgIGxldCByZXR2YWwgPSBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5fcmF2aVNlc3Npb24pIHtcclxuICAgICAgICAgICAgbGV0IHN0cmVhbUNvbnRyb2xsZXIgPSB0aGlzLl9yYXZpU2Vzc2lvbi5nZXRTdHJlYW1Db250cm9sbGVyKCk7XHJcbiAgICAgICAgICAgIGlmICghc3RyZWFtQ29udHJvbGxlcikge1xyXG4gICAgICAgICAgICAgICAgSGlGaUxvZ2dlci53YXJuKGBDb3VsZG4ndCBzZXQgaW5wdXQgYXVkaW8gb24gX3JhdmlTZXNzaW9uLnN0cmVhbUNvbnRyb2xsZXI6IE5vIFxcYHN0cmVhbUNvbnRyb2xsZXJcXGAhYCk7XHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuc2V0SW5wdXRBdWRpbyhpbnB1dEF1ZGlvTWVkaWFTdHJlYW0sIGlzU3RlcmVvKTtcclxuICAgICAgICAgICAgICAgIEhpRmlMb2dnZXIubG9nKGBTdWNjZXNzZnVsbHkgc2V0IGlucHV0IGF1ZGlvIG9uIF9yYXZpU2Vzc2lvbi5zdHJlYW1Db250cm9sbGVyIWApO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIEhpRmlMb2dnZXIud2FybihgQ291bGRuJ3Qgc2V0IGlucHV0IGF1ZGlvIG9uIF9yYXZpU2Vzc2lvbi5zdHJlYW1Db250cm9sbGVyOiBObyBcXGBfcmF2aVNlc3Npb25cXGAhYCk7XHJcbiAgICAgICAgICAgIHJldHZhbCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJldHZhbCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faW5wdXRBdWRpb01lZGlhU3RyZWFtSXNTdGVyZW8gIT0gaXNTdGVyZW8pIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yYXZpU2Vzc2lvbi5nZXRTdGF0ZSgpID09PSBSYXZpU2Vzc2lvblN0YXRlcy5DT05ORUNURUQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTdGVyZW8gc3RhdHVzIGhhcyBjaGFuZ2VkOyBtYXkgbmVlZCB0byBjYWxsIGF1ZGlvbmV0LmluaXQgYWdhaW4uXHJcbiAgICAgICAgICAgICAgICAgICAgSGlGaUxvZ2dlci53YXJuKGBTdGVyZW8gc3RhdHVzIGhhcyBjaGFuZ2VkIGZyb20gJHt0aGlzLl9pbnB1dEF1ZGlvTWVkaWFTdHJlYW1Jc1N0ZXJlb30gdG8gJHtpc1N0ZXJlb307IGF0dGVtcHRpbmcgdG8gcmUtaW5pdGlhbGl6ZSB3aXRoIHRoZSBtaXhlcmApO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBhdWRpb25ldEluaXRSZXNwb25zZTtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dEF1ZGlvTWVkaWFTdHJlYW1Jc1N0ZXJlbyA9IGlzU3RlcmVvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdWRpb25ldEluaXRSZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvbWlzZVRvUnVuQXVkaW9Jbml0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoaW5pdEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgZ29lcyB3cm9uZywgZG8gd2UgYWN0dWFsbHkgY2FyZSBhbGwgdGhhdCBtdWNoP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCBqdXN0IG1lYW5zIHRoYXQgdGhlIG1peGVyIHdpbGwgY29udGludWUgdG8gdHJlYXQgdGhlIG5ldyBzdHJlYW0gYXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hhdGV2ZXIgc2V0dGluZyBpdCB3YXMgYmVmb3JlLiBGb3Igbm93LCBqdXN0IHJldHVybiB0aGUgZXJyb3IgYW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCB0aGUgdXNlciB0cnkgYWdhaW4gaWYgdGhleSB3YW50LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXJyTXNnID0gYEF0dGVtcHQgdG8gY2FsbCBcXGBhdWRpb25ldC5pbml0XFxgIGZvciBjaGFuZ2UgaW4gc3RlcmVvIHN0YXR1cyBmYWlsZWQhIEVycm9yOlxcbiR7aW5pdEVycm9yLmVycm9yfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJNc2cpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBhbHJlYWR5IGNvbm5lY3RlZCwgaXQnbGwganVzdCBwaWNrIHVwIHRoZSByaWdodCBzdGVyZW8gdmFsdWUgd2hlbiB3ZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgaXQgdGhlIGZpcnN0IHRpbWUuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5wdXRBdWRpb01lZGlhU3RyZWFtSXNTdGVyZW8gPSBpc1N0ZXJlbztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgaW5wdXQgYXVkaW8gc3RyZWFtIHRvIFwibXV0ZWRcIiBieSBkaXNhYmxpbmcgYWxsIG9mIHRoZSB0cmFja3Mgb24gaXRcclxuICAgICAqIChvciB0byBcInVubXV0ZWRcIiBieSBlbmFibGluZyB0aGUgdHJhY2tzIG9uIGl0KS5cclxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3RyZWFtIHdhcyBzdWNjZXNzZnVsbHkgbXV0ZWQvdW5tdXRlZCwgYGZhbHNlYCBpZiBpdCB3YXMgbm90LlxyXG4gICAgICovXHJcbiAgICBhc3luYyBzZXRJbnB1dEF1ZGlvTXV0ZWQobmV3TXV0ZWRWYWx1ZTogYm9vbGVhbik6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgICAgIGxldCBzdHJlYW1Db250cm9sbGVyID0gdGhpcy5fcmF2aVNlc3Npb24uZ2V0U3RyZWFtQ29udHJvbGxlcigpO1xyXG4gICAgICAgIGlmICh0aGlzLl9yYXZpU2Vzc2lvbiAmJiBzdHJlYW1Db250cm9sbGVyKSB7XHJcbiAgICAgICAgICAgIGxldCBoYXNNaWNQZXJtaXNzaW9uID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBpZiAobmF2aWdhdG9yLnBlcm1pc3Npb25zICYmIG5hdmlnYXRvci5wZXJtaXNzaW9ucy5xdWVyeSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdDogUGVybWlzc2lvblN0YXR1cyA9IGF3YWl0IG5hdmlnYXRvci5wZXJtaXNzaW9ucy5xdWVyeSh7IG5hbWU6ICdtaWNyb3Bob25lJyB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdGUgPT09IFwiZ3JhbnRlZFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzTWljUGVybWlzc2lvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghaGFzTWljUGVybWlzc2lvbiB8fCB0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vZGVKUyBjb250ZXh0IE9SIHRoZSB1c2VyIGhhc24ndCBncmFudGVkIG9yIGNhbid0IGdyYW50IHBlcm1hbmVudCBtaWMgcGVybWlzc2lvbnMgdG8gb3VyIHNjcmlwdC4uLlxyXG4gICAgICAgICAgICAgICAgLy8gT24gaU9TIFNhZmFyaSwgdGhlIHVzZXIgX2Nhbid0XyBncmFudCBwZXJtYW5lbnQgbWljIHBlcm1pc3Npb25zIHRvIG91ciBzY3JpcHQuXHJcbiAgICAgICAgICAgICAgICBsZXQgcmF2aUF1ZGlvU3RyZWFtID0gc3RyZWFtQ29udHJvbGxlci5faW5wdXRBdWRpb1N0cmVhbTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocmF2aUF1ZGlvU3RyZWFtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmF2aUF1ZGlvU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrLmVuYWJsZWQgPSAhbmV3TXV0ZWRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBIaUZpTG9nZ2VyLmxvZyhgU3VjY2Vzc2Z1bGx5IHNldCBtdXRlIHN0YXRlIHRvICR7bmV3TXV0ZWRWYWx1ZX0gb24gX3JhdmlTZXNzaW9uLnN0cmVhbUNvbnRyb2xsZXIuX2lucHV0QXVkaW9TdHJlYW1gKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgSGlGaUxvZ2dlci53YXJuKGBDb3VsZG4ndCBzZXQgbXV0ZSBzdGF0ZTogTm8gXFxgX2lucHV0QXVkaW9TdHJlYW1cXGAgb24gXFxgX3JhdmlTZXNzaW9uLnN0cmVhbUNvbnRyb2xsZXJcXGAuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgYnJvd3NlciBjb250ZXh0LCBpZiBhbmQgb25seSBpZiB0aGUgdXNlciBoYXMgZ3JhbnRlZCBtaWMgcGVybWlzc2lvbnMgdG8gb3VyIHNjcmlwdCxcclxuICAgICAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8gY2FsbCBgc3RvcCgpYCBvbiBhbGwgYE1lZGlhU3RyZWFtVHJhY2tgcyBhc3NvY2lhdGVkIHdpdGggdGhlXHJcbiAgICAgICAgICAgICAgICAvLyB1c2VyJ3MgYXVkaW8gaW5wdXQgZGV2aWNlIHN0cmVhbS4gVGhpcyBpcyB0byBob3BlZnVsbHkgYWxsb3cgdGhlIE9TIHRvIHN3aXRjaCB0aGUgdXNlcidzIG91dHB1dCBhdWRpbyBkZXZpY2VcclxuICAgICAgICAgICAgICAgIC8vIGludG8gaGFsZi1kdXBsZXggKGkuZS4gc3RlcmVvKSBtb2RlIGluIHRoZSBjYXNlIHdoZXJlIHRoYXQgb3V0cHV0IGRldmljZSBpcyBCbHVldG9vdGguXHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBoYXNuJ3QgZ3JhbnRlZCBwZXJtYW5lbnQgbWljIHBlcm1pc3Npb25zIHRvIG91ciBzY3JpcHQsIGRvaW5nIHRoaXMgd291bGQgYnJlYWsgZmVhdHVyZXMgbGlrZSBwdXNoLXRvLXRhbGssXHJcbiAgICAgICAgICAgICAgICAvLyBhcyB0aGUgYnJvd3NlciB3b3VsZCBwcm9tcHQgdGhlIHVzZXIgZm9yIHBlcm1pc3Npb24gdG8gYWNjZXNzIHRoZSBtaWNyb3Bob25lIGV2ZXJ5IHRpbWUgdGhleSB1bm11dGVkLlxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vIFdlIG1heSBub3Qgd2FudCB0byB1c2UgdGhpcyBjb2RlIGJyYW5jaCBhdCBhbGwsIGFzIGdldHRpbmcgYSBicmFuZC1uZXcgYE1lZGlhU3RyZWFtYCBldmVyeSB0aW1lIHRoZSB1c2VyIHVubXV0ZXNcclxuICAgICAgICAgICAgICAgIC8vIG1heSBpbnRyb2R1Y2UgdW53YW50ZWQgZGVsYXkgb24gc2xvd2VyIGRldmljZXMuIEFkZGl0aW9uYWxseSwgc2luY2UgdGhlIHVzZXIgY2FuIF9uZXZlcl8gZ3JhbnQgcGVybWFuZW50IG1pYyBwZXJtaXNzaW9uc1xyXG4gICAgICAgICAgICAgICAgLy8gdG8gb3VyIHNjcmlwdCBvbiBpT1MsIGFuZCBtYW55IG9mIG91ciBwcm9ibGVtcyB3aXRoIGhhbGYtZHVwbGV4IGF1ZGlvIGFyZSBvbiBpT1MsIHdlIG1heSBzZWUgbm8gZ2FpbiBmcm9tIGFkZGluZyB0aGlzIGNvZGUuXHJcbiAgICAgICAgICAgICAgICBsZXQgcmF2aUF1ZGlvU3RyZWFtID0gc3RyZWFtQ29udHJvbGxlci5faW5wdXRBdWRpb1N0cmVhbTtcclxuICAgICAgICAgICAgICAgIGlmIChyYXZpQXVkaW9TdHJlYW0gJiYgbmV3TXV0ZWRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhdmlBdWRpb1N0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjazogTWVkaWFTdHJlYW1UcmFjaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYE1lZGlhVHJhY2tDb25zdHJhaW50c2AgYXJlIHZlcnkgbGlrZWx5IHRvIGJlIHRoZSBzYW1lIGFjcm9zcyBhbGwgYE1lZGlhU3RyZWFtVHJhY2tzYC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGh1cywgaW4gdGhlIGNhc2Ugb2Ygb3ZlcndyaXRpbmcgdGhpcyB2YWx1ZSBtdWx0aXBsZSB0aW1lcyBkdWUgdG8gbXVsdGlwbGUgdHJhY2tzIGNvbnRhaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXRoaW4gdGhlIGByYXZpQXVkaW9TdHJlYW1gLCB0aGVyZSBzaG91bGQgYmUgbm8gcHJvYmxlbXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZE1lZGlhVHJhY2tDb25zdHJhaW50cyA9IHRyYWNrLmdldENvbnN0cmFpbnRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnNldElucHV0QXVkaW8obnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgSGlGaUxvZ2dlci5sb2coYFN1Y2Nlc3NmdWxseSBzZXQgbXV0ZSBzdGF0ZSB0byBcXGB0cnVlXFxgIGJ5IHN0b3BwaW5nIGFsbCBpbnB1dCBtZWRpYSB0cmFja3MhYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFyYXZpQXVkaW9TdHJlYW0gJiYgIW5ld011dGVkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3TWVkaWFTdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7IGF1ZGlvOiB0aGlzLl9jYWNoZWRNZWRpYVRyYWNrQ29uc3RyYWludHMsIHZpZGVvOiBmYWxzZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnNldElucHV0QXVkaW8obmV3TWVkaWFTdHJlYW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIEhpRmlMb2dnZXIubG9nKGBTdWNjZXNzZnVsbHkgc2V0IG11dGUgc3RhdGUgdG8gXFxgZmFsc2VcXGAgYnkgZ2V0dGluZyBuZXcgaW5wdXQgbWVkaWEgc3RyZWFtIWApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyYXZpQXVkaW9TdHJlYW0gJiYgIW5ld011dGVkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByYXZpQXVkaW9TdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCgodHJhY2s6IE1lZGlhU3RyZWFtVHJhY2spID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2suZW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgSGlGaUxvZ2dlci5sb2coYFN1Y2Nlc3NmdWxseSBzZXQgbXV0ZSBzdGF0ZSB0byBcXGBmYWxzZVxcYCBieSBlbmFibGluZyBhbGwgdHJhY2tzIG9uIFxcYF9yYXZpU2Vzc2lvbi5zdHJlYW1Db250cm9sbGVyLl9pbnB1dEF1ZGlvU3RyZWFtXFxgIWApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBIaUZpTG9nZ2VyLndhcm4oYENvdWxkbid0IHNldCBtdXRlIHN0YXRlOiBObyBcXGBfaW5wdXRBdWRpb1N0cmVhbVxcYCBvbiBcXGBfcmF2aVNlc3Npb24uc3RyZWFtQ29udHJvbGxlclxcYC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIEhpRmlMb2dnZXIud2FybihgQ291bGRuJ3Qgc2V0IG11dGUgc3RhdGU6IE5vIFxcYF9yYXZpU2Vzc2lvblxcYCwgb3IgXFxgX3JhdmlTZXNzaW9uLmdldFN0cmVhbUNvbnRyb2xsZXIoKVxcYCByZXR1cm5lZCBudWxsLmApO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgb3V0cHV0IGBNZWRpYVN0cmVhbWAgZnJvbSB0aGUgTWl4ZXIuIFRoaXMgaXMgdGhlIGZpbmFsLCBtaXhlZCwgc3BhdGlhbGl6ZWQgYXVkaW8gc3RyZWFtIGNvbnRhaW5pbmdcclxuICAgICAqIGFsbCBzb3VyY2VzIHNlbnQgdG8gdGhlIE1peGVyLlxyXG4gICAgICogQHJldHVybnMgVGhlIG1peGVkLCBzcGF0aWFsaXplZCBgTWVkaWFTdHJlYW1gIGZyb20gdGhlIE1peGVyLiBSZXR1cm5zIGBudWxsYCBpZiBpdCdzIG5vdCBwb3NzaWJsZSB0byBvYnRhaW4gdGhhdCBgTWVkaWFTdHJlYW1gLlxyXG4gICAgICovXHJcbiAgICBnZXRPdXRwdXRBdWRpb01lZGlhU3RyZWFtKCk6IE1lZGlhU3RyZWFtIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3JhdmlTZXNzaW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHN0cmVhbUNvbnRyb2xsZXIgPSB0aGlzLl9yYXZpU2Vzc2lvbi5nZXRTdHJlYW1Db250cm9sbGVyKCk7XHJcblxyXG4gICAgICAgIGlmICghc3RyZWFtQ29udHJvbGxlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdHJlYW1Db250cm9sbGVyLmdldEF1ZGlvU3RyZWFtKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBSQVZJIFNpZ25hbGluZyBTdGF0ZSBjaGFudGdlcy5cclxuICAgICAqIEBwYXJhbSBldmVudCBcclxuICAgICAqL1xyXG4gICAgb25SQVZJU2lnbmFsaW5nU3RhdGVDaGFuZ2VkKGV2ZW50OiBhbnkpOiB2b2lkIHtcclxuICAgICAgICBIaUZpTG9nZ2VyLmxvZyhgTmV3IFJBVkkgc2lnbmFsaW5nIHN0YXRlOiBcXGAke2V2ZW50LnN0YXRlfVxcYGApO1xyXG4gICAgICAgIHN3aXRjaCAoZXZlbnQuc3RhdGUpIHtcclxuICAgICAgICAgICAgY2FzZSBTaWduYWxpbmdTdGF0ZXMuVU5BVkFJTEFCTEU6XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUNvbm5lY3Rpb25TdGF0ZSA9IEhpRmlDb25uZWN0aW9uU3RhdGVzLlVuYXZhaWxhYmxlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25Db25uZWN0aW9uU3RhdGVDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQodGhpcy5fY3VycmVudEhpRmlDb25uZWN0aW9uU3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBSQVZJIFNlc3Npb24gU3RhdGUgY2hhbmdlcy5cclxuICAgICAqIEBwYXJhbSBldmVudFxyXG4gICAgICovXHJcbiAgICBvblJBVklTZXNzaW9uU3RhdGVDaGFuZ2VkKGV2ZW50OiBhbnkpOiB2b2lkIHtcclxuICAgICAgICBIaUZpTG9nZ2VyLmxvZyhgTmV3IFJBVkkgc2Vzc2lvbiBzdGF0ZTogXFxgJHtldmVudC5zdGF0ZX1cXGBgKTtcclxuICAgICAgICBzd2l0Y2ggKGV2ZW50LnN0YXRlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgUmF2aVNlc3Npb25TdGF0ZXMuQ09OTkVDVEVEOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWl4ZXJQZWVyS2V5VG9Qcm92aWRlZFVzZXJJRERpY3QgPSB7fTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21peGVyUGVlcktleVRvSGFzaGVkVmlzaXRJRERpY3QgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUNvbm5lY3Rpb25TdGF0ZSA9IEhpRmlDb25uZWN0aW9uU3RhdGVzLkNvbm5lY3RlZDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCh0aGlzLl9jdXJyZW50SGlGaUNvbm5lY3Rpb25TdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBSYXZpU2Vzc2lvblN0YXRlcy5ESVNDT05ORUNURUQ6XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudEhpRmlDb25uZWN0aW9uU3RhdGUgPT09IEhpRmlDb25uZWN0aW9uU3RhdGVzLlVuYXZhaWxhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEhpRmlDb25uZWN0aW9uU3RhdGUgPSBIaUZpQ29ubmVjdGlvblN0YXRlcy5EaXNjb25uZWN0ZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25Db25uZWN0aW9uU3RhdGVDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQodGhpcy5fY3VycmVudEhpRmlDb25uZWN0aW9uU3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgUmF2aVNlc3Npb25TdGF0ZXMuRkFJTEVEOlxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRIaUZpQ29ubmVjdGlvblN0YXRlID09PSBIaUZpQ29ubmVjdGlvblN0YXRlcy5VbmF2YWlsYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRIaUZpQ29ubmVjdGlvblN0YXRlID0gSGlGaUNvbm5lY3Rpb25TdGF0ZXMuRmFpbGVkO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Db25uZWN0aW9uU3RhdGVDaGFuZ2VkKHRoaXMuX2N1cnJlbnRIaUZpQ29ubmVjdGlvblN0YXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH0gICAgXHJcblxyXG4gICAgc3RhcnRDb2xsZWN0aW5nV2ViUlRDU3RhdHMoY2FsbGJhY2s6IEZ1bmN0aW9uKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9yYXZpU2Vzc2lvbikge1xyXG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBDb3VsZG4ndCBzdGFydCBjb2xsZWN0aW5nIFdlYlJUQyBzdGF0czogTm8gXFxgX3JhdmlTZXNzaW9uXFxgIWApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5fc3RhdHNPYnNlcnZlckNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcENvbGxlY3RpbmdXZWJSVENTdGF0cygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fc3RhdHNPYnNlcnZlckNhbGxiYWNrID0gY2FsbGJhY2s7XHJcblxyXG4gICAgICAgIHRoaXMuX3JhdmlTZXNzaW9uLmFkZFN0YXRzT2JzZXJ2ZXIodGhpcy5fc3RhdHNPYnNlcnZlckNhbGxiYWNrKTtcclxuICAgIH1cclxuXHJcbiAgICBzdG9wQ29sbGVjdGluZ1dlYlJUQ1N0YXRzKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fcmF2aVNlc3Npb24pIHtcclxuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgQ291bGRuJ3Qgc3RvcCBjb2xsZWN0aW5nIFdlYlJUQyBzdGF0czogTm8gXFxgX3JhdmlTZXNzaW9uXFxgIWApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9yYXZpU2Vzc2lvbi5yZW1vdmVTdGF0c09ic2VydmVyKHRoaXMuX3N0YXRzT2JzZXJ2ZXJDYWxsYmFjayk7XHJcblxyXG4gICAgICAgIHRoaXMuX3N0YXRzT2JzZXJ2ZXJDYWxsYmFjayA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIElmIHRoaXMgb3BlcmF0aW9uIGlzIHN1Y2Nlc3NmdWwsIHJldHVybnMgYHsgc3VjY2VzczogdHJ1ZSwgc3RyaW5naWZpZWREYXRhRm9yTWl4ZXI6IDx0aGUgcmF3IGRhdGEgdGhhdCB3YXMgdHJhbnNtaXR0ZWQgdG8gdGhlIHNlcnZlcj59YC4gSWYgdW5zdWNjZXNzZnVsLCByZXR1cm5zXHJcbiAgICAgKiBgeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IDxhbiBlcnJvciBtZXNzYWdlPiB9YC5cclxuICAgICAqL1xyXG4gICAgX3RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YVRvU2VydmVyKGhpZmlBdWRpb0FQSURhdGE6IEhpRmlBdWRpb0FQSURhdGEpOiBhbnkge1xyXG4gICAgICAgIGlmICghdGhpcy5taXhlckluZm9bXCJjb25uZWN0ZWRcIl0gfHwgIXRoaXMuX3JhdmlTZXNzaW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGVycm9yOiBgQ2FuJ3QgdHJhbnNtaXQgZGF0YSB0byBtaXhlcjsgbm90IGNvbm5lY3RlZCB0byBtaXhlci5gXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZGF0YUZvck1peGVyOiBhbnkgPSB7fTtcclxuXHJcbiAgICAgICAgaWYgKGhpZmlBdWRpb0FQSURhdGEucG9zaXRpb24pIHtcclxuICAgICAgICAgICAgbGV0IHRyYW5zbGF0ZWRQb3NpdGlvbiA9IEhpRmlBeGlzVXRpbGl0aWVzLnRyYW5zbGF0ZVBvaW50M0RUb01peGVyU3BhY2Uob3VySGlGaUF4aXNDb25maWd1cmF0aW9uLCBoaWZpQXVkaW9BUElEYXRhLnBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFBvc2l0aW9uIGRhdGEgaXMgc2VudCBpbiBtaWxsaW1ldGVycyBpbnRlZ2VycyB0byByZWR1Y2UgSlNPTiBzaXplLlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mICh0cmFuc2xhdGVkUG9zaXRpb24ueCkgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgIGRhdGFGb3JNaXhlcltcInhcIl0gPSBNYXRoLnJvdW5kKHRyYW5zbGF0ZWRQb3NpdGlvbi54ICogMTAwMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiAodHJhbnNsYXRlZFBvc2l0aW9uLnkpID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhRm9yTWl4ZXJbXCJ5XCJdID0gTWF0aC5yb3VuZCh0cmFuc2xhdGVkUG9zaXRpb24ueSAqIDEwMDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHRyYW5zbGF0ZWRQb3NpdGlvbi56KSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgZGF0YUZvck1peGVyW1wielwiXSA9IE1hdGgucm91bmQodHJhbnNsYXRlZFBvc2l0aW9uLnogKiAxMDAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGhpZmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25FdWxlcikge1xyXG4gICAgICAgICAgICBsZXQgdHJhbnNsYXRlZE9yaWVudGF0aW9uID0gSGlGaUF4aXNVdGlsaXRpZXMudHJhbnNsYXRlT3JpZW50YXRpb25FdWxlcjNEVG9NaXhlclNwYWNlKG91ckhpRmlBeGlzQ29uZmlndXJhdGlvbiwgaGlmaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvbkV1bGVyKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHRyYW5zbGF0ZWRPcmllbnRhdGlvbi5waXRjaERlZ3JlZXMpID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhRm9yTWl4ZXJbXCJrXCJdID0gdHJhbnNsYXRlZE9yaWVudGF0aW9uLnBpdGNoRGVncmVlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mICh0cmFuc2xhdGVkT3JpZW50YXRpb24ueWF3RGVncmVlcykgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgIGRhdGFGb3JNaXhlcltcIm9cIl0gPSB0cmFuc2xhdGVkT3JpZW50YXRpb24ueWF3RGVncmVlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mICh0cmFuc2xhdGVkT3JpZW50YXRpb24ucm9sbERlZ3JlZXMpID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhRm9yTWl4ZXJbXCJsXCJdID0gdHJhbnNsYXRlZE9yaWVudGF0aW9uLnJvbGxEZWdyZWVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUaGUgbWl4ZXIgZXhwZWN0cyBRdWF0ZXJuaW9uIGNvbXBvbmVudHMgdG8gYmUgbXVsaXRpcGxpZWQgYnkgMTAwMC5cclxuICAgICAgICBpZiAoaGlmaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiAoaGlmaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQudykgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgIGRhdGFGb3JNaXhlcltcIldcIl0gPSBoaWZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC53ICogMTAwMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIChoaWZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC54KSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgZGF0YUZvck1peGVyW1wiWFwiXSA9IGhpZmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0LnggKiAxMDAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGhpZmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0LnkpID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhRm9yTWl4ZXJbXCJZXCJdID0gaGlmaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQueSAqIDEwMDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiAoaGlmaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQueikgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgIGRhdGFGb3JNaXhlcltcIlpcIl0gPSBoaWZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC56ICogMTAwMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiAoaGlmaUF1ZGlvQVBJRGF0YS5oaUZpR2FpbikgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgZGF0YUZvck1peGVyW1wiZ1wiXSA9IE1hdGgubWF4KDAsIGhpZmlBdWRpb0FQSURhdGEuaGlGaUdhaW4pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGRhdGFGb3JNaXhlcikubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGNhbGwgdGhpcyBhIFwic3VjY2Vzc1wiIGV2ZW4gdGhvdWdoIHdlIGRpZG4ndCBzZW5kIGFueXRoaW5nIHRvIHRoZSBtaXhlci5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzdHJpbmdpZmllZERhdGFGb3JNaXhlcjogSlNPTi5zdHJpbmdpZnkoe30pXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IGNvbW1hbmRDb250cm9sbGVyID0gdGhpcy5fcmF2aVNlc3Npb24uZ2V0Q29tbWFuZENvbnRyb2xsZXIoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjb21tYW5kQ29udHJvbGxlcikge1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0cmluZ2lmaWVkRGF0YUZvck1peGVyID0gSlNPTi5zdHJpbmdpZnkoZGF0YUZvck1peGVyKTtcclxuICAgICAgICAgICAgICAgIGNvbW1hbmRDb250cm9sbGVyLnNlbmRJbnB1dChzdHJpbmdpZmllZERhdGFGb3JNaXhlcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5naWZpZWREYXRhRm9yTWl4ZXI6IHN0cmluZ2lmaWVkRGF0YUZvck1peGVyXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogYENhbid0IHRyYW5zbWl0IGRhdGEgdG8gbWl4ZXI7IG5vIFxcYGNvbW1hbmRDb250cm9sbGVyXFxgIS5gXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIG91ciBcIk1peGVyIEluZm9cIi4gSGFwcGVucyB1cG9uIGluc3RhbnRpYXRpb24gYW5kIHdoZW4gZGlzY29ubmVjdGluZyBmcm9tIHRoZSBtaXhlci5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfcmVzZXRNaXhlckluZm8oKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5taXhlckluZm8gPSB7XHJcbiAgICAgICAgICAgIFwiY29ubmVjdGVkXCI6IGZhbHNlLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIFRoaXMgbW9kdWxlIHBlcnRhaW5zIHRvIFVzZXIgRGF0YSBTdWJzY3JpcHRpb25zLCB3aGljaCBhbGxvdyBjbGllbnRzIHRvIHJlY2VpdmUgdXBkYXRlcyBmcm9tIHRoZSBTZXJ2ZXIgYWJvdXQgYWxsIG5ldyBVc2VyIERhdGEuXHJcbiAqIFNlZSBbW2FkZFVzZXJEYXRhU3Vic2NyaXB0aW9uXV0uXHJcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXaGVuIGFkZGluZyBhIG5ldyBVc2VyIERhdGEgU3Vic2NyaXB0aW9uLCBhIGNsaWVudCBtdXN0IHNwZWNpZnkgb25lIG9mIHRoZSBcImNvbXBvbmVudHNcIiBsaXN0ZWQgYXMgYSBwYXJ0IG9mIHRoaXMgYGVudW1gLlxyXG4gKiBGb3IgZXhhbXBsZSwgc3Vic2NyaWJpbmcgdG8gYFBvc2l0aW9uYCB1cGRhdGVzIGVuc3VyZXMgdGhhdCBhIFN1YnNjcmliZXIgd2lsbCByZWNlaXZlIGFsbCBjaGFuZ2VzIHRvIHRoYXQgdXNlcidzIHBvc2l0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGVudW0gQXZhaWxhYmxlVXNlckRhdGFTdWJzY3JpcHRpb25Db21wb25lbnRzIHtcclxuICAgIFBvc2l0aW9uID0gXCJQb3NpdGlvblwiLFxyXG4gICAgT3JpZW50YXRpb25FdWxlciA9IFwiT3JpZW50YXRpb24gKEV1bGVyKVwiLFxyXG4gICAgT3JpZW50YXRpb25RdWF0ID0gXCJPcmllbnRhdGlvbiAoUXVhdGVybmlvbilcIixcclxuICAgIFZvbHVtZURlY2liZWxzID0gXCJWb2x1bWUgKERlY2liZWxzKVwiLFxyXG4gICAgSGlGaUdhaW4gPSBcIkhpRmlHYWluXCJcclxufVxyXG5cclxuLyoqXHJcbiAqIFVzZXIgRGF0YSBTdWJzY3JpcHRpb25zIGFsbG93IGNsaWVudCBBUEkgdXNlcnMgdG8gcGVyZm9ybSBhY3Rpb25zLCBzdWNoIGFzIGxvZ2dpbmcsIHdoZW4gdGhlIGNsaWVudFxyXG4gKiByZWNlaXZlcyBuZXcgVXNlciBEYXRhIGZyb20gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJIFNlcnZlci5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBVc2VyRGF0YVN1YnNjcmlwdGlvbiB7XHJcbiAgICBwcm92aWRlZFVzZXJJRDogc3RyaW5nO1xyXG4gICAgY29tcG9uZW50czogQXJyYXk8QXZhaWxhYmxlVXNlckRhdGFTdWJzY3JpcHRpb25Db21wb25lbnRzPjtcclxuICAgIGNhbGxiYWNrOiBGdW5jdGlvbjtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IF9fbmFtZWRQYXJhbWV0ZXJzXHJcbiAgICAgKiBAcGFyYW0gcHJvdmlkZWRVc2VySUQgLSBUaGUgdXNlcidzIGBwcm92aWRlZFVzZXJJRGAgYXNzb2NpYXRlZCB3aXRoIHRoZSBTdWJzY3JpcHRpb24uIFNlZSB7QGxpbmsgSGlGaUF1ZGlvQVBJRGF0YX0uIE9wdGlvbmFsLiBJZiB1bnNldCwgdGhlIFN1YnNjcmlwdGlvbiBjYWxsYmFja1xyXG4gICAgICogd2lsbCBiZSBjYWxsZWQgZm9yIGFsbCB1c2VycycgZGF0YSB3aGVuIGl0IGNoYW5nZXMuXHJcbiAgICAgKiBAcGFyYW0gY29tcG9uZW50cyAtIFRoZSBVc2VyIERhdGEgY29tcG9uZW50cyB0byB3aGljaCB3ZSB3YW50IHRvIHN1YnNjcmliZSwgc3VjaCBhcyBQb3NpdGlvbiwgT3JpZW50YXRpb25FdWxlciwgb3IgVm9sdW1lRGVjaWJlbHMuXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBjbGllbnQgcmVjZWl2ZXMgbmV3IFVzZXIgRGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGBjb21wb25lbnRgIGZyb20gdGhlIHNlcnZlci5cclxuICAgICAqIFRoZSBmaXJzdCBhbmQgb25seSBhcmd1bWVudCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCBiZSBvZiB0eXBlIGBBcnJheTxSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGE+YC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoeyBwcm92aWRlZFVzZXJJRCA9IG51bGwsIGNvbXBvbmVudHMsIGNhbGxiYWNrIH06IHsgcHJvdmlkZWRVc2VySUQ/OiBzdHJpbmcsIGNvbXBvbmVudHM6IEFycmF5PEF2YWlsYWJsZVVzZXJEYXRhU3Vic2NyaXB0aW9uQ29tcG9uZW50cz4sIGNhbGxiYWNrOiBGdW5jdGlvbiB9KSB7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlZFVzZXJJRCA9IHByb3ZpZGVkVXNlcklEO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IGNvbXBvbmVudHM7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgfVxyXG59IiwiLyoqXHJcbiAqIFRoaXMgbW9kdWxlIGRlZmluZXMgYSBudW1iZXIgb2YgY29uc3RhbnRzIHVzZWQgdGhyb3VnaG91dCB0aGUgQVBJIGNvZGUuXHJcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBEZWZpbmVzIGEgbnVtYmVyIG9mIGNvbnN0YW50cyB1c2VkIHRocm91Z2hvdXQgdGhlIEFQSSBjb2RlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEhpRmlDb25zdGFudHMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIHRoZSBtaW5pbXVtIGFtb3VudCBvZiB0aW1lIHRoYXQgbXVzdCBwYXNzIGJldHdlZW4gQVBJIHRyYW5zbWlzc2lvblxyXG4gICAgICogb2YgZGF0YSBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlci5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIE1JTl9UUkFOU01JVF9SQVRFX0xJTUlUX1RJTUVPVVRfTVM6IG51bWJlciA9IDEwO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIHRoZSBkZWZhdWx0IGFtb3VudCBvZiB0aW1lIHRoYXQgbXVzdCBwYXNzIGJldHdlZW4gQVBJIHRyYW5zbWlzc2lvblxyXG4gICAgICogb2YgZGF0YSBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlci5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIERFRkFVTFRfVFJBTlNNSVRfUkFURV9MSU1JVF9USU1FT1VUX01TOiBudW1iZXIgPSA1MDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHByb2R1Y3Rpb24gZW5kcG9pbnQgZm9yIG91ciBIaWdoIEZpZGVsaXR5IGF1ZGlvIGNvbm5lY3Rpb25zLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgREVGQVVMVF9QUk9EX0hJR0hfRklERUxJVFlfRU5EUE9JTlQ6IHN0cmluZyA9IFwid3NzOi8vYXBpLmhpZ2hmaWRlbGl0eS5jb206ODAwMVwiO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge31cclxufTtcclxuIiwiZGVjbGFyZSB2YXIgSElGSV9BUElfVkVSU0lPTjogc3RyaW5nO1xyXG5cclxuaW1wb3J0IHsgSGlGaUF1ZGlvQVBJRGF0YSwgUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhLCBPcmllbnRhdGlvbkV1bGVyM0QsIE9yaWVudGF0aW9uUXVhdDNELCBQb2ludDNEIH0gZnJvbSBcIi4vY2xhc3Nlcy9IaUZpQXVkaW9BUElEYXRhXCI7XHJcbmltcG9ydCB7IEhpRmlDb21tdW5pY2F0b3IsIEhpRmlDb25uZWN0aW9uU3RhdGVzLCBIaUZpVXNlckRhdGFTdHJlYW1pbmdTY29wZXMgfSBmcm9tIFwiLi9jbGFzc2VzL0hpRmlDb21tdW5pY2F0b3JcIjtcclxuaW1wb3J0IHsgQXZhaWxhYmxlVXNlckRhdGFTdWJzY3JpcHRpb25Db21wb25lbnRzLCBVc2VyRGF0YVN1YnNjcmlwdGlvbiB9IGZyb20gXCIuL2NsYXNzZXMvSGlGaVVzZXJEYXRhU3Vic2NyaXB0aW9uXCI7XHJcbmltcG9ydCB7IEhpRmlMb2dMZXZlbCwgSGlGaUxvZ2dlciB9IGZyb20gXCIuL3V0aWxpdGllcy9IaUZpTG9nZ2VyXCI7XHJcbmltcG9ydCB7IGdldEJlc3RBdWRpb0NvbnN0cmFpbnRzLCBwcmVjaXNlSW50ZXJ2YWwgfSBmcm9tIFwiLi91dGlsaXRpZXMvSGlGaVV0aWxpdGllc1wiO1xyXG5pbXBvcnQgeyBIaUZpQ29uc3RhbnRzIH0gZnJvbSBcIi4vY29uc3RhbnRzL0hpRmlDb25zdGFudHNcIjtcclxuaW1wb3J0IHsgSGlGaUF4ZXMsIEhpRmlIYW5kZWRuZXNzLCBIaUZpQXhpc0NvbmZpZ3VyYXRpb24gfSBmcm9tIFwiLi9jbGFzc2VzL0hpRmlBeGlzQ29uZmlndXJhdGlvblwiO1xyXG5cclxubGV0IGlzQnJvd3NlckNvbnRleHQgPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCc7XHJcbmlmIChpc0Jyb3dzZXJDb250ZXh0KSB7XHJcbiAgICBleHBvcnRzLkhpRmlBUElWZXJzaW9uID0gSElGSV9BUElfVkVSU0lPTjtcclxufVxyXG5cclxuZXhwb3J0cy5IaUZpQ29tbXVuaWNhdG9yID0gSGlGaUNvbW11bmljYXRvcjtcclxuZXhwb3J0cy5IaUZpQ29ubmVjdGlvblN0YXRlcyA9IEhpRmlDb25uZWN0aW9uU3RhdGVzO1xyXG5leHBvcnRzLkhpRmlVc2VyRGF0YVN0cmVhbWluZ1Njb3BlcyA9IEhpRmlVc2VyRGF0YVN0cmVhbWluZ1Njb3BlcztcclxuXHJcbmV4cG9ydHMuQXZhaWxhYmxlVXNlckRhdGFTdWJzY3JpcHRpb25Db21wb25lbnRzID0gQXZhaWxhYmxlVXNlckRhdGFTdWJzY3JpcHRpb25Db21wb25lbnRzO1xyXG5leHBvcnRzLlVzZXJEYXRhU3Vic2NyaXB0aW9uID0gVXNlckRhdGFTdWJzY3JpcHRpb247XHJcblxyXG5leHBvcnRzLlJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YSA9IFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YTtcclxuZXhwb3J0cy5IaUZpQXVkaW9BUElEYXRhID0gSGlGaUF1ZGlvQVBJRGF0YTtcclxuZXhwb3J0cy5Qb2ludDNEID0gUG9pbnQzRDtcclxuZXhwb3J0cy5PcmllbnRhdGlvbkV1bGVyM0QgPSBPcmllbnRhdGlvbkV1bGVyM0Q7XHJcbmV4cG9ydHMuT3JpZW50YXRpb25RdWF0M0QgPSBPcmllbnRhdGlvblF1YXQzRDtcclxuXHJcbmV4cG9ydHMuSGlGaUxvZ2dlciA9IEhpRmlMb2dnZXI7XHJcbmV4cG9ydHMuSGlGaUxvZ0xldmVsID0gSGlGaUxvZ0xldmVsO1xyXG5cclxuZXhwb3J0cy5nZXRCZXN0QXVkaW9Db25zdHJhaW50cyA9IGdldEJlc3RBdWRpb0NvbnN0cmFpbnRzO1xyXG5leHBvcnRzLnByZWNpc2VJbnRlcnZhbCA9IHByZWNpc2VJbnRlcnZhbDtcclxuXHJcbmV4cG9ydHMuSGlGaUNvbnN0YW50cyA9IEhpRmlDb25zdGFudHM7XHJcblxyXG5leHBvcnRzLkhpRmlBeGVzID0gSGlGaUF4ZXM7XHJcbmV4cG9ydHMuSGlGaUhhbmRlZG5lc3MgPSBIaUZpSGFuZGVkbmVzcztcclxuZXhwb3J0cy5IaUZpQXhpc0NvbmZpZ3VyYXRpb24gPSBIaUZpQXhpc0NvbmZpZ3VyYXRpb247IiwiaW1wb3J0IHsgUmF2aVV0aWxzIH0gZnJvbSAnLi9SYXZpVXRpbHMnO1xuXG4vKipcbiAqIFVzZWQgZm9yIHN0b3JpbmcgdGhlIGJpbmFyeSBjb21tYW5kIGhhbmRsZXJzXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBfQklOQVJZX0NPTU1BTkRfS0VZID0gXCJfQklOQVJZXCI7XG5cblxuLyoqXG4gKiBNb3VzZSBzdGF0ZSBtZXNzYWdlIGlzIDcgZmxvYXRzIGFrYSA3ICogNCA9IDI4IGJ5dGVzXG4gKi9cbmNvbnN0IF9NT1VTRV9TVEFURV9CVUZGRVJfU0laRSA9IDI4O1xuXG5lbnVtIF9LRVlfQ09ERV9UQUJMRSB7XG4gIFwiQ29udHJvbExlZnRcIiA9IDAsXG4gIFwiQWx0TGVmdFwiID0gMSxcbiAgXCJPU0xlZnRcIiA9IDIsXG4gIFwiU3BhY2VcIiA9IDMsXG4gIFwiT1NSaWdodFwiID0gNCxcbiAgXCJBbHRSaWdodFwiID0gNSxcbiAgXCJDb250cm9sUmlnaHRcIiA9IDYsXG5cbiAgXCJTaGlmdExlZnRcIiA9IDcsXG4gIFwiU2hpZnRSaWdodFwiID0gOCxcbiAgXCJDb21tYVwiID0gOSxcbiAgXCJQZXJpb2RcIiA9IDEwLFxuICBcIlNsYXNoXCIgPSAxMSxcbiBcbiAgXCJDYXBzTG9ja1wiID0gMTIsXG4gIFwiRW50ZXJcIiA9IDEzLFxuICBcIlNlbWljb2xvblwiID0gMTQsXG4gIFwiUXVvdGVcIiA9IDE1LFxuXG4gIFwiVGFiXCIgPSAxNixcbiAgXCJCcmFja2V0TGVmdFwiID0gMTcsXG4gIFwiQnJhY2tldFJpZ2h0XCIgPSAxOCxcbiAgXCJCYWNrc2xhc2hcIiA9IDE5LFxuXG4gIFwiQmFja3F1b3RlXCIgPSAyMCxcbiAgXCJNaW51c1wiID0gMjEsXG4gIFwiRXF1YWxcIiA9IDIyLFxuXG4gIFwiRGlnaXQwXCIgPSAyMyxcbiAgXCJEaWdpdDFcIiA9IDI0LFxuICBcIkRpZ2l0MlwiID0gMjUsXG4gIFwiRGlnaXQzXCIgPSAyNixcbiAgXCJEaWdpdDRcIiA9IDI3LFxuICBcIkRpZ2l0NVwiID0gMjgsXG4gIFwiRGlnaXQ2XCIgPSAyOSxcbiAgXCJEaWdpdDdcIiA9IDMwLFxuICBcIkRpZ2l0OFwiID0gMzEsXG4gIFwiRGlnaXQ5XCIgPSAzMixcblxuICBcIkJhY2tzcGFjZVwiID0gMzMsXG5cbiAgXCJFc2NhcGVcIiA9IDM0LFxuIFxuICBcIkFycm93TGVmdFwiID0gMzUsXG4gIFwiQXJyb3dSaWdodFwiID0gMzYsXG4gIFwiQXJyb3dEb3duXCIgPSAzNyxcbiAgXCJBcnJvd1VwXCIgPSAzOCxcbiAgXCJQYWdlRG93blwiID0gMzksXG4gIFwiUGFnZVVwXCIgPSA0MCxcbiAgXCJFbmRcIiA9IDQxLFxuICBcIkhvbWVcIiA9IDQyLFxuICBcIkRlbGV0ZVwiID0gNDMsXG4gIFwiSW5zZXJ0XCIgPSA0NCxcblxuICBcIk51bXBhZDBcIiA9IDQ1LFxuICBcIk51bXBhZDFcIiA9IDQ2LFxuICBcIk51bXBhZDJcIiA9IDQ3LFxuICBcIk51bXBhZDNcIiA9IDQ4LFxuICBcIk51bXBhZDRcIiA9IDQ5LFxuICBcIk51bXBhZDVcIiA9IDUwLFxuICBcIk51bXBhZDZcIiA9IDUxLFxuICBcIk51bXBhZDdcIiA9IDUyLFxuICBcIk51bXBhZDhcIiA9IDUzLFxuICBcIk51bXBhZDlcIiA9IDU0LFxuIFxuICBcIk51bXBhZERlY2ltYWxcIiA9IDU1LFxuICBcIk51bXBhZEVudGVyXCIgPSA1NixcbiAgXCJOdW1wYWRBZGRcIiA9IDU3LFxuICBcIk51bXBhZFN1YnRyYWN0XCIgPSA1OCxcbiAgXCJOdW1Mb2NrXCIgPSA1OSxcbiAgXCJOdW1wYWRFcXVhbFwiID0gNjAsXG4gIFwiTnVtcGFkTXVsdGlwbHlcIiA9IDYxLFxuICBcIk51bXBhZERpdmlkZVwiID0gNjIsXG4gXG4gIFwiS2V5QVwiID0gNjMsXG4gIFwiS2V5QlwiID0gNjQsXG4gIFwiS2V5Q1wiID0gNjUsXG4gIFwiS2V5RFwiID0gNjYsXG4gIFwiS2V5RVwiID0gNjcsXG4gIFwiS2V5RlwiID0gNjgsXG4gIFwiS2V5R1wiID0gNjksXG4gIFwiS2V5SFwiID0gNzAsXG4gIFwiS2V5SVwiID0gNzEsXG4gIFwiS2V5SlwiID0gNzIsXG4gIFwiS2V5S1wiID0gNzMsXG4gIFwiS2V5TFwiID0gNzQsXG4gIFwiS2V5TVwiID0gNzUsXG4gIFwiS2V5TlwiID0gNzYsXG4gIFwiS2V5T1wiID0gNzcsXG4gIFwiS2V5UFwiID0gNzgsXG4gIFwiS2V5UVwiID0gNzksXG4gIFwiS2V5UlwiID0gODAsXG4gIFwiS2V5U1wiID0gODEsXG4gIFwiS2V5VFwiID0gODIsXG4gIFwiS2V5VVwiID0gODMsXG4gIFwiS2V5VlwiID0gODQsXG4gIFwiS2V5V1wiID0gODUsXG4gIFwiS2V5WFwiID0gODYsXG4gIFwiS2V5WVwiID0gODcsXG4gIFwiS2V5WlwiID0gODgsXG59O1xuY29uc3QgX0tFWUJPQVJEX1NUQVRFX0JVRkZFUl9TSVpFID0gMTI7XG5cbi8qKiBcbiAqIEBjbGFzc1xuICogQGNsYXNzZGVzYyBUaGlzIGNsYXNzIGhhbmRsZXMgcXVldWluZywgbWFuYWdpbmcsIGFuZCB0cmFuc21pdHRpbmcgY29tbWFuZHMgZnJvbSBhIFJBVkkgSmF2YVNjcmlwdCBjbGllbnRcbiAqIHRvIGEgUkFWSSBzZXJ2ZXIuIFxuICogVGhpcyBjbGFzcyBpcyBwcm92aWRlZCBieSBhIHtAbGluayBSYXZpU2Vzc2lvbn0gYW5kIHNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LlxuICpcbiAqIEV4YW1wbGUgdXNhZ2UgKHNlbmRpbmcgaW5mb3JtYXRpb24gb24gbW91c2UgZG91YmxlLWNsaWNrKTpcbiAqIFxuICogYGBgXG4gKiB2YXIgY29tbWFuZENvbnRyb2xsZXIgPSByYXZpU2Vzc2lvbi5nZXRDb21tYW5kQ29udHJvbGxlcigpO1xuICogbGV0IGhhbmRsZU1vdXNlRG91YmxlQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAqICAgdmFyIHBvcyA9IG1vdXNlSGFuZGxlcihldmVudClcbiAqICAgY29tbWFuZENvbnRyb2xsZXIuc2VuZElucHV0KHtcImNcIjogXCJEb3VibGVDbGlja1wiLCBcInBcIjogcG9zIH0pXG4gKiB9O1xuICpgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFJhdmlDb21tYW5kQ29udHJvbGxlciB7XG4gIF9jb21tYW5kUXVldWVNYXA6IE1hcDxzdHJpbmcsIGFueT47XG4gIF9udW1RdWV1ZWRDb21tYW5kczogbnVtYmVyO1xuICBfY29tbWFuZFF1ZXVlSW50ZXJ2YWw6IG51bWJlcjtcbiAgX2NvbW1hbmRQdW1wVGltZXI6IFJldHVyblR5cGU8dHlwZW9mIHNldEludGVydmFsPjtcblxuICBfaW5wdXRUYXJnZXQ6IEhUTUxFbGVtZW50O1xuICBfa2V5Ym9hcmRUYXJnZXQ6IEhUTUxFbGVtZW50O1xuXG4gIF9tb3VzZVN0YXRlQnVmZmVyOiBBcnJheUJ1ZmZlcjtcbiAgX21vdXNlU3RhdGVVaW50ODogVWludDhBcnJheTtcbiAgX21vdXNlU3RhdGVGbG9hdDogRmxvYXQzMkFycmF5O1xuXG4gIF9rZXlib2FyZFN0YXRlQnVmZmVyOiBBcnJheUJ1ZmZlcjtcbiAgX2tleWJvYXJkU3RhdGU6IFVpbnQ4QXJyYXk7XG5cbiAgX2lucHV0RGF0YUNoYW5uZWw6IFJUQ0RhdGFDaGFubmVsO1xuICBfY29tbWFuZERhdGFDaGFubmVsOiBSVENEYXRhQ2hhbm5lbDtcblxuICAvKipcbiAgICogXCJDbGFzc1wiIHZhcmlhYmxlcyB0byBiZSBhd2FyZSBvZjpcbiAgICpcbiAgICogQ29tbWFuZC1jaGFubmVsIHJlbGF0ZWQ6IFxuICAgKiB0aGlzLl9jb21tYW5kRGF0YUNoYW5uZWw7XG4gICAqIHRoaXMuX2NvbW1hbmRRdWV1ZU1hcDtcbiAgICogdGhpcy5fbnVtUXVldWVkQ29tbWFuZHM7XG4gICAqIHRoaXMuX2NvbW1hbmRQdW1wVGltZXI7XG4gICAqIHRoaXMuX2NvbW1hbmRRdWV1ZUludGVydmFsO1xuICAgKlxuICAgKiBJbnB1dC1jaGFubmVsIHJlbGF0ZWQ6XG4gICAqIHRoaXMuX2lucHV0RGF0YUNoYW5uZWw7XG4gICAqIHRoaXMuX2lucHV0VGFyZ2V0O1xuICAgKiB0aGlzLl9rZXlib2FyZFRhcmdldDtcbiAgICovXG4gIFxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFJBVkkgY29tbWFuZCBjb250cm9sbGVyLiBcbiAgICogRGVmYXVsdHMgdGhlIGNvbW1hbmRRdWV1ZUludGVydmFsIHRvIDEgc2Vjb25kXG4gICAqIGFuZCBpbml0aWFsaXplcyB2YXJpYWJsZXMuXG4gICAqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcImNvbnN0cnVjdG9yXCIsIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICAgIFxuICAgIHRoaXMuX2NvbW1hbmRRdWV1ZU1hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9udW1RdWV1ZWRDb21tYW5kcyA9IDA7XG4gICAgdGhpcy5fY29tbWFuZFF1ZXVlSW50ZXJ2YWwgPSAxMDAwO1xuICAgIHRoaXMuX2NvbW1hbmRQdW1wVGltZXIgPSBudWxsO1xuXG4gICAgdGhpcy5faW5wdXRUYXJnZXQ7XG4gICAgdGhpcy5fa2V5Ym9hcmRUYXJnZXQ7XG5cbiAgICAvLyBNb3VzZSBzdGF0ZSBidWZmZXIgY29udGFpbnMgdGhlICdNJyBjaGFyIHRvIGluZGljYXRlIHRoZSBwYXlsb2FkIG9uIHRoZSBpbnB1dCBkYXRhIGNoYW5uZWxcbiAgICB0aGlzLl9tb3VzZVN0YXRlQnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKF9NT1VTRV9TVEFURV9CVUZGRVJfU0laRSArIDQpO1xuICAgIC8vIHNldCAnTScgYXMgdGhlIGZpcnN0IGNoYXIgb2YgdGhlIE1vdXNlZFN0YXRlIGJ1ZmZlclxuICAgIHRoaXMuX21vdXNlU3RhdGVVaW50OCA9IG5ldyBVaW50OEFycmF5KHRoaXMuX21vdXNlU3RhdGVCdWZmZXIpO1xuICAgIHRoaXMuX21vdXNlU3RhdGVVaW50OFswXSA9IDB4NERcbiAgICAvLyBBbGxvY2F0ZSB0aGUgdmlldyBvbiB0aGUgbW91c2UgYnVmZmVyIGFzIGZsb2F0cyBzdGFydGluZyBvbiB0aGUgMm5kIGJ5dGVcbiAgICB0aGlzLl9tb3VzZVN0YXRlRmxvYXQgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuX21vdXNlU3RhdGVCdWZmZXIsIDQgKTtcbiAgICB0aGlzLl9tb3VzZVN0YXRlRmxvYXRbMF0gPSAtMS4wO1xuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdFsxXSA9IC0xLjA7XG4gICAgdGhpcy5fbW91c2VTdGF0ZUZsb2F0WzJdID0gLTEuMDtcbiAgICB0aGlzLl9tb3VzZVN0YXRlRmxvYXRbM10gPSAtMS4wO1xuICAgIFxuICAgIC8vIEtleWJvYXJkIHN0YXRlIGJ1ZmZlciBjb250YWlucyB0aGUgJ2snIGNoYXIgdG8gaW5kaWNhdGUgdGhlIHBheWxvYWRcbiAgICB0aGlzLl9rZXlib2FyZFN0YXRlQnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKF9LRVlCT0FSRF9TVEFURV9CVUZGRVJfU0laRSArIDEpO1xuICAgIHRoaXMuX2tleWJvYXJkU3RhdGUgPSBuZXcgVWludDhBcnJheSh0aGlzLl9rZXlib2FyZFN0YXRlQnVmZmVyKTtcbiAgICB0aGlzLl9rZXlib2FyZFN0YXRlWzBdID0gMHg0QjsgLy8gc2V0ICdLJyBhcyB0aGUgZmlyc3QgY2hhciBvZiB0aGUgS2V5Ym9hcmRTdGF0ZSBidWZmZXJcbiAgfVxuICBcbiAgLyoqXG4gICAqIFNldCB0aGUgaW50ZXJ2YWwgYXQgd2hpY2ggd2Ugc2hvdWxkIHNlbmQgY29tbWFuZHNcbiAgICogdG8gdGhlIHNlcnZlci5cbiAgICpcbiAgICogQHBhcmFtIHtpbnR9IHF1ZXVlSW50ZXJ2YWwgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZXR3ZWVuXG4gICAqIHNlbmRpbmcgY29tbWFuZHMuIERlZmF1bHRzIHRvIDEwMDAgKDEgc2Vjb25kKS5cbiAgICovXG4gIHNldENvbW1hbmRRdWV1ZUludGVydmFsKHF1ZXVlSW50ZXJ2YWw6IG51bWJlcikge1xuICAgIHRoaXMuX2NvbW1hbmRRdWV1ZUludGVydmFsID0gcXVldWVJbnRlcnZhbDtcbiAgICAvLyBJZiB0aGUgY29tbWFuZCBxdWV1ZSBpcyBydW5uaW5nLCBzdG9wIGl0IGFuZFxuICAgIC8vIHJlc3RhcnQgaXQuXG4gICAgaWYgKHRoaXMuX2NvbW1hbmRQdW1wVGltZXIpIHtcbiAgICAgIHRoaXMuc3RvcE1vbml0b3JpbmdRdWV1ZXMoKTtcbiAgICAgIHRoaXMubW9uaXRvclF1ZXVlcygpO1xuICAgIH1cbiAgfVxuICBcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZm9yIGxpc3RlbmluZyBmb3IgcmVzcG9uc2VzIHRvIHF1ZXVlZCBjb21tYW5kc1xuICAgKiBAY2FsbGJhY2sgUmF2aUNvbW1hbmRDb250cm9sbGVyfmNvbW1hbmRDYWxsYmFja1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVzcG9uc2UgVGhlIHJlc3BvbnNlIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlclxuICAgKi9cbiAgLyoqXG4gICAqIFF1ZXVlIHVwIGEgY29tbWFuZCB0byBiZSBzZW50IHdoZW4gcmVhZHksIGFsb25nXG4gICAqIHRoZSBcImNvbW1hbmRcIiBkYXRhIGNoYW5uZWwuXG4gICAqIFNlZSBhbHNvIHtsaW5rIFJhdmlDb21tYW5kQ29udHJvbGxlciNzZW5kSW5wdXR9XG4gICAqIHRvIHNlbmQgaW1tZWRpYXRlIGlucHV0IHRvIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCBoZXJlIGlzIGEgcmVxdWVzdCBmb3IgYSBuZXcgdmlkZW8ga2V5ZnJhbWU6XG4gICAqIGBgYFxuICAgKiBjb21tYW5kQ29udHJvbGxlci5xdWV1ZUNvbW1hbmQoXCJ2aWRlby5mb3JjZUtleUZyYW1lXCIsIHt9LCBoYW5kbGVyKVxuICAgKlxuICAgKiBgYGBcbiAgICogTk9URTogVGhlc2UgY29tbWFuZHMgc2VudCB0byB0aGUgUkFWSSBzZXJ2ZXIgd2lsbCBiZSBzZW50IGFzIEpTT04sXG4gICAqIGFuZCBoYW5kbGVycyBhc3NvY2lhdGVkIHdpdGggdGhlc2UgY29tbWFuZHMgYXJlIGV4cGVjdGVkIHRvXG4gICAqIHJlY2VpdmUgSlNPTiBhcyBhIHJlc3BvbnNlLiBJZiB5b3UgbmVlZCB0byBwcm9jZXNzIGJpbmFyeSBkYXRhXG4gICAqIHJlY2VpdmVkIGluIHJlc3BvbnNlIHRvIGEgY29tbWFuZCwgeW91IHNob3VsZCBzZW5kIHRoZSBjb21tYW5kIFxuICAgKiB3aXRob3V0IGEgaGFuZGxlciwgYW5kIHRoZW4gQUxTTyBzcGVjaWZ5IGEgZ2xvYmFsIGJpbmFyeSBsaXN0ZW5lclxuICAgKiB3aXRoIHtsaW5rIFJhdmlDb21tYW5kQ29udHJvbGxlciNhZGRCaW5hcnlIYW5kbGVyfVxuICAgKiB0byBpZGVudGlmeSBhbmQgYXBwcm9wcmlhdGVseSBwcm9jZXNzIHRoZSByZXNwb25zZS4gQmluYXJ5XG4gICAqIGRhdGEgaXMgbm90IGFzc29jaWF0ZWQgd2l0aCBhIGNvbW1hbmQsIGFuZCBzbyBhbGwgYmluYXJ5IGhhbmRsZXJzXG4gICAqIGFyZSBleGVjdXRlZCBmb3IgYWxsIGJpbmFyeSBkYXRhIHJlY2VpdmVkOyBiaW5hcnkgaGFuZGxlcnMgc2hvdWxkXG4gICAqIHRoZW1zZWx2ZXMgZGV0ZXJtaW5lIGlmIHRoZSBkYXRhIHRoZXkndmUgYmVlbiBnaXZlbiBpcyB0aGUgZGF0YVxuICAgKiB0aGV5J3JlIGV4cGVjdGluZy4gKEFuZCBpZiB5b3Ugd2FudCB0byBzZW5kIHRoZSBjb21tYW5kIGFzIGJpbmFyeVxuICAgKiBmcm9tIHRoZSBKUyBzaWRlLCB1c2Uge2xpbmsgUmF2aUNvbW1hbmRDb250cm9sbGVyI3F1ZXVlQmluYXJ5Q29tbWFuZH0pXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb21tYW5kIFRoZSBjb21tYW5kIHRvIGFkZCB0byB0aGUgcXVldWVcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtICAgUGFyYW1ldGVycyB0byBpbmNsdWRlIGFsb25nIHdpdGggdGhlIGNvbW1hbmRcbiAgICogQHBhcmFtIHtSYXZpQ29tbWFuZENvbnRyb2xsZXJ+Y29tbWFuZENhbGxiYWNrfSBoYW5kbGVyIEEgY2FsbGJhY2sgaGFuZGxlciB0aGF0IHNob3VsZCBoYW5kbGUgYW55IHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlclxuICAgKi9cbiAgcXVldWVDb21tYW5kKGNvbW1hbmQ6IHN0cmluZywgcGFyYW06IGFueSwgaGFuZGxlcjogRnVuY3Rpb24pIHtcbiAgICAvLyBBZGQgdGhlIGNvbW1hbmQgdG8gdGhlIHF1ZXVlIGZvciB0aGlzIHBhcnRpY3VsYXJcbiAgICAvLyB0eXBlIG9mIGNvbW1hbmRcbiAgICB2YXIgY29tbWFuZFF1ZXVlID0gdGhpcy5fY29tbWFuZFF1ZXVlTWFwLmdldChjb21tYW5kKTtcbiAgICBpZiAoIWNvbW1hbmRRdWV1ZSkge1xuICAgICAgY29tbWFuZFF1ZXVlID0geyB0b1NlbmQ6IFtdLCBsaXN0ZW5lcjogW10gfTtcbiAgICAgIHRoaXMuX2NvbW1hbmRRdWV1ZU1hcC5zZXQoY29tbWFuZCwgY29tbWFuZFF1ZXVlKTtcbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlckluc3RhbmNlID0gbnVsbDtcbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgLy8gRm9yIG5vdywgYWxsIGhhbmRsZXJzIGFzc29jaWF0ZWQgd2l0aCBhY3R1YWwgc2VudCBjb21tYW5kc1xuICAgICAgLy8gYXJlIG5vdCBcInN0aWNreVwiIChpLmUuIHRoZXkgb25seSBleGVjdXRlIG9uY2UsIHdoZW4gdGhlIGNvbW1hbmQgcmV0dXJucylcbiAgICAgIC8vIGFuZCB0aGV5IERPIGhhdmUgYSBcIm1hdGNoaW5nIHNlbnQgY29tbWFuZFwiXG4gICAgICBoYW5kbGVySW5zdGFuY2UgPSBuZXcgUmF2aUNvbW1hbmRIYW5kbGVySW5zdGFuY2UoaGFuZGxlciwgZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgICBjb21tYW5kUXVldWUudG9TZW5kLnB1c2goIG5ldyBSYXZpQ29tbWFuZEluc3RhbmNlKGNvbW1hbmQsIHBhcmFtLCBoYW5kbGVySW5zdGFuY2UpICk7XG5cbiAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBudW1iZXIgb2Ygd2FpdGluZyBjb21tYW5kcyBzZXBhcmF0ZWx5IHNvIHdlIGRvbid0IGhhdmVcbiAgICAvLyB0byBrZWVwIGNhbGN1bGF0aW5nIGl0IHdoZW4gd2UgY2hlY2sgZm9yIHF1ZXVlZCBjb21tYW5kc1xuICAgIHRoaXMuX251bVF1ZXVlZENvbW1hbmRzKys7XG4gICAgXG4gICAgUmF2aVV0aWxzLmxvZyhcIkFkZGVkIGNvbW1hbmQgXCIgKyBjb21tYW5kLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWV1ZSB1cCBhIGJpbmFyeSBtZXNzYWdlIHRvIGJlIHNlbnQgd2hlbiByZWFkeSwgYWxvbmdcbiAgICogdGhlIFwiY29tbWFuZFwiIGRhdGEgY2hhbm5lbC5cbiAgICogU2VlIGFsc28ge2xpbmsgUmF2aUNvbW1hbmRDb250cm9sbGVyI3NlbmRJbnB1dH1cbiAgICogdG8gc2VuZCBpbW1lZGlhdGUgaW5wdXQgdG8gdGhlIHNlcnZlci5cbiAgICpcbiAgICogTk9URTogWW91IGNhbiBub3QgaW5jbHVkZSBhIGhhbmRsZXIgaW4gdGhpcyBtZXRob2QsIGJlY2F1c2VcbiAgICogYmluYXJ5IG1lc3NhZ2VzIGFyZSBub3QgY3VycmVudGx5IGRpc3Rpbmd1aXNoYWJsZSBmcm9tIGVhY2hcbiAgICogb3RoZXIgYXMgcmVnYXJkcyBoYW5kbGVycyAoaS5lLiB0aGVyZSBpcyBubyBcImNvbW1hbmRcIiBhc3NvY2lhdGVkXG4gICAqIHdpdGggYSBiaW5hcnkgbWVzc2FnZSkuIElmIHlvdSB3YW50IHRvIGFzc2lnbiBhIGhhbmRsZXIgdGhhdFxuICAgKiB3aWxsIHByb2Nlc3MgYmluYXJ5IG1lc3NhZ2VzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciwgdXNlXG4gICAqIHtsaW5rIFJhdmlDb21tYW5kQ29udHJvbGxlciNhZGRCaW5hcnlIYW5kbGVyfVxuICAgKiB0byBpZGVudGlmeSBhbmQgYXBwcm9wcmlhdGVseSBwcm9jZXNzIHRoZSByZXNwb25zZS4gQmluYXJ5XG4gICAqIGRhdGEgaXMgbm90IGFzc29jaWF0ZWQgd2l0aCBhbiBpbmRpdmlkdWFsIGNvbW1hbmQsIGFuZCBzbyBhbGwgYmluYXJ5IGhhbmRsZXJzXG4gICAqIGFyZSBleGVjdXRlZCBmb3IgYWxsIGJpbmFyeSBkYXRhIHJlY2VpdmVkOyBiaW5hcnkgaGFuZGxlcnMgc2hvdWxkXG4gICAqIHRoZW1zZWx2ZXMgZGV0ZXJtaW5lIGlmIHRoZSBkYXRhIHRoZXkndmUgYmVlbiBnaXZlbiBpcyB0aGUgZGF0YVxuICAgKiB0aGV5J3JlIGV4cGVjdGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gbWVzc2FnZSBBbiBBcnJheUJ1ZmZlciAoZXhwZWN0ZWQgYnkgdGhlIHNlcnZlciB0byBiZSBhIFVpbnQ4QXJyYXkpIHRoYXQgc2hvdWxkIGJlIHNlbnQgdG8gdGhlIHNlcnZlclxuICAgKi9cbiAgcXVldWVCaW5hcnlDb21tYW5kKG1lc3NhZ2U6IEFycmF5QnVmZmVyKSB7XG4gICAgLy8gQWRkIHRoZSBjb21tYW5kIHRvIHRoZSBiaW5hcnkgcXVldWUgXG4gICAgbGV0IGNvbW1hbmQgPSBfQklOQVJZX0NPTU1BTkRfS0VZO1xuICAgIHZhciBjb21tYW5kUXVldWUgPSB0aGlzLl9jb21tYW5kUXVldWVNYXAuZ2V0KGNvbW1hbmQpO1xuICAgIGlmICghIGNvbW1hbmRRdWV1ZSkge1xuICAgICAgY29tbWFuZFF1ZXVlID0geyB0b1NlbmQ6IFtdLCBsaXN0ZW5lcjogW10gfTtcbiAgICAgIHRoaXMuX2NvbW1hbmRRdWV1ZU1hcC5zZXQoY29tbWFuZCwgY29tbWFuZFF1ZXVlKTtcbiAgICB9XG5cbiAgICBjb21tYW5kUXVldWUudG9TZW5kLnB1c2goIG5ldyBSYXZpQ29tbWFuZEluc3RhbmNlKG1lc3NhZ2UsIG51bGwsIG51bGwpICk7XG5cbiAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBudW1iZXIgb2Ygd2FpdGluZyBjb21tYW5kcyBzZXBhcmF0ZWx5IHNvIHdlIGRvbid0IGhhdmVcbiAgICAvLyB0byBrZWVwIGNhbGN1bGF0aW5nIGl0IHdoZW4gd2UgY2hlY2sgZm9yIHF1ZXVlZCBjb21tYW5kc1xuICAgIHRoaXMuX251bVF1ZXVlZENvbW1hbmRzKys7XG4gICAgXG4gICAgUmF2aVV0aWxzLmxvZyhcIkFkZGVkIGJpbmFyeSBjb21tYW5kXCIsIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICB9XG5cbiAgXG4gIC8qKlxuICAgKiBBZGQgYSBjb21tYW5kIGhhbmRsZXIgb25seSwgd2l0aG91dCBhbHNvIHF1ZXVpbmcgdXAgYSBjb21tYW5kIHRvIHNlbmQuXG4gICAqIFRoaXMgbGlzdGVuZXIgd2lsbCB3YXRjaCBmb3IgYSBtZXNzYWdlIHRvIGJlIHJlY2VpdmVkIGZyb20gdGhlXG4gICAqIHNlcnZlciAob24gdGhlIFwiY29tbWFuZFwiIGRhdGEgY2hhbm5lbCkgdGhhdCBtYXRjaGVzIHRoZSBleHBlY3RlZFxuICAgKiBtZXNzYWdlIG5hbWUuIFdoZW4gcmVjZWl2ZWQsIHRoZSBsaXN0ZW5lciB3aWxsIGV4ZWN1dGUsIGFuZCB0aGVuIGVpdGhlciBzdGljayBhcm91bmQgYW5kXG4gICAqIGtlZXAgd2F0Y2hpbmcgKGlmIHRoZSBcImlzU3RpY2t5XCIgZmxhZyBpcyBzZXQgdG8gdHJ1ZSlcbiAgICogb3IgZGUtcmVnaXN0ZXIgaXRzZWxmIChpZiBcImlzU3RpY2t5XCIgaXMgZmFsc2UpIGFuZCBzdG9wIGxpc3RlbmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV4cGVjdGVkTWVzc2FnZSBUaGUgc3RyaW5nIHRvIHdhdGNoIGZvciBmcm9tIHRoZSBzZXJ2ZXIsIHNvbWV0aGluZyBsaWtlIFwibWVzc2FnZS5sb2NhdGlvblwiXG4gICAqIEBwYXJhbSB7UmF2aUNvbW1hbmRDb250cm9sbGVyfmNvbW1hbmRDYWxsYmFja30gaGFuZGxlciBBIGhhbmRsZXIgdGhhdCBzaG91bGQgcHJvY2VzcyBhbnkgZXZlbnRzIGxhYmVsZWQgd2l0aCBleHBlY3RlZE1lc3NhZ2VcbiAgICogQHBhcmFtIHtib29sZWFufSBpc1N0aWNreSBXaGV0aGVyIHRoZSBoYW5kbGVyIHNob3VsZCBleGVjdXRlIGV2ZXJ5IHRpbWUgdGhlIG1lc3NhZ2UgaXMgcmVjZWl2ZWQgKHRydWUpXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3IganVzdCB0aGUgZmlyc3QgdGltZSAoZmFsc2UpXG4gICAqL1xuICBhZGRNZXNzYWdlSGFuZGxlcihleHBlY3RlZE1lc3NhZ2U6IHN0cmluZywgaGFuZGxlcjogRnVuY3Rpb24sIGlzU3RpY2t5OiBib29sZWFuKSB7XG5cbiAgICAvLyBUaGUgY29tbWFuZCBxdWV1ZSBtYXAgaXMgdXNlZCB0byB0cmFjayBhbGwgY29tbWFuZHMvbGlzdGVuZXJzO1xuICAgIC8vIGVuc3VyZSB0aGF0IHRoaXMgcGFydGljdWxhciBcImV4cGVjdGVkTWVzc2FnZVwiIGhhcyBhbiBlbnRyeVxuICAgIHZhciBtZXNzYWdlRW50cnkgPSB0aGlzLl9jb21tYW5kUXVldWVNYXAuZ2V0KGV4cGVjdGVkTWVzc2FnZSk7XG4gICAgaWYgKCEgbWVzc2FnZUVudHJ5KSB7XG4gICAgICBtZXNzYWdlRW50cnkgPSB7IHRvU2VuZDogW10sIGxpc3RlbmVyOiBbXSB9O1xuICAgICAgdGhpcy5fY29tbWFuZFF1ZXVlTWFwLnNldChleHBlY3RlZE1lc3NhZ2UsIG1lc3NhZ2VFbnRyeSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFdlIGRvbid0IGFjdHVhbGx5IHdhbnQgdG8gcHV0IGFueXRoaW5nIGluIGl0cyBcInRvU2VuZFwiIGFycmF5LCBidXRcbiAgICAvLyB3ZSBkbyB3YW50IHRvIGFkZCBhIGxpc3RlbmVyLlxuICAgIHZhciBoYW5kbGVySW5zdGFuY2UgPSBuZXcgUmF2aUNvbW1hbmRIYW5kbGVySW5zdGFuY2UoaGFuZGxlciwgaXNTdGlja3ksIGZhbHNlKTtcbiAgICBtZXNzYWdlRW50cnkubGlzdGVuZXIucHVzaChoYW5kbGVySW5zdGFuY2UpOyBcblxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZvciBsaXN0ZW5pbmcgZm9yIGJpbmFyeSBzZXJ2ZXIgbWVzc2FnZXNcbiAgICogQGNhbGxiYWNrIFJhdmlDb21tYW5kQ29udHJvbGxlcn5iaW5hcnlDYWxsYmFja1xuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHJlc3BvbnNlIFRoZSByZXNwb25zZSByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIgYXMgYSBVaW50OEFycmF5IHR5cGVkIGFycmF5XG4gICAqL1xuICAvKipcbiAgICogQWRkIGEgaGFuZGxlciBmb3IgYmluYXJ5IGRhdGEgb25seSwgd2l0aG91dCBhbHNvIHF1ZXVpbmcgdXAgYSBjb21tYW5kIHRvIHNlbmQuXG4gICAqIFRoaXMgbGlzdGVuZXIgd2lsbCB3YXRjaCBmb3IgYSBiaW5hcnkgbWVzc2FnZSB0byBiZSByZWNlaXZlZCBmcm9tIHRoZVxuICAgKiBzZXJ2ZXIgKG9uIHRoZSBcImNvbW1hbmRcIiBkYXRhIGNoYW5uZWwpLlxuICAgKiBXaGVuIHJlY2VpdmVkLCB0aGUgbGlzdGVuZXIgd2lsbCBleGVjdXRlLCBhbmQgdGhlbiBlaXRoZXIgc3RpY2sgYXJvdW5kIGFuZFxuICAgKiBrZWVwIHdhdGNoaW5nIChpZiB0aGUgXCJpc1N0aWNreVwiIGZsYWcgaXMgc2V0IHRvIHRydWUpXG4gICAqIG9yIGRlLXJlZ2lzdGVyIGl0c2VsZiAoaWYgXCJpc1N0aWNreVwiIGlzIGZhbHNlKSBhbmQgc3RvcCBsaXN0ZW5pbmcuXG4gICAqXG4gICAqIE5PVEU6IEJpbmFyeSBkYXRhIGlzIG5vdCBhc3NvY2lhdGVkIHdpdGggYSBjb21tYW5kLCBhbmQgc28gYWxsIGJpbmFyeSBoYW5kbGVyc1xuICAgKiBhcmUgZXhlY3V0ZWQgZm9yIGFsbCBiaW5hcnkgZGF0YSByZWNlaXZlZDsgYmluYXJ5IGhhbmRsZXJzIHNob3VsZFxuICAgKiB0aGVtc2VsdmVzIGRldGVybWluZSBpZiB0aGUgZGF0YSB0aGV5J3ZlIGJlZW4gZ2l2ZW4gaXMgdGhlIGRhdGFcbiAgICogdGhleSdyZSBleHBlY3RpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7UmF2aUNvbW1hbmRDb250cm9sbGVyfmJpbmFyeUNhbGxiYWNrfSBoYW5kbGVyIEEgaGFuZGxlciB0aGF0IHNob3VsZCBwcm9jZXNzIGFueSBldmVudHMgbGFiZWxlZCB3aXRoIGV4cGVjdGVkTWVzc2FnZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3RpY2t5IFdoZXRoZXIgdGhlIGhhbmRsZXIgc2hvdWxkIGV4ZWN1dGUgZXZlcnkgdGltZSB0aGUgbWVzc2FnZSBpcyByZWNlaXZlZCAodHJ1ZSlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBqdXN0IHRoZSBmaXJzdCB0aW1lIChmYWxzZSlcbiAgICovXG4gIGFkZEJpbmFyeUhhbmRsZXIoaGFuZGxlcjogRnVuY3Rpb24sIGlzU3RpY2t5OiBib29sZWFuKSB7XG4gICAgLy8gU3RvcmUgdGhlc2UgaGFuZGxlcnMgaW4gdGhlIHNhbWUgbWFwIGFzIHRoZSBvdGhlciBsaXN0ZW5lci1vbmx5IGhhbmRsZXJzLFxuICAgIC8vIGJ1dCBqdXN0IHVzZSBhIHNpbmdsZSBjb25zdGFudCBrZXkuXG4gICAgdGhpcy5hZGRNZXNzYWdlSGFuZGxlcihfQklOQVJZX0NPTU1BTkRfS0VZLCBoYW5kbGVyLCBpc1N0aWNreSk7XG4gICAgLy8gTk9URTogQ3VycmVudGx5LCB3ZSBkb24ndCBzdXBwb3J0IGFueSBzb3J0IG9mIFwiY29tbWFuZFwiIGFzc29jaWF0ZWRcbiAgICAvLyB3aXRoIGJpbmFyeSBtZXNzYWdlcyAtLSB3aGVuIHdlIGdldCBhIGJpbmFyeSBtZXNzYWdlLCBhbGwgYmluYXJ5XG4gICAgLy8gaGFuZGxlcnMgYXJlIGNhbGxlZC4gV2UgbWF5IGRlY2lkZSB0byByZXRoaW5rIHRoaXMgaW4gdGhlIGZ1dHVyZS5cbiAgfVxuICBcbiAgLyoqXG4gICAqIFNlbmQgYW4gaW5wdXQgZXZlbnQgZGlyZWN0bHkgZnJvbSB0aGUgdXNlciB0byB0aGUgUkFWSSBzZXJ2ZXIgYWxvbmdcbiAgICogdGhlIFwiaW5wdXRcIiBkYXRhIGNoYW5uZWwuXG4gICAqIFNlZSBhbHNvIHtsaW5rIFJhdmlDb21tYW5kQ29udHJvbGxlciNxdWV1ZUNvbW1hbmR9LCB3aGljaCBxdWV1ZXMgY29tbWFuZHMgZm9yIGxhdGVyIHNlbmRpbmcuXG4gICAqIFRoaXMgbWV0aG9kIGRvZXMgbm90IGRlZmluZSBjYWxsYmFja3MuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCBoZXJlIGlzIGFuIGV2ZW50IGhhbmRsZXIgZm9yIHNlbmRpbmcgbW91c2UgbW92ZW1lbnQ6XG4gICAqIGBgYFxuICAgKiBsZXQgaGFuZGxlTW91c2VNb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAqICAgdmFyIHBvcyA9IG1vdXNlSGFuZGxlcihldmVudClcbiAgICogICBjb21tYW5kQ29udHJvbGxlci5zZW5kSW5wdXQoe1wiY1wiOiBcIk1vdXNlTW92ZVwiLCBcInBcIjogcG9zIH0pXG4gICAqIH07XG4gICAqIGBgYFxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRFdmVudCBBbiBldmVudCB0byBzZW5kLlxuICAgKi9cbiAgc2VuZElucHV0KGlucHV0RXZlbnQ6IGFueSkge1xuICAgIGlmICh0aGlzLl9pbnB1dERhdGFDaGFubmVsICYmIHRoaXMuX2lucHV0RGF0YUNoYW5uZWwucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICAvLyBUaGlzIGdldHMganVzdCBXQVkgdG9vIG5vaXN5IHRvbyBxdWlja2x5LFxuICAgICAgLy8gYnV0IHVuY29tbWVudCBpZiBuZWVkZWQ6XG4gICAgICAvLyBSYXZpVXRpbHMubG9nKFwiU2VuZGluZyBpbnB1dDpcIiArIEpTT04uc3RyaW5naWZ5KGlucHV0RXZlbnQpLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcbiAgICAgIHRoaXMuX2lucHV0RGF0YUNoYW5uZWwuc2VuZChpbnB1dEV2ZW50KTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBLaWNrIG9mZiBwb2xsaW5nIGZvciBxdWV1ZWQgY29tbWFuZHMuXG4gICAqIEV2ZXJ5IHNlY29uZCwgdGhpcyB3aWxsIHNlbmQgdGhlXG4gICAqIG5leHQgcXVldWVkIGNvbW1hbmQgZnJvbSB0aGUgY29tbWFuZFF1ZXVlLlxuICAgKiBUaGlzIGRvZXMgbm90IG5lZWQgdG8gYmUgY2FsbGVkIGV4dGVybmFsbHk7XG4gICAqIGl0IHdpbGwgYmUgY2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgYXBwcm9wcmlhdGVcbiAgICogY29tbWFuZCBkYXRhIGNoYW5uZWwgaXMgb3BlbmVkLiAoU2VlIHtAbGluayBSYXZpQ29tbWFuZENvbnRyb2xsZXIjX3NldENvbW1hbmREYXRhQ2hhbm5lbH0pXG4gICAqIEhvd2V2ZXIsIGl0IGNhbiBiZSBjYWxsZWQgZXh0ZXJuYWxseSBpZiBhdCBhbnkgcG9pbnRcbiAgICogeW91IG5lZWQgdG8gc3RvcCBhbmQgdGhlbiByZXN0YXJ0IHRoZSBxdWV1ZSBtb25pdG9yaW5nXG4gICAqIHByb2Nlc3MuXG4gICAqL1xuICBtb25pdG9yUXVldWVzKCkge1xuICAgIFJhdmlVdGlscy5sb2coXCJCZWdpbiBtb25pdG9yaW5nIGZvciBxdWV1ZWQgY29tbWFuZHNcIiwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG4gICAgdGhpcy5fY29tbWFuZFB1bXBUaW1lciA9IHNldEludGVydmFsKHRoaXMuX3Byb2Nlc3NTZW5kaW5nUXVldWVkQ29tbWFuZHMuYmluZCh0aGlzKSwgdGhpcy5fY29tbWFuZFF1ZXVlSW50ZXJ2YWwpOyAgXG4gIH1cbiAgXG4gIC8qKlxuICAgKiBTdG9wIHBvbGxpbmcgZm9yIHF1ZXVlZCBjb21tYW5kcyBhbmRcbiAgICogbm8gbG9uZ2VyIHNlbmQgdGhlbS4gQ2FsbGVkIHdoZW4gYSBSQVZJIHNlc3Npb24gaXMgY2xvc2VkXG4gICAqIChzZWUge0BsaW5rIFJhdmlTZXNzaW9uI2Nsb3NlfSkuIENhbiBhbHNvIGJlIGNhbGxlZFxuICAgKiBleHRlcm5hbGx5IHRvIGhhbHQgY29tbWFuZCBwcm9jZXNzaW5nIGlmIG5lZWRlZC5cbiAgICovXG4gIHN0b3BNb25pdG9yaW5nUXVldWVzKCkge1xuICAgIFJhdmlVdGlscy5sb2coXCJTdG9wIG1vbml0b3JpbmcgZm9yIHF1ZXVlZCBjb21tYW5kc1wiLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcbiAgICBjbGVhckludGVydmFsKHRoaXMuX2NvbW1hbmRQdW1wVGltZXIpO1xuICAgIHRoaXMuX2NvbW1hbmRQdW1wVGltZXIgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgdGhlIG5leHQgcXVldWVkIGNvbW1hbmQuXG4gICAqIHRoaXMgZ2V0cyB1c2VkIGludGVybmFsbHkgYnkgdGhlIHF1ZXVlIG1vbml0b3JcbiAgICogYW5kLCBpbiBnZW5lcmFsLCBzaG91bGQgbm90IGJlIGNhbGxlZCBleHRlcm5hbGx5LlxuICAgKiBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcm9jZXNzU2VuZGluZ1F1ZXVlZENvbW1hbmRzKCkge1xuICAgIGlmICh0aGlzLl9udW1RdWV1ZWRDb21tYW5kcyA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIEZvciBlYWNoIHR5cGUgb2YgY29tbWFuZCBpbiB0aGUgbWFwLCB3ZSBjYW4gc2VuZCB0aGUgZmlyc3Qgb25lIG9mIHRoZW0uXG4gICAgdGhpcy5fY29tbWFuZFF1ZXVlTWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWU6IGFueSwga2V5OiBhbnksIG1hcDogYW55KSB7XG4gICAgICAvLyBpZiB0aGlzIHBhcnRpY3VsYXIgY29tbWFuZCBoYXMgYSBxdWV1ZSBvZiBpbnN0YW5jZXMuLi5cbiAgICAgIGlmICh2YWx1ZS50b1NlbmQubGVuZ3RoKSB7XG4gICAgICAgIC8vIEdyYWIgdGhlIGZpcnN0IG9uZSBvZmYgdGhlIHF1ZXVlXG4gICAgICAgIHZhciBjb21tYW5kSW5zdGFuY2UgPSB2YWx1ZS50b1NlbmQuc2hpZnQoKTtcblxuICAgICAgICAvLyBJZiBhIGhhbmRsZXIgaXMgZGVmaW5lZCB0aGVuIHB1dCBpdCBvbiB0aGUgbGlzdGVuZXIgbWFwXG4gICAgICAgIGlmIChjb21tYW5kSW5zdGFuY2UuX2hhbmRsZXIpIHtcbiAgICAgICAgICAvLyBBZGQgaXQgdG8gdGhlIGxpc3Qgb2YgbGlzdGVuZXJzIGZvciBsYXRlciBoYW5kbGVyIGhhbmRsaW5nXG4gICAgICAgICAgdmFsdWUubGlzdGVuZXIucHVzaChjb21tYW5kSW5zdGFuY2UuX2hhbmRsZXIpOyAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExldCdzIHNlbmQgdGhlIGNvbW1hbmQhXG4gICAgICAgIGlmICggdGhpcy5fc2VuZENvbW1hbmRJbnN0YW5jZShjb21tYW5kSW5zdGFuY2UpICkge1xuICAgICAgICAgIHRoaXMuX251bVF1ZXVlZENvbW1hbmRzLS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUmF2aVV0aWxzLmxvZyhcIlNlbmQgZmFpbGVkLiBDb21tYW5kRGF0YUNoYW5uZWwgbWF5IGhhdmUgYmVlbiBkaXNjb25uZWN0ZWQuIFdpbGwgbm90IHJldHJ5LlwiLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcbiAgICAgICAgICAvLyBJZiB3ZSBkaWQgd2FudCB0byByZXRyeSwgdGhvdWdoOlxuICAgICAgICAgIC8vdmFsdWUudG9TZW5kLnB1c2goY29tbWFuZEluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplIGEgcGFpciB7IGNvbW1hbmQsIHBheWxvYWQgfSB0byBiZSBzZW50IGhhcyBhIG1lc3NhZ2Ugb24gdGhlIENvbW1hbmREYXRhQ2hhbm5lbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29tbWFuZCAtIFRoZSBhY3R1YWwgc3RyaW5nIGNvbW1hbmRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBheWxvYWQgLSBBbnkgcGFyYW1ldGVycyB0byBiZSBzZW50IG9yIHJlY2VpdmVkIHRoZSBjb21tYW5kXG4gICAqIFxuICAgKiBAcmV0dXJuIHRoZSBtZXNzYWdlIGFzIGEge3N0cmluZ30gYXMgZXhwZWN0ZWQgYnkgdGhlIHNlcnZlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlcmlhbGl6ZUpzb25Db21tYW5kTWVzc2FnZVRvU2VuZChjb21tYW5kOiBzdHJpbmcsIHBheWxvYWQ6IHN0cmluZykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XCJjXCI6IGNvbW1hbmQsIFwicFwiOiBwYXlsb2FkfSk7XG4gIH1cblxuICAvKipcbiAgICogVW5zZXJpYWxpemUgYSByZWNlaXZlZCBjb21tYW5kIG1lc3NhZ2UgXG4gICAqIElmIHRoZSBtZXNzYWdlIGlzIHBhcnNlZCBjb3JyZWN0bHkgdGhlbiB0aGUgZnVuY3Rpb24gcmV0dXJucyBhIHZhbGlkIFwiQ29tbWFuZE1lc3NhZ2VcIiBvYmplY3RcbiAgICogY29udGFpbmluZyB0aGUgZm9sbG93aW5nIGtleXNcbiAgICogLSB7c3RyaW5nfSAnY29tbWFuZCcgLSBUaGUgY29tbWFuZCB0b2tlbiBpZGVudGlmeWluZyB0aGUgZGVzdGluYXRpb24gb2YgdGhlIG1lc3NhZ2VcbiAgICogLSB7c3RyaW5nfSAncGF5bG9hZCcgLSBUaGUgYWN0dWFsIGRhdGEgcmVjZWl2ZWQgZnJvbSB0aGUgbWVzc2FnZVxuICAgKiBcbiAgICogSWYgdGhlIHBhcnNpbmcgZG9lc24ndCBtYXRjaCBhIHZhbGlkIGNvbW1hbmRNZXNzYWdlIHRoZW4gdGhlIGZ1bmN0aW9uIHJldHVybnMgbnVsbCBhbmQgbG9nIHRoZSBwcm9ibGVtXG4gICAqIFxuICAgKiBAcmV0dXJuIEEgdmFsaWQgXCJDb21tYW5kTWVzc2FnZVwiIG9iamVjdCBhcyBkZXRhaWxlZCBhYm92ZSBvciBudWxsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdW5zZXJpYWxpemVKc29uQ29tbWFuZE1lc3NhZ2VGcm9tUmVjZWl2ZWQobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgbGV0IGNvbW1hbmRNZXNzYWdlO1xuICAgIHRyeSB7XG4gICAgICBjb21tYW5kTWVzc2FnZSA9IEpTT04ucGFyc2UobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgUmF2aVV0aWxzLmVycihgQ291bGRuJ3QgcGFyc2UgY29tbWFuZCBtZXNzYWdlISBFcnJvcjpcXG4ke2V9XFxuIEZ1bGwgbWVzc2FnZSBjb250ZW50czpcXG4ke21lc3NhZ2V9YCwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY29tbWFuZE1lc3NhZ2UgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAyIGtleXM6XG4gICAgLy8gJ2MnOiB0aGUgY29tbWFuZCBuYW1lLCB0aGUgdG9rZW4gaWRlbnRpZnlpbmcgdGhlIGNvbW1hbmQgZGVzdGluYXRpb24gZm9yIHRoaXMgbWVzc2FnZVxuICAgIC8vICdwJzogdGhlIHBheWxvYWQgZGF0YSwgdGhlIGFjdHVhbCBpbmZvcm1hdGlvbiByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXJcbiAgICBpZiAoY29tbWFuZE1lc3NhZ2UgJiYgY29tbWFuZE1lc3NhZ2UuYyAmJiBjb21tYW5kTWVzc2FnZS5wKSB7XG4gICAgICByZXR1cm4geydjb21tYW5kJzogY29tbWFuZE1lc3NhZ2UuYywgJ3BheWxvYWQnOiBjb21tYW5kTWVzc2FnZS5wIH07XG4gICAgfVxuICAgIFJhdmlVdGlscy5lcnIoXCJNZXNzYWdlIGNhbm5vdCBiZSB1bnNlcmlhbGl6ZWQgaW50byBhIENvbW1hbmRNZXNzYWdlOiBcIiArIG1lc3NhZ2UsIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogXG4gICAqIFNlbmQgYSBwYXJ0aWN1bGFyIGNvbW1hbmQgaW5zdGFuY2UgaW1tZWRpYXRlbHkgLS1cbiAgICogdGhpcyBnZXRzIHVzZWQgaW50ZXJuYWxseSBieSB7QGxpbmsgUmF2aUNvbW1hbmRDb250cm9sbGVyI19wcm9jZXNzU2VuZGluZ1F1ZXVlZENvbW1hbmRzfVxuICAgKiBhbmQgaW4gZ2VuZXJhbCwgc2hvdWxkIG5vdCBiZSBjYWxsZWQgZXh0ZXJuYWxseS5cbiAgICogXG4gICAqIEBwYXJhbSB7UmF2aUNvbW1hbmRJbnN0YW5jZX0gY29tbWFuZEluc3RhbmNlXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VuZENvbW1hbmRJbnN0YW5jZShjb21tYW5kSW5zdGFuY2U6IFJhdmlDb21tYW5kSW5zdGFuY2UpIHtcbiAgICAvLyBSYXRoZXIgdGhhbiBjaGVja2luZyBmb3IgYW4gb3BlbiBjaGFubmVsIGV2ZXJ5IHRpbWUsIGp1c3QgdHJ5IGl0IGFuZFxuICAgIC8vIGNhdGNoIGFueSBlcnJvcnNcbiAgICB0cnkge1xuICAgICAgbGV0IG1lc3NhZ2UgPSBjb21tYW5kSW5zdGFuY2UuX2NvbW1hbmQ7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbWVzc2FnZSA9IHRoaXMuX3NlcmlhbGl6ZUpzb25Db21tYW5kTWVzc2FnZVRvU2VuZChjb21tYW5kSW5zdGFuY2UuX2NvbW1hbmQsIGNvbW1hbmRJbnN0YW5jZS5fcGFyYW0pO1xuICAgICAgICBSYXZpVXRpbHMubG9nKFwiU2VuZGluZyBjb21tYW5kIFwiICsgbWVzc2FnZSwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSYXZpVXRpbHMubG9nKFwiU2VuZGluZyBiaW5hcnkgY29tbWFuZFwiLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbW1hbmREYXRhQ2hhbm5lbC5zZW5kKG1lc3NhZ2UpO1xuICAgICAgLy8gd2UgZG9uJ3QgZ2V0IGFueXRoaW5nIGJhY2ssIHNvIGp1c3QgYXNzdW1lIGl0IHNlbnQgaWYgaXQgZGlkbid0IHRocm93IGFuIGVycm9yLi4uXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIFJhdmlVdGlscy5lcnIoXCJSZWNlaXZlZCBlcnJvciB3aGlsZSBzZW5kaW5nOiBcIiArIGVyci5tZXNzYWdlLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBcbiAgICogUHJvY2VzcyB0aGUgbGlzdGVuZXIgZm9yIHRoZSBtZXNzYWdlIGZyb20gdGhlIFJBVkkgc2VydmVyIC0tXG4gICAqIHRoaXMgZ2V0cyB1c2VkIGludGVybmFsbHkgYnkge0BsaW5rIFJhdmlXZWJSVENJbXBsZW1lbnRhdGlvbn1cbiAgICogYW5kIGluIGdlbmVyYWwsIHNob3VsZCBub3QgYmUgY2FsbGVkIGV4dGVybmFsbHkuXG4gICAqIFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZnJvbVNlcnZlck1lc3NhZ2VcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcm9jZXNzTGlzdGVuaW5nQ29tbWFuZChmcm9tU2VydmVyTWVzc2FnZTogYW55KSB7XG5cbiAgICBsZXQgc2VydmVyRGF0YSA9IGZyb21TZXJ2ZXJNZXNzYWdlLmRhdGE7XG4gICAgbGV0IGNvbW1hbmRNZXNzYWdlID0gbnVsbDtcblxuICAgIC8vIEZpcnN0IG9mZiwgaXMgdGhpcyBhIGJpbmFyeSBtZXNzYWdlIG9yIGEgSlNPTiBtZXNzYWdlP1xuICAgIC8vIElmIGl0J3MgYSBKU09OIG1lc3NhZ2UsIGl0J2xsIGJlIGEgc3RyaW5nOyBpZiBpdCdzIGFcbiAgICAvLyBiaW5hcnkgbWVzc2FnZSwgaXQnbGwgYmUgYW4gQXJyYXlCdWZmZXIuXG4gICAgLy8gKEFuZCBpZiBpdCdzIG5laXRoZXIgb2YgdGhvc2UsIHdlJ2xsIGxlYXZlIGNvbW1hbmRNZXNzYWdlXG4gICAgLy8gdW5zZXQgYW5kIHBpY2sgaXQgdXAgbGF0ZXIuKVxuICAgIGlmIChzZXJ2ZXJEYXRhKSB7XG4gICAgICBpZiAodHlwZW9mIHNlcnZlckRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEl0J3MgSlNPTi4gVGhlIGNvbW1hbmQgaW5mbyBpcyBhbHJlYWR5IGluIHRoZSBtZXNzYWdlLlxuICAgICAgICBjb21tYW5kTWVzc2FnZSA9IHRoaXMuX3Vuc2VyaWFsaXplSnNvbkNvbW1hbmRNZXNzYWdlRnJvbVJlY2VpdmVkKHNlcnZlckRhdGEpO1xuICAgICAgICB0aGlzLl9jb250aW51ZVByb2Nlc3NpbmdMaXN0ZW5pbmdDb21tYW5kKGNvbW1hbmRNZXNzYWdlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2VydmVyRGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXtcbiAgICAgICAgLy8gSXQncyBiaW5hcnkuIFdlJ2xsIHdyYXAgaXQgaW4gYSB0eXBlZCBhcnJheVxuICAgICAgICAvLyBhbmQgdGhlbiBpbiBhIEphdmFTY3JpcHQgc3RydWN0XG4gICAgICAgIC8vIHNvIHRoYXQgaXQgY2FuIGJlIHByb2Nlc3NlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgIC8vIFwicGF5bG9hZFwiIGNvZGUgcGF0aCBhcyB0aGUgSlNPTiBkYXRhXG4gICAgICAgIGNvbW1hbmRNZXNzYWdlID0geyAnY29tbWFuZCcgOiBfQklOQVJZX0NPTU1BTkRfS0VZLCAncGF5bG9hZCcgOiBuZXcgVWludDhBcnJheShzZXJ2ZXJEYXRhKX07XG4gICAgICAgIC8vIE5PVEU6IEN1cnJlbnRseSwgd2UgZG9uJ3QgbmF0aXZlbHkgaW5jbHVkZSBhbnkgc29ydCBvZiBcImNvbW1hbmRcIiBhc3NvY2lhdGVkXG4gICAgICAgIC8vIHdpdGggYmluYXJ5IG1lc3NhZ2VzIC0tIHdoZW4gd2UgZ2V0IGEgYmluYXJ5IG1lc3NhZ2UsIGFsbCBiaW5hcnlcbiAgICAgICAgLy8gaGFuZGxlcnMgYXJlIGNhbGxlZC4gV2UgbWF5IGRlY2lkZSB0byByZXRoaW5rIHRoaXMgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgdGhpcy5fY29udGludWVQcm9jZXNzaW5nTGlzdGVuaW5nQ29tbWFuZChjb21tYW5kTWVzc2FnZSk7XG4gICAgICB9IGVsc2UgaWYgKHNlcnZlckRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIHNlcnZlckRhdGEuYXJyYXlCdWZmZXIoKVxuICAgICAgICAgIC50aGVuKChwcm9jZXNzZWRBcnJheUJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgY29tbWFuZE1lc3NhZ2UgPSB7ICdjb21tYW5kJyA6IF9CSU5BUllfQ09NTUFORF9LRVksICdwYXlsb2FkJyA6IG5ldyBVaW50OEFycmF5KHByb2Nlc3NlZEFycmF5QnVmZmVyKX07XG4gICAgICAgICAgICB0aGlzLl9jb250aW51ZVByb2Nlc3NpbmdMaXN0ZW5pbmdDb21tYW5kKGNvbW1hbmRNZXNzYWdlKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfY29udGludWVQcm9jZXNzaW5nTGlzdGVuaW5nQ29tbWFuZChjb21tYW5kTWVzc2FnZTogYW55KSB7XG4gICAgaWYgKCFjb21tYW5kTWVzc2FnZSkge1xuICAgICAgUmF2aVV0aWxzLmVycihcIlJlY2VpdmVkIGludmFsaWQgY29tbWFuZCBtZXNzYWdlLCBpZ25vcmluZzogXCIgKyBKU09OLnN0cmluZ2lmeShjb21tYW5kTWVzc2FnZSksIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIFJhdmlVdGlscy5sb2coXCJfY29udGludWVQcm9jZXNzaW5nTGlzdGVuaW5nQ29tbWFuZDogXCIgKyBjb21tYW5kTWVzc2FnZSwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG5cbiAgICAvLyBMZXQncyB0cnkgdG8gZmluZCB0aGUgbWF0Y2hpbmcgbGlzdGVuZXIocykgZm9yIHRoZSBjb21tYW5kTWVzc2FnZSByZWNlaXZlZDpcbiAgICB2YXIgZm91bmRDb21tYW5kSW5zdGFuY2UgPSB0aGlzLl9jb21tYW5kUXVldWVNYXAuZ2V0KGNvbW1hbmRNZXNzYWdlLmNvbW1hbmQpO1xuICAgIGlmIChmb3VuZENvbW1hbmRJbnN0YW5jZSkge1xuICAgICAgLy8gSG93IG1hbnkgbGlzdGVuZXJzIGRvZXMgaXQgaGF2ZT9cbiAgICAgIHZhciBsZW5ndGggPSBmb3VuZENvbW1hbmRJbnN0YW5jZS5saXN0ZW5lci5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICAvKipcbiAgICAgICAgVE9ETzogV2UgbmVlZCB0byBhZGQgYm90aCBzZXJ2ZXIgJiBjbGllbnQgZnVuY3Rpb25hbGl0eSB0aGF0XG4gICAgICAgIHdpbGwgdHJhY2sgdGhlIFwiaW5zdGFuY2VcIiBvZiBhIGNvbW1hbmQgYW5kIHRyaWdnZXIgdGhlIGFwcHJvcHJpYXRlXG4gICAgICAgIGxpc3RlbmVyLiBSaWdodCBub3cgdGhpcyBjb3VsZCBiZWhhdmUgdW5leHBlY3RlZGx5IGluIHRoZSBzaXR1YXRpb25cbiAgICAgICAgd2hlcmUgd2UgcmVnaXN0ZXIgdHdvIGRpZmZlcmVudCBsaXN0ZW5lcnMgZm9yIHRoZSBzYW1lIGNvbW1hbmRcbiAgICAgICAgYW5kIHRoZSBcIndyb25nXCIgb25lIHJldHVybnMgZmlyc3QuIFNlZSBCSUdXT1JMRC00NTYuIFdlIGNhbiBtYWtlXG4gICAgICAgIHRoaXMgY29kZSBjbGVhbmVyIG9uY2UgdGhhdCdzIGltcGxlbWVudGVkLlxuXG4gICAgICAgIEluIHRoZSBtZWFudGltZSwgd2UnbGwgbGVhdmUgdGhlIFwiaW5zdGFuY2Ugb2YgYSBjb21tYW5kXCIgYmVoYXZpb3IgYXMgaXMuXG4gICAgICAgIEFuZCBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lciB3aXRoIGEgXCJtYXRjaGluZyBzZW50IGNvbW1hbmRcIiwgd2UnbGxcbiAgICAgICAgZXhlY3V0ZSBhbGwgdGhlIHJlbGV2YW50IFwibGlzdGVuLW9ubHlcIiBsaXN0ZW5lcnMuXG5cbiAgICAgICAgTk9URTogVGhpcyBjb2RlIGFzc3VtZXMgdGhhdCBhIGdpdmVuIGNvbW1hbmRNZXNzYWdlIFwiY29tbWFuZFwiIHN0cmluZ1xuICAgICAgICAoZS5nLiBcImNvbW1hbmQuYWJvdXRcIiBvciBcIm1lc3NhZ2UubG9jYXRpb25cIikgd2lsbCBvbmx5IGhhdmUgT05FIFRZUEVcbiAgICAgICAgb2YgbGlzdGVuZXI6IFwibWF0Y2hpbmcgc2VudCBjb21tYW5kXCIgb3IgXCJsaXN0ZW4tb25seVwiLiBJZiB5b3UgcXVldWVcbiAgICAgICAgYSBjb21tYW5kIHdpdGggYSBsaXN0ZW5lciwgYW5kIHRoZW4gQUxTTyB0cnkgdG9cbiAgICAgICAgYXNzb2NpYXRlIGEgbGlzdGVuLW9ubHkgbGlzdGVuZXIgd2l0aCB0aGF0IHNhbWUgY29tbWFuZCBuYW1lLFxuICAgICAgICBzdHJhbmdlIHRoaW5ncyB3aWxsIGhhcHBlbi4gKFNwZWNpZmljYWxseSwgdGhlIGNvbW1hbmQgaGFuZGxlciBmb3JcbiAgICAgICAgdGhlIHNlbnQgY29tbWFuZCB3aWxsIGJlIHRoZSBvbmx5IHRoaW5nIGV4ZWN1dGVkIHdoZW4geW91IGdldCB0aGUgZmlyc3RcbiAgICAgICAgcmVzcG9uc2UgYmFjaywgYnV0IGlmIHlvdSBnZXQgc3Vic2VxdWVudCByZXNwb25zZXMgYmFjaywgdGhlbiB0aGVcbiAgICAgICAgbGlzdGVuLW9ubHkgbGlzdGVuZXIocykgd2lsbCBleGVjdXRlLikgV2UgY2FuIHJlbW92ZSB0aGlzIHJlc3RyaWN0aW9uXG4gICAgICAgIG9uY2UgQklHV09STEQtNDU2IGlzIGltcGxlbWVudGVkLlxuICAgICAgICAqKi9cbiAgICAgICAgaWYgKGZvdW5kQ29tbWFuZEluc3RhbmNlLmxpc3RlbmVyWzBdICYmIGZvdW5kQ29tbWFuZEluc3RhbmNlLmxpc3RlbmVyWzBdLl9oYXNNYXRjaGluZ1NlbnRDb21tYW5kKSB7XG4gICAgICAgICAgLy8gVGhlcmUgd2FzIGFuIG9yaWdpbmFsIGNvbW1hbmQgc2VudCB0aGF0IHdlJ3JlIGxpc3RlbmluZyBmb3IgYSByZXNwb25zZSBmb3IsIFxuICAgICAgICAgIC8vIGNvbW1hbmQgc2VudCwgc28gdGhhdCBtZWFucyB3ZSBqdXN0IGV4ZWN1dGUgdGhlIGZpcnN0IGhhbmRsZXIsXG4gICAgICAgICAgLy8gd2hhdGV2ZXIgaXQgaXMuXG4gICAgICAgICAgdmFyIGNvbW1hbmRJbnN0YW5jZSA9IGZvdW5kQ29tbWFuZEluc3RhbmNlLmxpc3RlbmVyLnNoaWZ0KCk7XG4gICAgICAgICAgaWYgKGNvbW1hbmRJbnN0YW5jZSAmJiBjb21tYW5kSW5zdGFuY2UuX2hhbmRsZXIpIHtcbiAgICAgICAgICAgIGNvbW1hbmRJbnN0YW5jZS5faGFuZGxlcihjb21tYW5kTWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgICAgIHJldHVybjsgLy8gc3VjY2VzcywgZW5kIG9mIHRoZSAoZmlyc3QpIGxpc3RlbmVyXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFJhdmlVdGlscy5lcnIoXCJVbmRlZmluZWQgY29tbWFuZCBoYW5kbGVyOiBcIiArIGNvbW1hbmRNZXNzYWdlLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbmV3TGlzdGVuZXJzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gZm91bmRDb21tYW5kSW5zdGFuY2UubGlzdGVuZXJbaV07XG4gICAgICAgICAgICBpZiAobGlzdGVuZXIgJiYgbGlzdGVuZXIuX2hhbmRsZXIpIHtcbiAgICAgICAgICAgICAgLy8gYXR0ZW1wdCB0byBleGVjdXRlIHRoZSBoYW5kbGVyXG4gICAgICAgICAgICAgIGxpc3RlbmVyLl9oYW5kbGVyKGNvbW1hbmRNZXNzYWdlLnBheWxvYWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgUmF2aVV0aWxzLmVycihcIlVuZGVmaW5lZCBtZXNzYWdlIGhhbmRsZXI6IFwiICsgY29tbWFuZE1lc3NhZ2UsIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgaXQncyBzdGlja3ksIGFkZCBpdCB0byB0aGUgXCJuZXdcIiBsaXN0XG4gICAgICAgICAgICBpZiAobGlzdGVuZXIgJiYgbGlzdGVuZXIuX2lzU3RpY2t5KSB7XG4gICAgICAgICAgICAgIG5ld0xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVXBkYXRlIHdpdGggb25seSB0aGUgc3RpY2t5IG9uZXNcbiAgICAgICAgICBmb3VuZENvbW1hbmRJbnN0YW5jZS5saXN0ZW5lciA9IG5ld0xpc3RlbmVycztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gbm8gbGlzdGVuZXIgZGVmaW5lZCwganVzdCBtb3ZlIG9uLCB0aGlzIGlzIGFuIG9rIHBhdGhcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogXG4gICAqIFNldCB0aGUgaW5wdXQgZGF0YSBjaGFubmVsLlxuICAgKlxuICAgKiBAcGFyYW0ge1JUQ0RhdGFDaGFubmVsfSBpbnB1dERhdGFDaGFubmVsIFRoZSBkYXRhQ2hhbm5lbCB0byB1c2UuIFdoaWxlIHRoaXMgaXMgZGVmaW5lZCBhcyBhbiBSVENEYXRhQ2hhbm5lbCxcbiAgICogaHlwb3RoZXRpY2FsbHkgc29tZSBvdGhlciBraW5kIG9mIHN0cmVhbSB0aGF0IG9mZmVycyB0aGUgc2FtZSBBUEkgYW5kIGNhbGxiYWNrcyBhcyBhbiBSVENEYXRhQ2hhbm5lbFxuICAgKiBjb3VsZCBhbHNvIGJlIHVzZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0SW5wdXREYXRhQ2hhbm5lbChpbnB1dERhdGFDaGFubmVsOiBSVENEYXRhQ2hhbm5lbCkge1xuICAgIHRoaXMuX2lucHV0RGF0YUNoYW5uZWwgPSBpbnB1dERhdGFDaGFubmVsO1xuICAgIFJhdmlVdGlscy5sb2coXCJSZWNlaXZlZCBuZXcgaW5wdXQgZGF0YSBjaGFubmVsIHdpdGggaWQgXCIgKyB0aGlzLl9pbnB1dERhdGFDaGFubmVsLmlkLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcblxuICAgIHRoaXMuX2lucHV0RGF0YUNoYW5uZWwub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgUmF2aVV0aWxzLmxvZyhcIl9pbnB1dERhdGFDaGFubmVsIG9ub3Blbiwgc3RhdGUgaXMgXCIgKyB0aGlzLl9pbnB1dERhdGFDaGFubmVsLnJlYWR5U3RhdGUsIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX2lucHV0RGF0YUNoYW5uZWwub25jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIFJhdmlVdGlscy5sb2coXCJfaW5wdXREYXRhQ2hhbm5lbCBvbmNsb3NlLCBzdGF0ZSBpcyBcIiArIHRoaXMuX2lucHV0RGF0YUNoYW5uZWwucmVhZHlTdGF0ZSwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5faW5wdXREYXRhQ2hhbm5lbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZTogYW55KSB7XG4gICAgICBSYXZpVXRpbHMubG9nKFwiX2lucHV0RGF0YUNoYW5uZWwgZ290IG1lc3NhZ2U6IFwiICsgKG1lc3NhZ2UuZGF0YSksIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcbiAgICogU2V0IHRoZSBjb21tYW5kIGRhdGEgY2hhbm5lbC5cbiAgICpcbiAgICogQHBhcmFtIHtSVENEYXRhQ2hhbm5lbH0gY29tbWFuZERhdGFDaGFubmVsIFRoZSBkYXRhQ2hhbm5lbCB0byB1c2UuIFdoaWxlIHRoaXMgaXMgZGVmaW5lZCBhcyBhbiBSVENEYXRhQ2hhbm5lbCxcbiAgICogaHlwb3RoZXRpY2FsbHkgc29tZSBvdGhlciBraW5kIG9mIHN0cmVhbSB0aGF0IG9mZmVycyB0aGUgc2FtZSBBUEkgYW5kIGNhbGxiYWNrcyBhcyBhbiBSVENEYXRhQ2hhbm5lbFxuICAgKiBjb3VsZCBhbHNvIGJlIHVzZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0Q29tbWFuZERhdGFDaGFubmVsKGNvbW1hbmREYXRhQ2hhbm5lbDogUlRDRGF0YUNoYW5uZWwpIHtcbiAgICB0aGlzLl9jb21tYW5kRGF0YUNoYW5uZWwgPSBjb21tYW5kRGF0YUNoYW5uZWw7XG4gICAgUmF2aVV0aWxzLmxvZyhcIlJlY2VpdmVkIG5ldyBkYXRhIGNoYW5uZWwgd2l0aCBpZCBcIiArIHRoaXMuX2NvbW1hbmREYXRhQ2hhbm5lbC5pZCwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG4gIFxuICAgIHRoaXMuX2NvbW1hbmREYXRhQ2hhbm5lbC5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBSYXZpVXRpbHMubG9nKFwiX2NvbW1hbmREYXRhQ2hhbm5lbCBvbm9ucGVuLCBzdGF0ZSBpcyBcIiArIHRoaXMuX2NvbW1hbmREYXRhQ2hhbm5lbC5yZWFkeVN0YXRlLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcbiAgICAgIC8vIEtpY2sgb2ZmIHRoZSBtb25pdG9yaW5nIG9mIHRoZSBjb21tYW5kIHF1ZXVlcyBpbiB0aGUgY29tbWFuZCBjb250cm9sbGVyLlxuICAgICAgdGhpcy5tb25pdG9yUXVldWVzKCk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fY29tbWFuZERhdGFDaGFubmVsLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBSYXZpVXRpbHMubG9nKFwiX2NvbW1hbmREYXRhQ2hhbm5lbCBvbmNsb3NlLCBzdGF0ZSBpcyBcIiArIHRoaXMuX2NvbW1hbmREYXRhQ2hhbm5lbC5yZWFkeVN0YXRlLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcbiAgICAgIC8vIFN0b3AgbW9uaXRvcmluZyB0aGUgY29tbWFuZCBxdWV1ZVxuICAgICAgdGhpcy5zdG9wTW9uaXRvcmluZ1F1ZXVlcygpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX2NvbW1hbmREYXRhQ2hhbm5lbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZTogYW55KSB7XG4gICAgICB0aGlzLl9wcm9jZXNzTGlzdGVuaW5nQ29tbWFuZChtZXNzYWdlKTtcbiAgICB9LmJpbmQodGhpcyk7XG4gIH1cblxuICBcbiAgLyoqXG4gICAqIFNldCBhIERPTSBlbGVtZW50IHRoYXQgaXMgdXNlZCB0byB0cmFjayBpbnB1dCBldmVudCAobW91c2UgJiB0b3VjaClcbiAgICogc2V2ZXJhbCBsaXN0ZW5lcnMgYXJlIGFkZGVkIHRvIHRoZSBlbGVtZW50IGFuZCBjb21tdW5pY2F0ZSBpbnB1dCBldmVudHMgdG8gUmF2aSBTZXJ2ZXIgdGhyb3VnaCB0aGUgaW5wdXQgY2hhbm5lbFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGlucHV0VGFyZ2V0RWxlbWVudCBSZWZlcmVuY2UgdG8gdGhlIEphdmFTY3JpcHQgRE9NIGVsZW1lbnQgdXNlZCB0byB0cmFjayBpbnB1dCBldmVudHMgXG4gICAqL1xuICBzZXRJbnB1dFRhcmdldChpbnB1dFRhcmdldEVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gICAgaWYgKHRoaXMuX2lucHV0VGFyZ2V0KSB7XG4gICAgICB0aGlzLl9pbnB1dFRhcmdldC5vbm1vdXNlbW92ZSA9IG51bGw7XG4gICAgICB0aGlzLl9pbnB1dFRhcmdldC5vbm1vdXNlZW50ZXIgPSBudWxsO1xuICAgICAgdGhpcy5faW5wdXRUYXJnZXQub25tb3VzZWxlYXZlID0gbnVsbDtcbiAgICAgIHRoaXMuX2lucHV0VGFyZ2V0Lm9ubW91c2Vkb3duID0gbnVsbDtcbiAgICAgIHRoaXMuX2lucHV0VGFyZ2V0Lm9ubW91c2V1cCA9IG51bGw7XG4gICAgICB0aGlzLl9pbnB1dFRhcmdldC5vbndoZWVsID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLl9pbnB1dFRhcmdldCA9IGlucHV0VGFyZ2V0RWxlbWVudDtcblxuICAgIGlmICh0aGlzLl9pbnB1dFRhcmdldCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9pbnB1dFRhcmdldC5vbm1vdXNlbW92ZSA9ICBmdW5jdGlvbihldmVudCkgeyB0aGF0Ll90cmFja01vdXNlKGV2ZW50KTsgfTtcbiAgICAgIHRoaXMuX2lucHV0VGFyZ2V0Lm9ubW91c2VlbnRlciA9IG51bGw7XG4gICAgICB0aGlzLl9pbnB1dFRhcmdldC5vbm1vdXNlbGVhdmUgPSBudWxsO1xuICAgICAgdGhpcy5faW5wdXRUYXJnZXQub25tb3VzZWRvd24gPSBmdW5jdGlvbihldmVudCkgeyB0aGF0Ll9jYXB0dXJlTW91c2VEb3duKGV2ZW50KTsgfTtcbiAgICAgIHRoaXMuX2lucHV0VGFyZ2V0Lm9ubW91c2V1cCA9IGZ1bmN0aW9uKGV2ZW50KSB7IHRoYXQuX3Jlc2V0TW91c2VEb3duKGV2ZW50KTsgfTtcbiAgICAgIHRoaXMuX2lucHV0VGFyZ2V0Lm9ud2hlZWwgPSAgZnVuY3Rpb24oZXZlbnQpIHsgdGhhdC5fd2hlZWxNb3VzZShldmVudCk7IH07XG4gICAgfVxuICB9XG5cbiBzZXRLZXlib2FyZFRhcmdldChpbnB1dFRhcmdldEVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gICAgaWYgKHRoaXMuX2tleWJvYXJkVGFyZ2V0KSB7XG4gICAgICB0aGlzLl9rZXlib2FyZFRhcmdldC5vbmtleWRvd24gPSBudWxsO1xuICAgICAgdGhpcy5fa2V5Ym9hcmRUYXJnZXQub25rZXl1cCA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5fa2V5Ym9hcmRUYXJnZXQgPSBpbnB1dFRhcmdldEVsZW1lbnQ7XG5cbiAgICBpZiAodGhpcy5fa2V5Ym9hcmRUYXJnZXQpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgdGhpcy5fa2V5Ym9hcmRUYXJnZXQub25rZXlkb3duID0gZnVuY3Rpb24oZXZlbnQpIHsgdGhhdC5fb25LZXlib2FyZERvd24oZXZlbnQpOyB9O1xuICAgICAgdGhpcy5fa2V5Ym9hcmRUYXJnZXQub25rZXl1cCA9IGZ1bmN0aW9uKGV2ZW50KSB7IHRoYXQuX29uS2V5Ym9hcmRVcChldmVudCk7IH07XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogXG4gICAqL1xuICBfY2FwdHVyZU1vdXNlRG93bihlOiBNb3VzZUV2ZW50KSB7XG4gICAgdGhpcy5fbW91c2VTdGF0ZUZsb2F0WzBdID0gZS5vZmZzZXRYO1xuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdFsxXSA9IGUub2Zmc2V0WTtcbiAgICB0aGlzLl9tb3VzZVN0YXRlRmxvYXRbMl0gPSBlLm9mZnNldFg7XG4gICAgdGhpcy5fbW91c2VTdGF0ZUZsb2F0WzNdID0gZS5vZmZzZXRZO1xuXG4gICAgdGhpcy5fbW91c2VTdGF0ZVVpbnQ4WzFdID0gZS5idXR0b25zO1xuXG4gICAgLy8gQW5kIHNlbmQgc3RhdGVcbiAgICB0aGlzLl9zZW5kTW91c2VTdGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBcbiAgICovXG4gIF9yZXNldE1vdXNlRG93bihlOiBNb3VzZUV2ZW50KSB7XG4gICAgdGhpcy5fbW91c2VTdGF0ZUZsb2F0WzBdID0gLTEuMDtcbiAgICB0aGlzLl9tb3VzZVN0YXRlRmxvYXRbMV0gPSAtMS4wO1xuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdFsyXSA9IC0xLjA7XG4gICAgdGhpcy5fbW91c2VTdGF0ZUZsb2F0WzNdID0gLTEuMDtcblxuICAgIHRoaXMuX21vdXNlU3RhdGVVaW50OFsxXSA9IGUuYnV0dG9ucztcblxuICAgIC8vIEFuZCBzZW5kIHN0YXRlXG4gICAgdGhpcy5fc2VuZE1vdXNlU3RhdGUoKTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogXG4gICAqL1xuICBfdHJhY2tNb3VzZShlOiBNb3VzZUV2ZW50KSB7XG4gICAgLy8gdXBkYXRlIHRoZSBjdXJyZW50IG1vdXNlIHBvcyBpbiB0aGUgb3VzZVN0YXRlQnVmZmZlclxuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdFswXSA9IGUub2Zmc2V0WDtcbiAgICB0aGlzLl9tb3VzZVN0YXRlRmxvYXRbMV0gPSBlLm9mZnNldFk7XG5cbiAgICB0aGlzLl9tb3VzZVN0YXRlRmxvYXRbNF0gPSB0aGlzLl9pbnB1dFRhcmdldC5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLl9tb3VzZVN0YXRlRmxvYXRbNV0gPSB0aGlzLl9pbnB1dFRhcmdldC5vZmZzZXRIZWlnaHQ7XG5cbiAgICB0aGlzLl9tb3VzZVN0YXRlVWludDhbMV0gPSBlLmJ1dHRvbnM7XG5cbiAgICAvLyBBbmQgc2VuZCBzdGF0ZVxuICAgIHRoaXMuX3NlbmRNb3VzZVN0YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogXG4gICAqL1xuICBfd2hlZWxNb3VzZShlOiBXaGVlbEV2ZW50KSB7XG4gICAgdGhpcy5fbW91c2VTdGF0ZUZsb2F0WzZdID0gZS5kZWx0YVk7XG4gICAgdGhpcy5fc2VuZE1vdXNlU3RhdGUoKTtcbiAgICB0aGlzLl9tb3VzZVN0YXRlRmxvYXRbNl0gPSAwO1xuICB9XG5cbiAgX3NlbmRNb3VzZVN0YXRlKCkge1xuICAgIHRoaXMuc2VuZElucHV0KHRoaXMuX21vdXNlU3RhdGVCdWZmZXIpO1xuICB9XG5cbiAgX2tleUJ5dGVOdW0oYzogYW55KSB7XG4gICAgcmV0dXJuIGMgPj4gMztcbiAgfVxuICBfa2V5Qml0TWFzayhjOiBhbnkpIHtcbiAgICByZXR1cm4gKDEgPDwgKGMgJSA4KSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbktleWJvYXJkRG93bihlOiBLZXlib2FyZEV2ZW50KSB7XG4gICAgbGV0IGMgPSBfS0VZX0NPREVfVEFCTEVbPGFueT4gZS5jb2RlXTtcbiAgICBsZXQga2V5Qnl0ZU51bSA9IDEgKyB0aGlzLl9rZXlCeXRlTnVtKGMpO1xuICAgIGxldCBrZXlCeXRlTWFzayA9IHRoaXMuX2tleUJpdE1hc2soYyk7XG4gICAgaWYgKCh0aGlzLl9rZXlib2FyZFN0YXRlW2tleUJ5dGVOdW1dICYga2V5Qnl0ZU1hc2spID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2tleWJvYXJkU3RhdGVba2V5Qnl0ZU51bV0gfD0ga2V5Qnl0ZU1hc2s7XG4gICAgICAgIHRoaXMuX3NlbmRLZXlib2FyZFN0YXRlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25LZXlib2FyZFVwKGU6IEtleWJvYXJkRXZlbnQpIHtcbiAgICBsZXQgYyA9IF9LRVlfQ09ERV9UQUJMRVs8YW55PiBlLmNvZGVdO1xuICAgIGxldCBrZXlCeXRlTnVtID0gMSArIHRoaXMuX2tleUJ5dGVOdW0oYyk7XG4gICAgbGV0IGtleUJ5dGVNYXNrID0gdGhpcy5fa2V5Qml0TWFzayhjKTtcbiAgICBpZiAoKHRoaXMuX2tleWJvYXJkU3RhdGVba2V5Qnl0ZU51bV0gJiBrZXlCeXRlTWFzaykgIT09IDApIHtcbiAgICAgICAgdGhpcy5fa2V5Ym9hcmRTdGF0ZVtrZXlCeXRlTnVtXSBePSBrZXlCeXRlTWFzaztcbiAgICAgICAgdGhpcy5fc2VuZEtleWJvYXJkU3RhdGUoKTtcbiAgICB9XG4gIH1cblxuICBfc2VuZEtleWJvYXJkU3RhdGUoKSB7XG4gICAgdGhpcy5zZW5kSW5wdXQodGhpcy5fa2V5Ym9hcmRTdGF0ZUJ1ZmZlcik7XG4gIH1cblxufSAvLyBFbmQgb2YgdGhlIFJhdmlDb21tYW5kQ29udHJvbGxlciBjbGFzc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbi8qKiBcbiAqXG4gKiBBIGNvbW1hbmQgaW5zdGFuY2UgZm9yIHVzZSB3aXRoIHRoZSBcbiAqIFJhdmlDb21tYW5kQ29udHJvbGxlci4gVGhpcyBpcyBqdXN0XG4gKiBhIHNwZWNpYWxpemVkIG9iamVjdCB0byB0cmFjayB0aGUgY29tYmluYXRpb24gb2ZcbiAqIGEgY29tbWFuZCB0eXBlLCB0aGUgcGFyYW1ldGVycyBmb3IgdGhhdCBjb21tYW5kLFxuICogYW5kIHRoZSBoYW5kbGVyIHRvIGJlIHVzZWQgZm9yIHRoZSBjb21tYW5kIHJlc3VsdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21tYW5kIC0gVGhlIGFjdHVhbCBzdHJpbmcgY29tbWFuZCB0byBzZW5kXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW0gLSBBbnkgcGFyYW1ldGVycyB0byBiZSBzZW50IHRvIHRoZSBjb21tYW5kXG4gKiBAcGFyYW0ge1JhdmlDb21tYW5kQ29udHJvbGxlci5SYXZpQ29tbWFuZEhhbmRsZXJJbnN0YW5jZX0gaGFuZGxlciAtIEEgY2FsbGJhY2sgaGFuZGxlciB0byB1c2Ugd2hlbiB0aGUgY29tbWFuZCByZXR1cm5zIGZyb20gdGhlIHNlcnZlclxuICogXG4gKiBAY2xhc3MgUmF2aUNvbW1hbmRDb250cm9sbGVyLlJhdmlDb21tYW5kSW5zdGFuY2VcbiAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIGNvbW1hbmQgdGhhdCBzaG91bGQgYmUgXG4gKiBxdWV1ZWQgdXAgaW4gdGhlIFJhdmlDb21tYW5kQ29udHJvbGxlcidzIGNvbW1hbmQgcXVldWUuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUmF2aUNvbW1hbmRJbnN0YW5jZSB7XG4gIF9jb21tYW5kOiBhbnk7XG4gIF9wYXJhbTogYW55O1xuICBfaGFuZGxlcjogYW55O1xuXG4gIC8qXG4gICAqIFwiQ2xhc3NcIiB2YXJpYWJsZXMgdG8gYmUgYXdhcmUgb2Y6XG4gICAqIHRoaXMuX2NvbW1hbmQ7XG4gICAqIHRoaXMuX3BhcmFtO1xuICAgKiB0aGlzLl9oYW5kbGVyO1xuICAgKi9cbiAgXG4gIC8qKiBcbiAgICogQHByaXZhdGUgXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb21tYW5kOiBhbnksIHBhcmFtOiBhbnksIGhhbmRsZXI6IGFueSkge1xuICAgIFJhdmlVdGlscy5sb2coXCJjb25zdHJ1Y3RvclwiLCBcIlJhdmlDb21tYW5kSW5zdGFuY2VcIik7XG4gICAgdGhpcy5fY29tbWFuZCA9IGNvbW1hbmQ7XG4gICAgdGhpcy5fcGFyYW0gPSBwYXJhbTtcbiAgICB0aGlzLl9oYW5kbGVyID0gaGFuZGxlcjtcbiAgfVxufVxuXG4vKiogXG4gKlxuICogQSBoYW5kbGVyIGluc3RhbmNlIGZvciB1c2Ugd2l0aCB0aGUgXG4gKiBSYXZpQ29tbWFuZENvbnRyb2xsZXIuIFRoaXMganVzdFxuICogdHJhY2tzIHRoZSBoYW5kbGVyIGZ1bmN0aW9uIGFuZCB3aGV0aGVyIG9yIFxuICogbm90IGl0J3MgXCJzdGlja3kuXCIgSGFuZGxlcnMgdGhhdCBhcmUgYXNzb2NpYXRlZFxuICogd2l0aCBhIHBhcnRpY3VsYXIgU0VOVCBjb21tYW5kIGFyZSBOT1Qgc3RpY2t5IGJ5XG4gKiBkZWZhdWx0IChpLmUuIHRoZXkgZXhlY3V0ZSBvbmNlLCBhbmQgdGhlbiBzdG9wXG4gKiBsaXN0ZW5pbmcpLCBidXQgbGlzdGVuZXJzIHRoYXQgYXJlIHJlZ2lzdGVyZWRcbiAqIGJ5IHRoZW1zZWx2ZXMgY2FuIGJlIGVpdGhlciBzdGlja3kgb3Igbm90IHN0aWNreS5cbiAqIEBwYXJhbSB7UmF2aUNvbW1hbmRDb250cm9sbGVyfmNvbW1hbmRDYWxsYmFja30gaGFuZGxlciAtIEEgY2FsbGJhY2sgaGFuZGxlciB0byB1c2Ugd2hlbiB0aGUgY29tbWFuZCByZXR1cm5zIGZyb20gdGhlIHNlcnZlclxuICogQHBhcmFtIHtib29sZWFufSBpc1N0aWNreSAtIFdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIHN0aWNrcyBhcm91bmQgZm9yZXZlciAodHJ1ZSkgb3Igc3RvcHMgbGlzdGVuaW5nIGFmdGVyIGl0IGdldHNcbiAqIGl0cyBmaXJzdCByZXNwb25zZSAoZmFsc2UpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhhc01hdGNoaW5nU2VudENvbW1hbmQgLSBXaGV0aGVyIG9yIG5vdCB0aGlzIGhhbmRsZXIgaGFzIGEgbWF0Y2hpbmcgY29tbWFuZCB0aGF0IHdhcy9pcyBnb2luZyB0byBiZSBcbiAqIHNlbnQgdG8gdGhlIHNlcnZlciAodHJ1ZSksIG9yIGlmIGl0J3MganVzdCBsaXN0ZW5pbmcgZm9yIHNvbWV0aGluZyB0aGUgc2VydmVyIG1pZ2h0IHNlbmQgb24gaXRzIG93biAoZmFsc2UpXG4gKiBcbiAqIEBjbGFzcyBSYXZpQ29tbWFuZENvbnRyb2xsZXIuUmF2aUNvbW1hbmRIYW5kbGVySW5zdGFuY2VcbiAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIGhhbmRsZXIgdGhhdCBjYW4gYmUgXG4gKiB1c2VkIHRvIHByb2Nlc3MgbWVzc2FnZXMgZnJvbSB0aGUgc2VydmVyXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUmF2aUNvbW1hbmRIYW5kbGVySW5zdGFuY2Uge1xuICBfaGFuZGxlcjogYW55O1xuICBfaXNTdGlja3k6IGJvb2xlYW47XG4gIF9oYXNNYXRjaGluZ1NlbnRDb21tYW5kOiBib29sZWFuO1xuXG4gIC8qXG4gICAqIFwiQ2xhc3NcIiB2YXJpYWJsZXM6XG4gICAqIHRoaXMuX2hhbmRsZXI7XG4gICAqIHRoaXMuX2lzU3RpY2t5O1xuICAgKiB0aGlzLl9oYXNNYXRjaGluZ1NlbnRDb21tYW5kO1xuICAgKi9cbiAgLyoqIFxuICAgKiBAcHJpdmF0ZSBcbiAgICovXG4gIGNvbnN0cnVjdG9yKGhhbmRsZXI6IGFueSwgaXNTdGlja3k6IGJvb2xlYW4sIGhhc01hdGNoaW5nU2VudENvbW1hbmQ6IGJvb2xlYW4pIHtcbiAgICBSYXZpVXRpbHMubG9nKFwiY29uc3RydWN0b3JcIiwgXCJSYXZpQ29tbWFuZEhhbmRsZXJJbnN0YW5jZVwiKTtcbiAgICB0aGlzLl9oYW5kbGVyID0gaGFuZGxlcjtcbiAgICB0aGlzLl9pc1N0aWNreSA9IGlzU3RpY2t5O1xuICAgIHRoaXMuX2hhc01hdGNoaW5nU2VudENvbW1hbmQgPSBoYXNNYXRjaGluZ1NlbnRDb21tYW5kO1xuICB9XG59XG4iLCJcbmltcG9ydCB7IFJhdmlTaWduYWxpbmdDb25uZWN0aW9uIH0gZnJvbSAnLi9SYXZpU2lnbmFsaW5nQ29ubmVjdGlvbic7XG5pbXBvcnQgeyBSYXZpU3RyZWFtQ29udHJvbGxlciB9IGZyb20gJy4vUmF2aVN0cmVhbUNvbnRyb2xsZXInO1xuaW1wb3J0IHsgUmF2aVV0aWxzIH0gZnJvbSAnLi9SYXZpVXRpbHMnO1xuaW1wb3J0IHsgUmF2aUNvbW1hbmRDb250cm9sbGVyIH0gZnJvbSAnLi9SYXZpQ29tbWFuZENvbnRyb2xsZXInO1xuXG5cbi8qKlxuICogRW51bSBmb3IgcmVwcmVzZW50aW5nIGRpZmZlcmVudCBwb3NzaWJsZSBzdGF0ZXNcbiAqIHRoYXQgYSBSQVZJIHNlc3Npb24gbWlnaHQgYmUgaW4uXG4gKiBcbiAqIEByZWFkb25seVxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGVudW0gUmF2aVNlc3Npb25TdGF0ZXMge1xuICBORVcgPSBcIm5ld1wiLFxuICBDT05ORUNUSU5HID0gXCJjaGVja2luZ1wiLFxuICBDT05ORUNURUQgPSBcImNvbm5lY3RlZFwiLFxuICBDT01QTEVURUQgPSBcImNvbXBsZXRlZFwiLFxuICBESVNDT05ORUNURUQgPSBcImRpc2Nvbm5lY3RlZFwiLFxuICBGQUlMRUQgPSBcImZhaWxlZFwiLFxuICBDTE9TRUQgPSBcImNsb3NlZFwiXG59O1xuXG4vKiogXG4gKlxuICogQGNsYXNzXG4gKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBjb21tdW5pY2F0aW9ucyBzZXNzaW9uIGJldHdlZW4gYSBSQVZJIEpTIGNsaWVudCBhbmQgYSBSQVZJIHNlcnZlci5cbiAqIFRoaXMgY2xhc3Mgc2hvdWxkIGJlIGluc3RhbnRpYXRlZCBieSB0aGUgUkFWSSBjb25zdW1lciwgYW5kIHRoZW4gdXNlZCB0byBvcGVuLCB3b3JrIHdpdGgsIGFuZCBjbG9zZSBcbiAqIFJBVkkgc2Vzc2lvbnMgYXMgbmVlZGVkLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIFJhdmlTZXNzaW9uIHtcbiAgX3N0YXRlQ2hhbmdlSGFuZGxlcnM6IFNldDxGdW5jdGlvbj47XG4gIF91dWlkOiBzdHJpbmc7XG5cbiAgX2NvbW1hbmRDb250cm9sbGVyOiBSYXZpQ29tbWFuZENvbnRyb2xsZXI7XG4gIF9zdHJlYW1Db250cm9sbGVyOiBSYXZpU3RyZWFtQ29udHJvbGxlcjtcblxuICBfc3RhdGU6IFJhdmlTZXNzaW9uU3RhdGVzO1xuXG4gIF9yYXZpSW1wbGVtZW50YXRpb246IFJhdmlXZWJSVENJbXBsZW1lbnRhdGlvbjtcblxuICAvKipcbiAgICogXCJDbGFzc1wiIHZhcmlhYmxlcyB0byBiZSBhd2FyZSBvZjpcbiAgICpcbiAgICogdGhpcy5fdXVpZCAgICAgICAgICAgICAgICAgLy8gQSBVVUlEIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHBhcnRpY3VsYXIgUmF2aVNlc3Npb25cbiAgICogdGhpcy5fc3RhdGVDaGFuZ2VIYW5kbGVycyAgLy8gQSBsaXN0IG9mIGhhbmRsZXJzIHRvIGNhbGwgd2hlbiBzb21ldGhpbmcgKGUuZy4gc3RhdGUpLCBcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2VzLCBpbmNsdWRpbmcgd2hlbiBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWRcbiAgICpcbiAgICogdGhpcy5fcmF2aUltcGxlbWVudGF0aW9uICAgLy8gVGhlIGltcGxlbWVudGF0aW9uIG9mIGV4YWN0bHkgaG93IHRvIGltcGxlbWVudCB0aGUgUkFWSSBjb25uZWN0aW9uIChlLmcuIHdpdGggV2ViUlRDKVxuICAgKiB0aGlzLl9jb21tYW5kQ29udHJvbGxlclxuICAgKiB0aGlzLl9zdHJlYW1Db250cm9sbGVyXG4gICAqXG4gICAqIHRoaXMuX3N0YXRlICAgICAgICAgICAgICAgICAvLyBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGlzIGNvbm5lY3Rpb25cbiAgICovXG4gIFxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFJhdmlTZXNzaW9uLlxuICAgKiBEZWZhdWx0cyB0byB1c2luZyBuZXcgUmF2aUNvbW1hbmRDb250cm9sbGVyIGFuZCBSYXZpU3RyZWFtQ29udHJvbGxlcnNcbiAgICogYW5kIGluaXRpYWxpemVzIHRoZSBzdGF0ZSB0byBSYXZpU2Vzc2lvblN0YXRlcy5DTE9TRUQuXG4gICAqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcIkNvbnN0cnVjdG9yXCIsIFwiUmF2aVNlc3Npb25cIik7XG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgbGlzdCBvZiBoYW5kbGVycyBhbmQgdGhlIFVVSURcbiAgICB0aGlzLl9zdGF0ZUNoYW5nZUhhbmRsZXJzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX3V1aWQgPSBSYXZpVXRpbHMuY3JlYXRlVVVJRCgpO1xuICAgIFxuICAgIC8vIEFuZCB0aGUgY29tbWFuZCBjb250cm9sbGVyIGFuZCBzdHJlYW0gY29udHJvbGxlclxuICAgIHRoaXMuX2NvbW1hbmRDb250cm9sbGVyID0gbmV3IFJhdmlDb21tYW5kQ29udHJvbGxlcigpO1xuICAgIHRoaXMuX3N0cmVhbUNvbnRyb2xsZXIgPSBuZXcgUmF2aVN0cmVhbUNvbnRyb2xsZXIodGhpcy5fY29tbWFuZENvbnRyb2xsZXIpO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG4gICAgdGhpcy5fc3RhdGUgPSBSYXZpU2Vzc2lvblN0YXRlcy5DTE9TRUQ7XG4gICAgXG4gICAgLy8gSWYgd2Ugd2FudGVkIHRvIHVzZSBhIGRpZmZlcmVudCBjb25uZWN0aW9uIGltcGxlbWVudGF0aW9uLFxuICAgIC8vIHdlIHdvdWxkIG5ldygpIGl0IGhlcmUuIChUT0RPOiBNYWtlIHRoaXMgY29uZmlndXJhYmxlIGluIHNvbWVcbiAgICAvLyBpbnRlcmVzdGluZyB3YXkuIEZvciBub3csIGl0J3MgZW5vdWdoIGp1c3QgdG8gbWFrZSBpdCBlYXNpbHkgXG4gICAgLy8gc3dhcHBhYmxlIGluIHRoZSBjb2RlIGhlcmUuKVxuICAgIHRoaXMuX3JhdmlJbXBsZW1lbnRhdGlvbiA9IG5ldyBSYXZpV2ViUlRDSW1wbGVtZW50YXRpb24odGhpcyk7XG4gICAgLy8gV2hlbiBzb21lb25lIHNldHMgYW4gaW5wdXQgYXVkaW8gc3RyZWFtIG9uIHRoZSBzdHJlYW0gY29udHJvbGxlcixcbiAgICAvLyBwYXNzIHRoYXQgYWxvbmcgdG8gdGhlIGltcGxlbWVudGF0aW9uJ3MgX2FkZEF1ZGlvSW5wdXRTdHJlYW0gbWV0aG9kLlxuICAgIGNvbnN0IHJhdmlJbXBsID0gdGhpcy5fcmF2aUltcGxlbWVudGF0aW9uO1xuICAgIHRoaXMuX3N0cmVhbUNvbnRyb2xsZXIuc2V0SW5wdXRBdWRpb0NoYW5nZUhhbmRsZXIocmF2aUltcGwuX2FkZEF1ZGlvSW5wdXRTdHJlYW0uYmluZChyYXZpSW1wbCkpO1xuICAgIHRoaXMuX3N0cmVhbUNvbnRyb2xsZXIuc2V0SW5wdXRWaWRlb0NoYW5nZUhhbmRsZXIocmF2aUltcGwuX2FkZFZpZGVvSW5wdXRTdHJlYW0uYmluZChyYXZpSW1wbCkpO1xuICB9XG4gIFxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBSQVZJIHNlc3Npb24uXG4gICAqIFxuICAgKiBAcmV0dXJucyB7UmF2aVNlc3Npb25TdGF0ZXN9XG4gICAqL1xuICBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBVVUlEIG9mIHRoZSBzZXNzaW9uXG4gICAqIFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0VVVJRCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXVpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmb3IgbGlzdGVuaW5nIHRvIHN0YXRlIGNoYW5nZXNcbiAgICogQGNhbGxiYWNrIFJhdmlTZXNzaW9ufnN0YXRlQ2hhbmdlQ2FsbGJhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IEFuIG9iamVjdCB0aGF0IHdpbGwgY29udGFpbiBpbmZvcm1hdGlvblxuICAgKiBhYm91dCB0aGUgc3RhdGUgY2hhbmdlLiBUaGlzIGluY2x1ZGVzIHRoZSBcImV2ZW50LnN0YXRlXCIga2V5LFxuICAgKiB3aGljaCB3aWxsIGhhdmUgdGhlIGFwcHJvcHJpYXRlIHZhbHVlIGZyb20gdGhlIFJhdmlTZXNzaW9uU3RhdGVzIGVudW0uXG4gICAqL1xuICAvKipcbiAgICogQWRkIGEgaGFuZGxlciB0aGF0IHdpbGwgYmUgdXNlZCB0byBsaXN0ZW4gZm9yIHN0YXRlXG4gICAqIGNoYW5nZSBldmVudHMuXG4gICAqIFRoZXNlIGFyZSBzdG9yZWQgaW4gYSBTZXQgb2YgRnVuY3Rpb25zOyB0aGVyZWZvcmUsIGEgZ2l2ZW4gZnVuY3Rpb25cbiAgICogY2FuIG9ubHkgZXhpc3Qgb25jZSBpbiB0aGlzIFNldC5cbiAgICogXG4gICAqIEBwYXJhbSB7UmF2aVNlc3Npb25+c3RhdGVDaGFuZ2VDYWxsYmFja30gaGFuZGxlciBBIGNhbGxiYWNrIGhhbmRsZXIgdGhhdCBzaG91bGQgaGFuZGxlIGEgc3RhdGUgY2hhbmdlIGV2ZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgYWRkIHN1Y2NlZWRlZFxuICAgKi9cbiAgYWRkU3RhdGVDaGFuZ2VIYW5kbGVyKGNoYW5nZUhhbmRsZXI6IEZ1bmN0aW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX3N0YXRlQ2hhbmdlSGFuZGxlcnMuYWRkKGNoYW5nZUhhbmRsZXIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBSYXZpVXRpbHMuZXJyKFwiRXJyb3IgYWRkaW5nIGEgc3RhdGUgY2hhbmdlIGhhbmRsZXI6IFwiICtcbiAgICAgICAgZXJyLm1lc3NhZ2UsIFwiUmF2aVNlc3Npb25cIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBoYW5kbGVyIHNvIHRoYXQgaXQgc3RvcHMgbGlzdGVuaW5nIGZvciBzdGF0ZVxuICAgKiBjaGFuZ2UgZXZlbnRzLlxuICAgKiBcbiAgICogQHBhcmFtIHtSYXZpU2Vzc2lvbn5zdGF0ZUNoYW5nZUNhbGxiYWNrfSBoYW5kbGVyIEEgY2FsbGJhY2sgaGFuZGxlciB0aGF0IGhhcyBiZWVuIGhhbmRsaW5nIGEgc3RhdGUgY2hhbmdlIGV2ZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgcmVtb3ZhbCB3YXMgc3VjY2Vzc2Z1bCAoaS5lLiBkaWQgbm90IHRocm93IGFuIGVycm9yIC0tIG5vdGUgdGhhdCB0aGlzIGRvZXNcbiAgICogTk9UIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIHdhcyBpbiB0aGUgc2V0IGluIHRoZSBmaXJzdCBwbGFjZSlcbiAgICovXG4gIHJlbW92ZVN0YXRlQ2hhbmdlSGFuZGxlcihjaGFuZ2VIYW5kbGVyOiBGdW5jdGlvbikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9zdGF0ZUNoYW5nZUhhbmRsZXJzLmRlbGV0ZShjaGFuZ2VIYW5kbGVyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgUmF2aVV0aWxzLmVycihcIkVycm9yIHJlbW92aW5nIGEgc3RhdGUgY2hhbmdlIGhhbmRsZXI6IFwiICtcbiAgICAgICAgZXJyLm1lc3NhZ2UsIFwiUmF2aVNlc3Npb25cIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCB0aGUgUmF2aUNvbW1hbmRDb250cm9sbGVyIGZvciB1c2Ugd2l0aCB0aGlzIFJhdmlTZXNzaW9uLlxuICAgKiBUaGUge2xpbmsgUmF2aUNvbW1hbmRDb250cm9sbGVyfSBpcyB1c2VkIHRvIHNlbmQgY29tbWFuZHMgYW5kIGlucHV0IHRvIHRoZSBSQVZJIHNlcnZlci5cbiAgICogXG4gICAqIEByZXR1cm5zIHtSYXZpQ29tbWFuZENvbnRyb2xsZXJ9XG4gICAqL1xuICBnZXRDb21tYW5kQ29udHJvbGxlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tbWFuZENvbnRyb2xsZXI7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBSYXZpU3RyZWFtQ29udHJvbGxlciBmb3IgdXNlIHdpdGggdGhpcyBSYXZpU2Vzc2lvbi5cbiAgICogVGhlIHtsaW5rIFJhdmlTdHJlYW1Db250cm9sbGVyfSBpcyB1c2VkIHRvIHNlbmQgY29tbWFuZHMgYW5kIGlucHV0IHRvIHRoZSBSQVZJIHNlcnZlci5cbiAgICogXG4gICAqIEByZXR1cm5zIHtSYXZpU3RyZWFtQ29udHJvbGxlcn1cbiAgICovXG4gIGdldFN0cmVhbUNvbnRyb2xsZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmVhbUNvbnRyb2xsZXI7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBPcGVuIGEgUkFWSSBjb25uZWN0aW9uIHVzaW5nIHRoZSBwcm92aWRlZCBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbi4gUmV0dXJucyBhIFByb21pc2VcbiAgICogdGhhdCB3aWxsIHJlc29sdmUgd2l0aCB0aGUgY29ubmVjdGVkIHN0YXRlIG9uY2UgdGhlIFJhdmlTZXNzaW9uIGlzIGNvbm5lY3RlZC5cbiAgICogXG4gICAqIEBwYXJhbSB7UmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb259IHNpZ25hbGluZ0Nvbm5lY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgQSB0aW1vdXQgaW4gbXMgYWZ0ZXIgd2hpY2ggdG8gdGltZW91dCB0aGUgYXR0ZW1wdCB0byBjb25uZWN0LiBEZWZhdWx0cyB0byA1MDAwICg1IHNlY29uZHMpLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIEFuIG9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGFwcGxpZWQgdG8gdGhlIHNlcnZlciBzaWRlIG9mIHRoZSBzZXNzaW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCB2YWx1ZSBpcyBudWxsIGltcGx5aW5nIHRvIHJlbHkgb24gdGhlIGRlZmF1bHQgdmFsdWVzIGFzIGRlZmluZWQgb24gdGhlIHNlcnZlciBzaWRlLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIFN1cHBvcnRlZCBmaWVsZHMgYXJlOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIFwiYXVkaW9NaW5KaXR0ZXJCdWZmZXJEdXJhdGlvblwiOiA8bnVtYmVyPiAgd2l0aCB2YWxpZCB2YWx1ZXMgaW4gdGhlIHJhbmdlIDAuMHMgdG8gMTAuMHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICBcImF1ZGlvTWF4Sml0dGVyQnVmZmVyRHVyYXRpb25cIjogPG51bWJlcj4gIHdpdGggdmFsaWQgdmFsdWVzIGluIHRoZSByYW5nZSAwLjBzIHRvIDEwLjBzXG4gICAqICAgICAgICAgICAgXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgb3BlbihzaWduYWxpbmdDb25uZWN0aW9uOiBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbiwgdGltZW91dD01MDAwLCBwYXJhbXM6IGFueSA9IG51bGwpIHtcbiAgICB2YXIgcmF2aVNlc3Npb24gPSB0aGlzO1xuXG4gICAgLy8gVGVsbCBvdXIgY29ubmVjdGlvbiBpbXBsZW1lbnRhdGlvbiBhYm91dCB0aGlzIHNpZ25hbGluZyBjb25uZWN0aW9uIC0tXG4gICAgLy8gaXQgbWF5IG5lZWQgdG8gdGFsayB0byBpdCBkaXJlY3RseSB3aGlsZSBpdCdzIGF0dGVtcHRpbmcgdG8gbmVnb3RpYXRlXG4gICAgLy8gdGhlIGNvbm5lY3Rpb24uXG4gICAgdGhpcy5fcmF2aUltcGxlbWVudGF0aW9uLl9hc3NpZ25TaWduYWxpbmdDb25uZWN0aW9uKHNpZ25hbGluZ0Nvbm5lY3Rpb24pO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIFJhdmlVdGlscy5sb2coXCJPcGVuaW5nIFJBVkkgc2Vzc2lvblwiLCBcIlJhdmlTZXNzaW9uXCIpO1xuXG4gICAgICAvLyBTZXQgYSB0aW1lb3V0IGluIGNhc2UgdGhlIHNlc3Npb24gZ2V0cyBodW5nIHVwIGluIGluaXRpYWxpemF0aW9uXG4gICAgICBsZXQgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIlJhdmlTZXNzaW9uLm9wZW4gdGltZWQgb3V0IGFmdGVyIFwiICsgdGltZW91dCArIFwiIG1zXCIsIFwiUmF2aVNlc3Npb25cIik7XG4gICAgICAgIC8vIFJlamVjdCB0aGUgcHJvbWlzZSB3aXRoIGFuIGV4cGxpY2l0IGVycm9yIG1lc3NhZ2UuXG4gICAgICAgIHJlamVjdChFcnJvcihcIlJhdmlTZXNzaW9uLm9wZW4gdGltZWQgb3V0XCIpKTtcbiAgICAgICAgLy8gQ2xvc2UgdGhlIHNlc3Npb247IHRoaXMgc2hvdWxkIHRyaWdnZXIgdGhlIHN0YXRlIGNoYW5nZVxuICAgICAgICAvLyBoYW5kbGVyIHRvIGNsZWFuIHVwLiBUaGlzIHdvdWxkIGFsc28gcmVqZWN0IHRoZSBwcm9taXNlIGlmIHdlIGRpZG4ndCBkbyBzbyBleHBsaWNpdGx5IGFib3ZlLlxuICAgICAgICByYXZpU2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgfSwgdGltZW91dCk7XG4gICAgICBcbiAgICAgIC8vIEFkZCBhIHN0YXRlIGNoYW5nZSBoYW5kbGVyIHRoYXQgd2lsbCByZXNvbHZlIHRoZVxuICAgICAgLy8gcHJvbWlzZSBvbmNlIHRoZSBjb25uZWN0aW9uIGlzIG9wZW5cbiAgICAgIGNvbnN0IHN0YXRlSGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gXCJcIjtcbiAgICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50LnN0YXRlKSBzdGF0ZSA9IGV2ZW50LnN0YXRlO1xuXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gUmF2aVNlc3Npb25TdGF0ZXMuTkVXIHx8XG4gICAgICAgICAgICAgIHN0YXRlID09PSBSYXZpU2Vzc2lvblN0YXRlcy5DT05ORUNUSU5HIHx8XG4gICAgICAgICAgICAgIHN0YXRlID09PSBSYXZpU2Vzc2lvblN0YXRlcy5ESVNDT05ORUNURUQpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IFBlciBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUlRDUGVlckNvbm5lY3Rpb24jUlRDSWNlQ29ubmVjdGlvblN0YXRlX2VudW1cbiAgICAgICAgICAgIC8vIFwiZGlzY29ubmVjdGVkXCIgaXMgYSBwb3RlbnRpYWxseSB0cmFuc2llbnQgc3RhdGUsIHNvIGluIHRoaXMgY2FsbCB3ZSB3aWxsIHNpbXBseSB3YWl0IHVudGlsIHdlXG4gICAgICAgICAgICAvLyBnZXQgdG8gY29ubmVjdGVkLCBjb21wbGV0ZSwgb3IgZmFpbGVkLlxuICAgICAgICAgICAgUmF2aVV0aWxzLmxvZyhcIlJBVkkgc2Vzc2lvbiBzdGF0ZSBpcyBcIiArIHN0YXRlLCBcIlJhdmlTZXNzaW9uXCIpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IFJhdmlTZXNzaW9uU3RhdGVzLkNPTk5FQ1RFRCB8fFxuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID09PSBSYXZpU2Vzc2lvblN0YXRlcy5DT01QTEVURUQpIHtcbiAgICAgICAgICBjbGVhckhhbmRsZXJBbmRUaW1lb3V0KCk7XG4gICAgICAgICAgcmVzb2x2ZShzdGF0ZSk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gUmF2aVNlc3Npb25TdGF0ZXMuRkFJTEVEKSB7XG4gICAgICAgICAgY2xlYXJIYW5kbGVyQW5kVGltZW91dCgpO1xuICAgICAgICAgIC8vIEV4cGxpY2l0bHkgY2FsbCB0aGUgaW1wbGVtZW50YXRpb24ncyBcImNsb3NlXCIgbWV0aG9kIHRvIG1ha2VcbiAgICAgICAgICAvLyByZWFsbHksIHJlYWxseSBzdXJlIGl0J3MgY2xvc2VkIGluIGFkZGl0aW9uIHRvIGJlaW5nIFwiZmFpbGVkXCIuXG4gICAgICAgICAgLy8gVGhlc2UgYXJlIE5PVCB0aGUgc2FtZSBzdGF0ZSEgQSBcImZhaWxlZFwiIGNvbm5lY3Rpb24gbWF5IHN0aWxsIGJlXG4gICAgICAgICAgLy8gYXdhcmUgb2YgaXRzIHNpZ25hbGluZyBjb25uZWN0aW9uIGFuZCBvdGhlciBuaWNldGllcy5cbiAgICAgICAgICAvLyBLaWNrIG9mZiB0aGF0IGNsb3NlIGluIGEgdGltZW91dCB0byBnZXQgaXQgdG8gcnVuIGFzeW5jaHJvbm91c2x5XG4gICAgICAgICAgLy8gZnJvbSB0aGUgUHJvbWlzZSByZWplY3Rpb24uXG4gICAgICAgICAgY29uc3QgY2xvc2VUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcmF2aVNlc3Npb24uX3JhdmlJbXBsZW1lbnRhdGlvbi5fY2xvc2UoKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICByZWplY3QoRXJyb3Ioc3RhdGUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gUmF2aVNlc3Npb25TdGF0ZXMuQ0xPU0VEKSB7XG4gICAgICAgICAgY2xlYXJIYW5kbGVyQW5kVGltZW91dCgpO1xuICAgICAgICAgIHJlamVjdChFcnJvcihzdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBjbGVhckhhbmRsZXJBbmRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJhdmlTZXNzaW9uLnJlbW92ZVN0YXRlQ2hhbmdlSGFuZGxlcihzdGF0ZUhhbmRsZXIpO1xuICAgICAgICAgIC8vIENsZWFyIHRoZSB0aW1lclxuICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBpbXBsZW1lbnRhdGlvbiB3aWxsIHRyaWdnZXIgY29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2UgZXZlbnRzXG4gICAgICByYXZpU2Vzc2lvbi5hZGRTdGF0ZUNoYW5nZUhhbmRsZXIoc3RhdGVIYW5kbGVyKTtcblxuICAgICAgLy8gQW5kIGZpbmFsbHksIGNhbGwgdGhlIGltcGxlbWVudGF0aW9uJ3Mgb3BlbiBtZXRob2RcbiAgICAgIHJhdmlTZXNzaW9uLl9yYXZpSW1wbGVtZW50YXRpb24uX29wZW4ocGFyYW1zKTtcblxuICAgIH0pO1xuICB9XG4gIFxuICAvKipcbiAgICogQ2xvc2UgYSBSQVZJIGNvbm5lY3Rpb24sIGluY2x1ZGluZyBzaHV0dGluZyBkb3duIHRoZSBcbiAgICogcmVsZXZhbnQgUmF2aVN0cmVhbUNvbnRyb2xsZXIgYW5kIFJhdmlDb21tYW5kQ29udHJvbGxlci4gUmV0dXJucyBhIFByb21pc2VcbiAgICogdGhhdCB3aWxsIHJlc29sdmUgd2l0aCB0aGUgY2xvc2VkIHN0YXRlIG9uY2UgdGhlIFJhdmlTZXNzaW9uIGlzIGNsb3NlZC5cbiAgICogXG4gICAqIEBwYXJhbSB7UmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb259IHNpZ25hbGluZ0Nvbm5lY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICB2YXIgcmF2aVNlc3Npb24gPSB0aGlzO1xuICAgXG4gICAgLy8gU3RhcnQgYnkgY2xvc2luZyBvdXQgY29tbWFuZCBjb250cm9sbGVyXG4gICAgLy8gYW5kIHRoZSBzdHJlYW0gY29udHJvbGxlci5cbiAgICB0aGlzLl9zdHJlYW1Db250cm9sbGVyLl9zdG9wKCk7XG4gICAgdGhpcy5fY29tbWFuZENvbnRyb2xsZXIuc3RvcE1vbml0b3JpbmdRdWV1ZXMoKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBSYXZpVXRpbHMubG9nKFwiQ2xvc2luZyBSQVZJIHNlc3Npb25cIiwgXCJSYXZpU2Vzc2lvblwiKTtcbiAgICAgIC8vIEFkZCBhIHN0YXRlIGNoYW5nZSBoYW5kbGVyIHRoYXQgd2lsbCByZXNvbHZlIHRoZVxuICAgICAgLy8gcHJvbWlzZSBvbmNlIHRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZFxuICAgICAgY29uc3Qgc3RhdGVIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQ6IGFueSkge1xuICAgICAgICB2YXIgc3RhdGUgPSBcIlwiO1xuICAgICAgICBpZiAoZXZlbnQgJiYgZXZlbnQuc3RhdGUpIHN0YXRlID0gZXZlbnQuc3RhdGU7XG5cbiAgICAgICAgaWYgKHN0YXRlID09PSBSYXZpU2Vzc2lvblN0YXRlcy5ESVNDT05ORUNURUQpIHtcbiAgICAgICAgICBSYXZpVXRpbHMubG9nKFwiQ2xvc2luZy4uLlwiLCBcIlJhdmlTZXNzaW9uXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBSYXZpU2Vzc2lvblN0YXRlcy5DTE9TRUQpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgdGhpcyBhcyBhIHN0YXRlIGNoYW5nZSBoYW5kbGVyXG4gICAgICAgICAgcmF2aVNlc3Npb24ucmVtb3ZlU3RhdGVDaGFuZ2VIYW5kbGVyKHN0YXRlSGFuZGxlcik7XG4gICAgICAgICAgLy8gYW5kIHJlc29sdmUgdGhlIFByb21pc2VcbiAgICAgICAgICByZXNvbHZlKHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZW1vdmUgdGhpcyBhcyBhIHN0YXRlIGNoYW5nZSBoYW5kbGVyXG4gICAgICAgICAgcmF2aVNlc3Npb24ucmVtb3ZlU3RhdGVDaGFuZ2VIYW5kbGVyKHN0YXRlSGFuZGxlcik7XG4gICAgICAgICAgLy8gYW5kIHJlamVjdCB0aGUgUHJvbWlzZVxuICAgICAgICAgIHJlamVjdChFcnJvcihzdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmF2aVNlc3Npb24uYWRkU3RhdGVDaGFuZ2VIYW5kbGVyKHN0YXRlSGFuZGxlcik7XG5cbiAgICAgIC8vIEFuZCB0aGVuIGFsZXJ0IGFib3V0IHRoZSBcImNsb3NpbmdcIiBwcm9jZXNzXG4gICAgICB2YXIgZXZlbnQgPSB7XCJzdGF0ZVwiOlJhdmlTZXNzaW9uU3RhdGVzLkRJU0NPTk5FQ1RFRH07XG4gICAgICByYXZpU2Vzc2lvbi5faGFuZGxlU3RhdGVDaGFuZ2UoZXZlbnQsIFJhdmlTZXNzaW9uU3RhdGVzLkRJU0NPTk5FQ1RFRCk7IFxuICAgICAgLy8gQW5kIGZpbmFsbHksIGNhbGwgdGhlIGltcGxlbWVudGF0aW9uJ3MgY2xvc2UgbWV0aG9kXG4gICAgICByYXZpU2Vzc2lvbi5fcmF2aUltcGxlbWVudGF0aW9uLl9jbG9zZSgpO1xuXG4gICAgfSk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBIYW5kbGVyIGZvciB3aGVuZXZlciBhIG5ldyBcInRyYWNrIGNoYW5uZWxcIiBzaG93cyB1cC4gKFdoZW4gdGhpcyBldmVudCBoYXBwZW5zXG4gICAqIHNob3VsZCBiZSBkZXRlcm1pbmVkIGJ5IHRoZSBpbXBsZW1lbnRhdGlvbiwgYW5kIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0cmFjayBzaG91bGQgYmUgXG4gICAqIHN0b3JlZCBpbiB0aGUgcGFzc2VkIGV2ZW50IG9iamVjdC4pXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZG9PbnRyYWNrKGV2ZW50OiBhbnkpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGNvZGUgaXMgd29ya2luZyBpZiB3ZSBoYXZlIG9ubHkgb25lIG1lZGlhIHRyYWNrICh2aWRlbyBPUiBhdWRpbyksIG5vdCBzdXJlIGl0IHdvcmtzIHdpdGggbW9yZVxuICAgIC8vIE5lZWQgdG9vIG1ha2UgaXQgbW9yZSByb2J1c3Qgd2l0aCBkaWZmZXJlbnQgYnJhbmNoZXMgYmFzZWQgb24gdGhlIGV2ZW50IGluZm9cbiAgICBSYXZpVXRpbHMubG9nKFwiUmVjZWl2ZWQgbmV3IHRyYWNrOiBcIiwgXCJSYXZpU2Vzc2lvblwiKTtcbiAgICBSYXZpVXRpbHMubG9nKGV2ZW50LCBcIlJhdmlTZXNzaW9uXCIpO1xuXG4gICAgaWYgKGV2ZW50ICYmIGV2ZW50LnRyYWNrICYmIGV2ZW50LnRyYWNrLmtpbmQgPT09IFwidmlkZW9cIikgeyBcbiAgICAgIFJhdmlVdGlscy5sb2coXCJBZGRpbmcgcmVtb3RlIHZpZGVvIHRyYWNrIHRvIHN0cmVhbSBjb250cm9sbGVyXCIsIFwiUmF2aVNlc3Npb25cIik7XG4gICAgICB0aGlzLl9zdHJlYW1Db250cm9sbGVyLl9zZXRWaWRlb1N0cmVhbShldmVudC5zdHJlYW1zWzBdKTtcbiAgICAgIHRoaXMuX3N0cmVhbUNvbnRyb2xsZXIuX29uVmlkZW9TdHJlYW1TdGF0ZUNoYW5nZWQoXCJyZWFkeVwiKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGV2ZW50ICYmIGV2ZW50LnRyYWNrICYmIGV2ZW50LnRyYWNrLmtpbmQgPT09IFwiYXVkaW9cIikge1xuICAgICAgUmF2aVV0aWxzLmxvZyhcIkFkZGluZyByZW1vdGUgYXVkaW8gdHJhY2sgdG8gc3RyZWFtIGNvbnRyb2xsZXJcIiwgXCJSYXZpU2Vzc2lvblwiKTtcbiAgICAgIHRoaXMuX3N0cmVhbUNvbnRyb2xsZXIuX3NldEF1ZGlvU3RyZWFtKGV2ZW50LnN0cmVhbXNbMF0pO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEhhbmRsZXIgZm9yIHdoZW5ldmVyIGEgbmV3IFwiZGF0YSBjaGFubmVsXCIgc2hvd3MgdXAuIChXaGVuIHRoaXMgZXZlbnQgaGFwcGVucyBzaG91bGQgYmUgZGV0ZXJtaW5lZFxuICAgKiBieSB0aGUgaW1wbGVtZW50YXRpb24sIGFuZCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2hhbm5lbCBzaG91bGQgYmUgc3RvcmVkIGluIHRoZSBwYXNzZWQgZXZlbnQgb2JqZWN0LilcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kb09uZGF0YWNoYW5uZWwoZXZlbnQ6IGFueSkge1xuICAgIFJhdmlVdGlscy5sb2coXCJSZWNlaXZlZCBuZXcgY2hhbm5lbDogXCIsIFwiUmF2aVNlc3Npb25cIik7XG4gICAgUmF2aVV0aWxzLmxvZyhldmVudCwgXCJSYXZpU2Vzc2lvblwiKTtcbiAgICBcbiAgICBzd2l0Y2ggKGV2ZW50LmNoYW5uZWwubGFiZWwpIHtcbiAgICAgIGNhc2UgXCJyYXZpLmlucHV0XCI6XG4gICAgICAgIHRoaXMuX2NvbW1hbmRDb250cm9sbGVyLl9zZXRJbnB1dERhdGFDaGFubmVsKGV2ZW50LmNoYW5uZWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJyYXZpLmNvbW1hbmRcIjpcbiAgICAgICAgdGhpcy5fY29tbWFuZENvbnRyb2xsZXIuX3NldENvbW1hbmREYXRhQ2hhbm5lbChldmVudC5jaGFubmVsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBSYXZpVXRpbHMubG9nKFwiUmVjZWl2ZWQgdW5rbm93biBkYXRhIGNoYW5uZWwgbmFtZWQgXCIgKyBldmVudC5jaGFubmVsLmxhYmVsLCBcIlJhdmlTZXNzaW9uXCIpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvKiogXG4gICAqIEdlbmVyaWMgaGFuZGxlciBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGVTdGF0ZUNoYW5nZShldmVudDogYW55LCBzdGF0ZTogYW55KSB7XG4gICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50W1wic3RhdGVcIl0gPSBzdGF0ZTtcbiAgICBSYXZpVXRpbHMubG9nKFwiX2hhbmRsZVN0YXRlQ2hhbmdlOiBcIiArIEpTT04uc3RyaW5naWZ5KGV2ZW50KSwgXCJSYXZpU2Vzc2lvblwiKTtcbiAgICB0aGlzLl9zdGF0ZUNoYW5nZUhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgaGFuZGxlcihldmVudCk7IFxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgIC8qKlxuICAgKiBDYWxsYmFjayBmb3IgbGlzdGVuaW5nIHRvIHN0YXRzXG4gICAqIEBjYWxsYmFjayBSYXZpU2Vzc2lvbn5zdGF0c09ic2VydmVyQ2FsbGJhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRzIEFuIG9iamVjdCB0aGF0IHdpbGwgY29udGFpbiBpbmZvcm1hdGlvblxuICAgKiBhYm91dCB0aGUgc3RhdHMgcmVjb3JkZWRcbiAgICovXG4gIC8qKlxuICAgKiBBZGQgYSBoYW5kbGVyIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGxpc3RlbiBmb3IgbmV3IHN0YXRzIGdlbmVyYXRlZC5cbiAgICogVGhlc2UgYXJlIHN0b3JlZCBpbiBhIFNldCBvZiBGdW5jdGlvbnM7IHRoZXJlZm9yZSwgYSBnaXZlbiBmdW5jdGlvblxuICAgKiBjYW4gb25seSBleGlzdCBvbmNlIGluIHRoaXMgU2V0LlxuICAgKiBcbiAgICogQHBhcmFtIHtSYXZpU2Vzc2lvbn5zdGF0c09ic2VydmVyQ2FsbGJhY2t9IGhhbmRsZXIgQSBjYWxsYmFjayBoYW5kbGVyIHRoYXQgc2hvdWxkIGhhbmRsZSBhIHN0YXRlIGNoYW5nZSBldmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGFkZCBzdWNjZWVkZWRcbiAgICovXG4gIGFkZFN0YXRzT2JzZXJ2ZXIob2JzZXJ2ZXI6IEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JhdmlJbXBsZW1lbnRhdGlvbi5fYWRkU3RhdHNPYnNlcnZlcihvYnNlcnZlcik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgaGFuZGxlciBzbyB0aGF0IGl0IHN0b3BzIGxpc3RlbmluZyBmb3Igc3RhdHMgdXBkYXRlcy5cbiAgICogXG4gICAqIEBwYXJhbSB7UmF2aVNlc3Npb25+c3RhdHNPYnNlcnZlckNhbGxiYWNrfSBoYW5kbGVyIEEgY2FsbGJhY2sgaGFuZGxlciB0aGF0IHNob3VsZCBoYW5kbGUgYSBzdGF0ZSBjaGFuZ2UgZXZlbnRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSByZW1vdmFsIHdhcyBzdWNjZXNzZnVsIChpLmUuIGRpZCBub3QgdGhyb3cgYW4gZXJyb3IgLS0gbm90ZSB0aGF0IHRoaXMgZG9lc1xuICAgKiBOT1QgaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhlIGhhbmRsZXIgd2FzIGluIHRoZSBzZXQgaW4gdGhlIGZpcnN0IHBsYWNlKVxuICAgKi9cbiAgcmVtb3ZlU3RhdHNPYnNlcnZlcihvYnNlcnZlcjogRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fcmF2aUltcGxlbWVudGF0aW9uLl9yZW1vdmVTdGF0c09ic2VydmVyKG9ic2VydmVyKTtcbiAgfVxuICBcbn0gLy8gRW5kIG9mIHRoZSBSYXZpU2Vzc2lvbiBjbGFzc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4gLyoqXG4gKiBDb25zdGFudHMgdXNlZCBhcyB0aGUgZGVmYXVsdCBmaWx0ZXIgZm9yIHRoZSBzdGF0cyBjb2xsZWN0ZWQgaW4gdGhlIFJhdmlTdGF0c1dhdGNoZXJcbiAqL1xuY29uc3QgU1RBVFNfV0FUQ0hFUl9GSUxURVIgPSBuZXcgTWFwKFtcbiAgW1wicmVtb3RlLWluYm91bmQtcnRwXCIsIFtcImlkXCIsIFwidHlwZVwiLCBcInRpbWVzdGFtcFwiLCBcInJvdW5kVHJpcFRpbWVcIiwgXCJqaXR0ZXJcIl0gXSxcbiAgW1wiaW5ib3VuZC1ydHBcIiwgW1wiaWRcIiwgXCJ0eXBlXCIsIFwidGltZXN0YW1wXCIsIFwiaml0dGVyQnVmZmVyRGVsYXlcIiwgXCJqaXR0ZXJCdWZmZXJFbWl0dGVkQ291bnRcIiwgXCJieXRlc1JlY2VpdmVkXCJdXVxuXSk7XG5cbi8qKlxuICogU3RhdHNXYXRjaGVyIGlzIHRoZSBvYmplY3QgcmVzcG9uc2libGUgZm9yIGNhbGxpbmcgZ2V0U3RhdHMgZnJvbSB0aGVcbiAqIFJUQ1BlZXJDb25uZWN0aW9uIGF0IHJlZ3VsYXIgaW50ZXJ2YWxzLlxuICogVGhlIGNhcHR1cmVkIG1ldHJpY3MgYXJlIGZpbHRlcmVkIGFuZCBwYXNzZWQgb24gdG8gdGhlIHN0YXRzT2JzZXJ2ZXIocykuXG4gKiBUaGUgZmlsdGVyIGlzIGEgZGljdGlvbmFyeSBvZiB0aGUgcmVwb3J0IHR5cGUgYW5kIGZpZWxkcy5cbiAqIEN1cnJlbnQgZGVmYXVsdCB2YWx1ZSBpcyBkZWZpbmVkIGluIFNUQVRTX1dBVENIRVJfRklMVEVSLlxuICogU3RhdHNPYnNlcnZlciBpcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgMiBwYXJhbWV0ZXJzLCB0aGUgY3VycmVudCByZWNvcmQgYW5kIHRoZSBwcmV2aW91cyByZWNvcmQuXG4gKiBTZXZlcmFsIFN0YXRzT2JzZXJ2ZXIgY2FsbGJhY2tzIGNhbiBiZSBhZGRlZC9yZW1vdmVkIGJ5IHVzZXIgY29kZSB0aHJvdWdoIHRoZSBjb3JyZXNwb25kaW5nIG1ldGhvZHMgb2YgdGhlIG9iamVjdC5cbiAqIHRoZXNlIG1ldGhvZHMgYXJlIGV4cG9zZWQgcHVibGljYWxseSBvbiB0aGUgUmF2aVNlc3Npb24uXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBSYXZpV2ViUlRDU3RhdHNXYXRjaGVyIHtcbiAgX3JhdmlJbXBsZW1lbnRhdGlvbjogUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uO1xuICBfb2JzZXJ2ZXJzOiBTZXQ8RnVuY3Rpb24+O1xuICBfZmlsdGVyOiBNYXA8c3RyaW5nLCBBcnJheTxhbnk+PjtcbiAgX2ludGVydmFsOiBudW1iZXI7XG4gIF9wcmV2U3RhdHM6IEFycmF5PGFueT47XG5cbiAgXG4gIC8qKlxuICAgKiBcIkNsYXNzXCIgdmFyaWFibGVzIHRvIGJlIGF3YXJlIG9mOlxuICAgKiB0aGlzLl9vYnNlcnZlcnMgaXMgdGhlIHNldCBvZiBvYnNlcnZlciBjYWxsYmFja3MgcmVnaXN0ZXJlZCBieSB1c2VyIGNvZGVcbiAgICogdGhpcy5faW50ZXJ2YWwgaXMgdGhlIGludGVydmFsIHRpY2tpbmcgdGhlIGdldFN0YXRzIGNhbGxcbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBSYXZpU3RhdHNXYXRjaGVyXG4gICAqIEBwYXJhbSB7UmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9ufSB3ZWJSVENJbXBsZW1lbnRhdGlvbiBUaGUgUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uIGJlaW5nIHdhdGNoZWRcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3ZWJSVENJbXBsZW1lbnRhdGlvbjogUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uKSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcImNvbnN0cnVjdG9yXCIsIFwiUmF2aVN0YXRzV2F0Y2hlclwiKTtcbiAgICB0aGlzLl9yYXZpSW1wbGVtZW50YXRpb24gPSB3ZWJSVENJbXBsZW1lbnRhdGlvbjtcbiAgICB0aGlzLl9vYnNlcnZlcnMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5fZmlsdGVyID0gU1RBVFNfV0FUQ0hFUl9GSUxURVI7XG4gICAgdGhpcy5faW50ZXJ2YWwgPSAwO1xuICAgIHRoaXMuX3ByZXZTdGF0cyA9IFtdOyBcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyB0aGUgd2F0Y2hlclxuICAgKi9cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5faW50ZXJ2YWwpIHtcbiAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKTtcbiAgICAgIHRoaXMuX2ludGVydmFsID0gMDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFuIG9ic2VydmVyIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGxpc3RlbiBmb3IgbmV3IHN0YXRzIGdlbmVyYXRlZC5cbiAgICogVGhlc2UgYXJlIHN0b3JlZCBpbiBhIFNldCBvZiBGdW5jdGlvbnM7IHRoZXJlZm9yZSwgYSBnaXZlbiBmdW5jdGlvblxuICAgKiBjYW4gb25seSBleGlzdCBvbmNlIGluIHRoaXMgU2V0LlxuICAgKiBcbiAgICogc3RhdHNPYnNlcnZlckNhbGxiYWNrIGZ1bmN0aW9uIHJlY2VpdmVzIDIgcGFyYW1ldGVycywgdGhlIGN1cnJlbnQgcmVjb3JkIGFuZCB0aGUgcHJldmlvdXMgcmVjb3JkLlxuICAgKiBmdW5jdGlvbihuZXdTdGF0cywgcHJldlN0YXRzKVxuICAgKiB0aGUgU3RhdHMgcGFyYW1ldGVyIGlzIGFuIEFycmF5IG9mIG9iamVjdHMsIGEgZmlsdGVyZWQgZG93biB2ZXJzaW9uIG9mIHRoZSBkaWN0aW9ubmFyaWVzIHJldHVybmVkIGJ5IFxuICAgKiBSVENQZWVyQ29ubmVjdGlvbi5nZXRTdGF0c1xuICAgKiBcbiAgICogQHBhcmFtIHtSYXZpU3RhdHNXYXRjaGVyfnN0YXRzT2JzZXJ2ZXJDYWxsYmFja30gb2JzZXJ2ZXIgQSBjYWxsYmFjayB3aGljaCB3aWxsIHJlY2VpdmUgdGhlIHN0YXRzIHNhbXBsZXNcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBhZGQgc3VjY2VlZGVkXG4gICAqL1xuICBhZGRPYnNlcnZlcihvYnNlcnZlcjogRnVuY3Rpb24pIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5fb2JzZXJ2ZXJzLmFkZChvYnNlcnZlcik7XG4gICAgICB0aGlzLl9vbk9ic2VydmVyQ2hhbmdlKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIFJhdmlVdGlscy5lcnIoXCJFcnJvciBhZGRpbmcgYSBzdGF0cyBvYnNlcnZlcjogXCIgK1xuICAgICAgICBlcnIubWVzc2FnZSwgXCJSYXZpU3RhdHNXYXRjaGVyXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIG9ic2VydmVyIHNvIHRoYXQgaXQgc3RvcHMgbGlzdGVuaW5nIGZvciBzdGF0cyB1cGRhdGVzLlxuICAgKiBcbiAgICogQHBhcmFtIHtSYXZpU2Vzc2lvbn5zdGF0c09ic2VydmVyQ2FsbGJhY2t9IG9ic2VydmVyIEEgY2FsbGJhY2sgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBzZXRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSByZW1vdmFsIHdhcyBzdWNjZXNzZnVsIChpLmUuIGRpZCBub3QgdGhyb3cgYW4gZXJyb3IgLS0gbm90ZSB0aGF0IHRoaXMgZG9lc1xuICAgKiBOT1QgaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhlIGhhbmRsZXIgd2FzIGluIHRoZSBzZXQgaW4gdGhlIGZpcnN0IHBsYWNlKVxuICAgKi9cbiAgcmVtb3ZlT2JzZXJ2ZXIob2JzZXJ2ZXI6IEZ1bmN0aW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX29ic2VydmVycy5kZWxldGUob2JzZXJ2ZXIpO1xuICAgICAgdGhpcy5fb25PYnNlcnZlckNoYW5nZSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBSYXZpVXRpbHMuZXJyKFwiRXJyb3IgcmVtb3ZpbmcgYSBzdGF0cyBvYnNlcnZlciBoYW5kbGVyOiBcIiArXG4gICAgICAgIGVyci5tZXNzYWdlLCBcIlJhdmlTZXNzaW9uXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBcbiAgLy8gV2hlbmV2ZXIgb2JzZXJ2ZXIocykgYXJlIGFkZGVkIG9yIHJlbW92ZSxcbiAgLy8gbGV0J3MgbWFrZSBzdXJlIHRoZSB3YXRjaGVyIGlzIHJ1bm5pbmcgaWYgdGhlcmUgaXMgYW55IG9ic2VydmVyLlxuICAvLyBhbmQgbGV0J3MgdHVybiBvZmYgdGhlIGNvbGxlY3Rpb24gb2Ygc3RhdHMgaWYgdGhlIHNldCBvZiBvYnNlcnZlcnMgaXMgZW1wdHkuXG4gIF9vbk9ic2VydmVyQ2hhbmdlKCkge1xuICAgIGNvbnN0IElOVEVSVkFMID0gMTAwMDtcblxuICAgIHRoaXMuX3ByZXZTdGF0cyA9IFtdO1xuICAgIC8vIHNvbWUgb2JzZXJ2ZXJzLCB0aGVuIG1ha2Ugc3VyZSB3ZSBydW5cbiAgICBpZiAodGhpcy5fb2JzZXJ2ZXJzLnNpemUgPiAwKSB7XG4gICAgICBpZiAoIXRoaXMuX2ludGVydmFsKSB7XG4gICAgICAgIHdpbmRvdy5zZXRJbnRlcnZhbChhc3luYyAoaGFuZGxlcjogYW55LCB0aW1lb3V0OiBhbnkpID0+IHsgXG4gICAgICAgICAgY29uc3Qgc3RhdHMgPSBhd2FpdCB0aGlzLl9yYXZpSW1wbGVtZW50YXRpb24uX2dldFN0YXRzKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgbGV0IGZpbHRlcmVkU3RhdHM6YW55ID0gW107XG4gICAgICAgICAgaWYgKHN0YXRzKSB7XG4gICAgICAgICAgICBzdGF0cy5mb3JFYWNoKChyZXBvcnQ6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAvLyBGaWx0ZXIgb24gdGhlIHJlcG9ydCB0eXBlXG4gICAgICAgICAgICAgIGlmICh0aGlzLl9maWx0ZXIuaGFzKHJlcG9ydC50eXBlKSkge1xuICAgICAgICAgICAgICAgIC8vIHNlbGVjdGVkIGZpZWxkcyBtdXN0IGJlIGEgdmFsaWQgYXJyYXkgb2YgZmllbGRzOlxuICAgICAgICAgICAgICAgIGxldCBzZWxlY3RlZEZpZWxkcyA9IHRoaXMuX2ZpbHRlci5nZXQocmVwb3J0LnR5cGUpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFRoZW4gd2l0aGluIHRoZSByZXBvcnQgdHlwZSwgcGljayBvbiB0aGUgd2FudGVkIGZpZWxkc1xuICAgICAgICAgICAgICAgIGxldCBmaWx0ZXJlZFJlcG9ydDogYW55ID0ge307XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRGaWVsZHMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZFJlcG9ydFtrZXldID0gcmVwb3J0W2tleV07XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGZpbHRlcmVkIHJlcG9ydCBmb3VuZCBpbiB0aGUgcmVzdWx0IHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIGZpbHRlcmVkU3RhdHMucHVzaChmaWx0ZXJlZFJlcG9ydCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTdGF0cyBoYXZlIGJlZW4gY29sbGVjdGVkLCBub3cgbGV0J3MgYnJvYWRjYXN0XG4gICAgICAgICAgaWYgKGZpbHRlcmVkU3RhdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9vYnNlcnZlcnMuZm9yRWFjaCAoKG9ic2VydmVyKT0+e1xuICAgICAgICAgICAgICBvYnNlcnZlcihmaWx0ZXJlZFN0YXRzLCB0aGlzLl9wcmV2U3RhdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcmVjb3JkIHRoZSBwcm9kdWNlZCBzdGF0cyBhcyB0aGUgbW9zdCByZWNlbnQgb25lXG4gICAgICAgICAgdGhpcy5fcHJldlN0YXRzID0gZmlsdGVyZWRTdGF0cztcbiAgICAgICAgfSwgSU5URVJWQUwgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm8gb2JzZXJ2ZXJzLCBtYWtlIHN1cmUgd2UgYXJlIHN0b3BwZWRcbiAgICAgIGlmICh0aGlzLl9pbnRlcnZhbCkge1xuICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCk7XG4gICAgICAgIHRoaXMuX2ludGVydmFsID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbi8qXG5UT0RPOiBBZGQgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBhIFJBVkkgUGVlciBDb25uZWN0aW9uIFwiY29ubmVjdGlvbiBpbXBsZW1lbnRhdGlvblwiXG5jbGFzcyBzaG91bGQgbG9vayBsaWtlLiBTb21lIGluaXRpYWwgbm90ZXM6XG5Db25zdHJ1Y3RvcjogVGFrZXMgaW4gYSBSYXZpU2Vzc2lvbiBzbyB0aGF0IGl0IGNhbiB1c2UgaXRzIGhhbmRsZXJzLiBUaGUgaW1wbGVtZW50YXRpb24gY2xhc3NcbmlzIGV4cGVjdGVkIHRvIGFzc2lnbiB0aGUgUmF2aVNlc3Npb24ncyBfaGFuZGxlU3RhdGVDaGFuZ2UoZXZlbnQsIHN0YXRlKSBcbmhhbmRsZXIgdG8gYW55IGFwcHJvcHJpYXRlIGV2ZW50cyB0aHJvd24gYnkgaXRzIGltcGxlbWVudGF0aW9uIFxuKGFuZC9vciB0aHJvd24gYnkgaXRzZWxmKS5cblNpbWlsYXJseSwgaXQgaXMgZXhwZWN0ZWQgdG8gY2FsbCB0aGUgcGFyZW50J3MgX2RvT25kYXRhY2hhbm5lbCBhbmQgX2RvT250cmFja1xubWV0aG9kcyB3aGVuIGl0IGhhcyBkYXRhIGNoYW5uZWwgYW5kIHRyYWNrIGNoYW5uZWxzIHJlYWR5LlxuICBFeHBlY3RlZCBtZXRob2RzOlxuICBjb25zdHJ1Y3RvcihyYXZpU2Vzc2lvbik7XG4gIF9hc3NpZ25TaWduYWxpbmdDb25uZWN0aW9uKCk7XG4gIF9hZGRBdWRpb0lucHV0U3RyZWFtKGlucHV0U3RyZWFtKTtcbiAgX2FkZFZpZGVvSW5wdXRTdHJlYW0oaW5wdXRTdHJlYW0pO1xuICBfb3BlbigpOyBcbiAgX2Nsb3NlKCk7XG4qL1xuXG4vKipcbiAqIFVzZSB0aGUgY29ycmVjdCBjbGFzc2VzIGRlcGVuZGluZyBvbiB3aGV0aGVyIHdlJ3JlIGJlaW5nIFxuICogY2FsbGVkIGZyb20gbm9kZSBvciB0aGUgYnJvd3Nlci5cbiAqL1xubGV0IGNyb3NzUGxhdGZvcm1SVENQZWVyQ29ubmVjdGlvbjphbnkgPSBudWxsO1xubGV0IGNyb3NzUGxhdGZvcm1SVENTZXNzaW9uRGVzY3JpcHRpb246YW55ID0gbnVsbDtcbmlmICh0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gbm9kZSBjb250ZXh0XG4gIGNyb3NzUGxhdGZvcm1SVENQZWVyQ29ubmVjdGlvbiA9IHJlcXVpcmUoJ3dydGMnKS5SVENQZWVyQ29ubmVjdGlvbjtcbiAgY3Jvc3NQbGF0Zm9ybVJUQ1Nlc3Npb25EZXNjcmlwdGlvbiA9IHJlcXVpcmUoJ3dydGMnKS5SVENTZXNzaW9uRGVzY3JpcHRpb247XG59IGVsc2Uge1xuICAvLyBicm93c2VyIGNvbnRleHRcbiAgY3Jvc3NQbGF0Zm9ybVJUQ1BlZXJDb25uZWN0aW9uID0gUlRDUGVlckNvbm5lY3Rpb247XG4gIGNyb3NzUGxhdGZvcm1SVENTZXNzaW9uRGVzY3JpcHRpb24gPSBSVENTZXNzaW9uRGVzY3JpcHRpb247XG59XG5cbi8qKlxuICogQ29uc3RhbnRzIHVzZWQgZHVyaW5nIHNlc3Npb24gbmVnb3RpYXRpb25cbiAqL1xuY29uc3QgcGVlckNvbm5lY3Rpb25Db25maWcgPSB7XG4gICdpY2VTZXJ2ZXJzJzogW1xuICAgIHsndXJscyc6ICdzdHVuOnN0dW4ubC5nb29nbGUuY29tOjE5MzAyJ30sXG4gICAgeyd1cmxzJzogJ3R1cm46dHVybi5oaWdoZmlkZWxpdHkuY29tOjM0NzgnLFxuICAgICAgJ3VzZXJuYW1lJzogJ2Nsb3VkdXNlcicsXG4gICAgICAnY3JlZGVudGlhbCc6ICdjaGFyaW90LXRyYXZlc3R5LWhvb2snXG4gICAgfVxuICBdXG59O1xuXG4vKiogXG4gKiBBIFdlYlJUQyBpbXBsZW1lbnRhdGlvbiBmb3IgYSBSQVZJIHBlZXIgY29ubmVjdGlvblxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uIHtcbiAgX3JhdmlTZXNzaW9uOiBSYXZpU2Vzc2lvbjtcbiAgX25lZ290aWF0b3I6IGFueTtcbiAgX3N0YXRzV2F0Y2hlcjogUmF2aVdlYlJUQ1N0YXRzV2F0Y2hlcjtcbiAgX3J0Y0Nvbm5lY3Rpb246IHR5cGVvZiBjcm9zc1BsYXRmb3JtUlRDUGVlckNvbm5lY3Rpb247XG4gIF9yYXZpQXVkaW9TZW5kZXJzOiBhbnk7XG4gIF9yYXZpVmlkZW9TZW5kZXJzOiBhbnk7XG4gIF9zaWduYWxpbmdDb25uZWN0aW9uOiBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbjtcbiAgXG4gIC8qKlxuICAgKiBcIkNsYXNzXCIgdmFyaWFibGVzIHRvIGJlIGF3YXJlIG9mOlxuICAgKiB0aGlzLl9ydGNDb25uZWN0aW9uICAgICAgIC8vIFRoZSBhY3R1YWwgUlRDUGVlckNvbm5lY3Rpb25cbiAgICogdGhpcy5fcmF2aVNlc3Npb24gICAgICAgICAvLyBUaGUgXCJvd25pbmdcIiBSYXZpU2Vzc2lvblxuICAgKiB0aGlzLl9zaWduYWxpbmdDb25uZWN0aW9uIC8vIEEgUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB3aGVuIG5lZ290aWF0aW5nIHRoZSBzZXNzaW9uXG4gICAqIHRoaXMuX25lZ290aWF0b3IgICAgICAgICAgLy8gQSBib3VuZCB2ZXJzaW9uIG9mIHRoZSBjb25uZWN0aW9uIHNldHVwIG1ldGhvZCB0aGF0IGNhbiBiZSB1c2VkIGZvciBtZXNzYWdlIGhhbmRsaW5nXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXG4gICAqIEBwYXJhbSB7UmF2aVNlc3Npb259IHJhdmlTZXNzaW9uIFRoZSBvd25lciBvZiB0aGlzIFJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJhdmlTZXNzaW9uOiBSYXZpU2Vzc2lvbikge1xuICAgIFJhdmlVdGlscy5sb2coXCJjb25zdHJ1Y3RvclwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICB0aGlzLl9yYXZpU2Vzc2lvbiA9IHJhdmlTZXNzaW9uO1xuICAgIHRoaXMuX25lZ290aWF0b3IgPSB0aGlzLl9zZXR1cENvbm5lY3Rpb24uYmluZCh0aGlzKTtcbiAgICB0aGlzLl9pbml0UnRjQ29ubmVjdGlvbigpO1xuICAgIHRoaXMuX3N0YXRzV2F0Y2hlciA9IG5ldyBSYXZpV2ViUlRDU3RhdHNXYXRjaGVyKHRoaXMpO1xuICB9XG4gIFxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgUlRDIGNvbm5lY3Rpb24gdG8gYSBuZXcgZnJlc2ggb25lLiBUaGlzIHNob3VsZCBiZSBjYWxsZWRcbiAgICogYmVmb3JlIGF0dGVtcHRpbmcgdG8gb3BlbiB0aGUgY29ubmVjdGlvbi4gQnV0IHNpbmNlIGl0J3MgbmljZSB0byBoYXZlIHRoZXNlXG4gICAqIGhhbmRsZXJzIGF0dGFjaGVkIGFzIGVhcmx5IGFzIHBvc3NpYmxlLCB3ZSBhY3R1YWxseSBjYWxsIHRoaXMgcmlnaHQgYXdheSBpbiB0aGUgY29uc3RydWN0b3JcbiAgICogYW5kIHRoZW4gYWdhaW4gd2hlbiBhIGNvbm5lY3Rpb24gaXMgY2xvc2VkICh0byByZWluaXRpYWxpemUpLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRSdGNDb25uZWN0aW9uKCkge1xuICAgIGNvbnN0IHJhdmlTZXNzaW9uID0gdGhpcy5fcmF2aVNlc3Npb247XG4gICAgY29uc3QgdGhhdCA9IHRoaXM7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgbmV3IFJUQyBjb25uZWN0aW9uIChmb3Igbm9kZSBvciB0aGUgYnJvd3NlcilcbiAgICB0aGlzLl9ydGNDb25uZWN0aW9uID0gbmV3IGNyb3NzUGxhdGZvcm1SVENQZWVyQ29ubmVjdGlvbihwZWVyQ29ubmVjdGlvbkNvbmZpZyk7XG4gICAgY29uc3QgcnRjQ29ubmVjdGlvbiA9IHRoaXMuX3J0Y0Nvbm5lY3Rpb247XG4gICAgXG4gICAgLy8gQ2xlYXIgb3V0IGFueSBvbGQgdHJhY2sgc2VuZGVyc1xuICAgIGxldCBzZW5kZXJzID0gcnRjQ29ubmVjdGlvbi5nZXRTZW5kZXJzKCk7XG4gICAgc2VuZGVycy5mb3JFYWNoKChzZW5kZXI6IGFueSkgPT4ge1xuICAgICAgc2VuZGVyLnJlcGxhY2VUcmFjayhudWxsKTtcbiAgICB9KTtcbiAgICB0aGlzLl9yYXZpQXVkaW9TZW5kZXJzID0gW107XG4gICAgdGhpcy5fcmF2aVZpZGVvU2VuZGVycyA9IFtdO1xuICAgIFxuICAgIC8vIFRoaXMgbmV3IFJUQ0Nvbm5lY3Rpb24ncyBzdGF0ZSBjaGFuZ2UgZXZlbnRzIHdpbGwganVzdFxuICAgIC8vIGNhbGwgYmFjayB1cCB0byB0aGUgbWFpbiBSYXZpU2Vzc2lvbidzIFxuICAgIC8vIHN0YXRlQ2hhbmdlSGFuZGxlcnMuXG4gICAgLy8gTk9URTogVGFrZSBhIGxvb2sgYXQgQklHV09STEQtMTA2MiBhbmQgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUlRDUGVlckNvbm5lY3Rpb24jUlRDSWNlQ29ubmVjdGlvblN0YXRlX2VudW1cbiAgICAvLyBhbmRcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUlRDUGVlckNvbm5lY3Rpb24jUlRDUGVlckNvbm5lY3Rpb25TdGF0ZV9lbnVtXG4gICAgLy8gdG8gc2VlIHdoeSB3ZSdyZSBsaXN0ZW5pbmcgb24gaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlIGluc3RlYWQgb2YgcGVlcmNvbm5lY3Rpb25zdGF0ZWNoYW5nZVxuICAgIHJ0Y0Nvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcignaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgZnVuY3Rpb24oZXZlbnQ6IGFueSkgeyBcbiAgICAgIHJhdmlTZXNzaW9uLl9oYW5kbGVTdGF0ZUNoYW5nZShldmVudCwgcnRjQ29ubmVjdGlvbi5pY2VDb25uZWN0aW9uU3RhdGUpOyBcbiAgICB9KTtcblxuICAgIC8vIFNpbWlsaWFybHksIGxpc3RlbiBhdCB0aGUgUmF2aVNlc3Npb24gbGV2ZWwgZm9yIHRyYWNrIGFuZCBkYXRhIGNoYW5uZWwgZXZlbnRzXG4gICAgcnRjQ29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdkYXRhY2hhbm5lbCcsIGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHsgcmF2aVNlc3Npb24uX2RvT25kYXRhY2hhbm5lbChldmVudCk7IH0pO1xuICAgIHJ0Y0Nvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcigndHJhY2snLCBmdW5jdGlvbihldmVudDogYW55KSB7IHJhdmlTZXNzaW9uLl9kb09udHJhY2soZXZlbnQpOyB9KTtcblxuICAgIC8vIEhvd2V2ZXIsIHdlIG5lZWQgdG8gbGlzdGVuIGF0IG91ciBvd24gUlRDIGltcGxlbWVudGF0aW9uIGxldmVsIGZvciBpY2UgY2FuZGlkYXRlIGV2ZW50cywgXG4gICAgLy8gYmVjYXVzZSB0aGV5J3JlIHBhcnQgb2YgdGhlIHNlc3Npb24gbmVnb3RpYXRpb25cbiAgICBydGNDb25uZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNhbmRpZGF0ZScsIGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHsgdGhhdC5fZG9PbmljZWNhbmRpZGF0ZShldmVudCk7IH0pO1xuXG4gICAgLy8gV2hlbiBhIG5lZ290aWF0aW9ubmVlZWRlZCBpcyB0cmlnZ2VyZWQgZnJvbSB0aGlzIHBlZXIsIHNpZ25hbCB0aGUgc2VydmVyIHNpZGUgdG8gaW5pdGlhdGUgYW4gb2ZmZXJcbiAgICAvLyBJbiBSYXZpLCB0aGUgd2VicnRjIG5lZ290aWF0aW9uIGlzIGFsd2F5cyBpbml0aWF0ZWQgZnJvbSB0aGUgc2VydmVyIHNpZGVcbiAgICBydGNDb25uZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ25lZ290aWF0aW9ubmVlZGVkJywgZnVuY3Rpb24oZXZlbnQ6IGFueSkgeyB0aGF0Ll9kb09ubmVnb3RpYXRpb25uZWVkZWQoZXZlbnQpOyB9KTtcblxuICAgIC8vIFdhdGNoIHRoZSBzaWduYWxpbmcgc3RhdGUgY2hhbmdlcyBmb3IgZGVidWcuXG4gICAgcnRjQ29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwic2lnbmFsaW5nc3RhdGVjaGFuZ2VcIiwgZnVuY3Rpb24oZXZlbnQ6IGFueSkgeyB0aGF0Ll9kb09uc2lnbmFsaW5nc3RhdGVjaGFuZ2VkKGV2ZW50KTsgfSk7XG5cbiAgfVxuICBcbiAgLyoqXG4gICAqIFRlbGwgdGhpcyBSYXZpV2ViUlRDSW1wbGVtZW50YXRpb24gd2hhdCBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbiB0byB1c2UuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgb3duaW5nIFJhdmlTZXNzaW9uLiBcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX2Fzc2lnblNpZ25hbGluZ0Nvbm5lY3Rpb24oc2lnbmFsaW5nQ29ubmVjdGlvbjogUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24pIHtcbiAgICB0aGlzLl9zaWduYWxpbmdDb25uZWN0aW9uID0gc2lnbmFsaW5nQ29ubmVjdGlvbjtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEFkZCBhbiBpbnB1dCBzdHJlYW0gdG8gdGhpcyBjb25uZWN0aW9uLiAoVGhpcyBjYW4gYmUgZG9uZSBhdFxuICAgKiBhbnkgcG9pbnQgZHVyaW5nIHRoZSBjb25uZWN0aW9uLCB3aGljaCBpcyB3aHkgaXQncyBhIHNlcGFyYXRlIG1ldGhvZC4pXG4gICAqIFxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhlIG93bmluZyBSYXZpU2Vzc2lvbiB3aGVuIGl0cyBzdHJlYW0gY29udHJvbGxlclxuICAgKiBnZXRzIGFuIGlucHV0IHN0cmVhbS4gXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9hZGRBdWRpb0lucHV0U3RyZWFtKHN0cmVhbTogTWVkaWFTdHJlYW0pIHtcbiAgICBjb25zdCBydGNDb25uZWN0aW9uID0gdGhpcy5fcnRjQ29ubmVjdGlvbjtcbiAgICBjb25zdCB0aGF0ID0gdGhpcztcbiAgICB2YXIgcmV0dmFsID0gZmFsc2U7XG5cbiAgICBpZiAoc3RyZWFtKSB7XG4gICAgICAvLyBXZSBrZWVwIHRyYWNrIG9mIHRoZSBzZW5kZXJzIHRoYXQgd2UgaW50ZXJhY3Qgd2l0aFxuICAgICAgLy8gc2VwYXJhdGVseSBmcm9tIHRoZSBsaXN0IG9mIHNlbmRlcnMgb24gdGhlIFJUQyBjb25uZWN0aW9uLFxuICAgICAgLy8gYmVjYXVzZSB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSdyZSBvbmx5IHdvcmtpbmcgd2l0aCBcbiAgICAgIC8vIHNlbmRlcnMgdGhhdCBtYXRjaCBvdXIgb3duIHBhcmFtZXRlcnMuXG4gICAgICBjb25zdCBjdXJyZW50U2VuZGVycyA9IHRoaXMuX3JhdmlBdWRpb1NlbmRlcnM7XG4gICAgICBcbiAgICAgIC8vIExpc3Qgb2YgbmV3IHRyYWNrcyBpbiB0aGUgcGFzc2VkIHN0cmVhbVxuICAgICAgY29uc3QgbmV3QXVkaW9UcmFja3MgPSBzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKTtcbiAgICAgIGNvbnN0IG51bU5ld1RyYWNrcyA9IG5ld0F1ZGlvVHJhY2tzLmxlbmd0aDtcblxuICAgICAgbGV0IGk9MDtcbiAgICAgIGZvciAoaTsgaSA8IGN1cnJlbnRTZW5kZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIEZvciBlYWNoIG9mIHRoZSB0cmFja3MgdGhhdCB3ZSBhbHJlYWR5IGtub3cgYWJvdXQsXG4gICAgICAgIC8vIHJlcGxhY2UgdGhlbSB3aXRoIGEgdHJhY2sgZnJvbSB0aGUgbmV3IHN0cmVhbS5cbiAgICAgICAgLy8gKE5vdGU6IHRoaXMgc2VlbXMgdG8gYWRkIGEgbGl0dGxlIGxhdGVuY3kgd2hlbiBpdCBnZXRzIGNhbGxlZCxcbiAgICAgICAgLy8gYnV0IG9uIHRoZSBwbHVzIHNpZGUsIGRvZXMgbm90IHRyaWdnZXIgYSByZW5lZ290aWF0aW9uLiBUaGUgbGF0ZW5jeVxuICAgICAgICAvLyB0ZW5kcyB0byBkaXNzaXBhdGUgb3ZlciB0aW1lLilcbiAgICAgICAgaWYgKGkgPCBudW1OZXdUcmFja3MpIHtcbiAgICAgICAgICBSYXZpVXRpbHMubG9nKFwiUmVwbGFjaW5nIGF1ZGlvIHRyYWNrICNcIiArIGkgKyBcIiAgaW4gcnRjQ29ubmVjdGlvblwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgICBjdXJyZW50U2VuZGVyc1tpXS5yZXBsYWNlVHJhY2sobmV3QXVkaW9UcmFja3NbaV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBtb3JlIHRyYWNrcyBpbiB0aGUgb2xkIHN0cmVhbSB0aGFuXG4gICAgICAgICAgLy8gaW4gdGhlIG5ldyBvbmUsIHNldCB0aGUgZXh0cmFzIHRvIG51bGwgXG4gICAgICAgICAgUmF2aVV0aWxzLmxvZyhcIlNldHRpbmcgYXVkaW8gc2VuZGVyICNcIiArIGkgKyBcIiB0byBudWxsXCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICAgIGN1cnJlbnRTZW5kZXJzW2ldLnJlcGxhY2VUcmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGVyZSBhcmUgbW9yZSB0cmFja3MgaW4gdGhlIG5ldyBzdHJlYW0gdGhlblxuICAgICAgLy8gaW4gdGhlIG9sZCwgYWRkIHRoZW1cbiAgICAgIGZvciAoaTsgaSA8IG51bU5ld1RyYWNrczsgaSsrKSB7XG4gICAgICAgIFJhdmlVdGlscy5sb2coXCJBZGRpbmcgbG9jYWwgYXVkaW8gdHJhY2sgI1wiICsgaSArIFwiIHRvIHJ0Y0Nvbm5lY3Rpb25cIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgIGN1cnJlbnRTZW5kZXJzLnB1c2gocnRjQ29ubmVjdGlvbi5hZGRUcmFjayhuZXdBdWRpb1RyYWNrc1tpXSkpO1xuICAgICAgICAvLyBXZSBleHBlY3QgdGhlICduZWdvdGlhdGlvbm5lZWRlZCcgZXZlbnQgdG8gZmlyZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZSBzdHJlYW0gYXNzaWduZWQgaXMgbnVsbCBtZWFuaW5nIHdlIHdhbnQgdG8ga2lsbCBhbnkgaW5wdXQgYXVkaW8gc3RyZWFtXG4gICAgICAgIGNvbnN0IGN1cnJlbnRTZW5kZXJzID0gdGhpcy5fcmF2aUF1ZGlvU2VuZGVycztcblxuICAgICAgICAvLyBzaW1wbHkgc2V0IGFsbCB0aGUgZXhpc3Rpbmcgc2VuZGVycyB0byBudWxsIHRyYWNrLlxuICAgICAgICBsZXQgaT0wO1xuICAgICAgICBmb3IgKGk7IGkgPCBjdXJyZW50U2VuZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIFJhdmlVdGlscy5sb2coXCJTZXR0aW5nIGF1ZGlvIHNlbmRlciAjXCIgKyBpICsgXCIgdG8gbnVsbFwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgICBjdXJyZW50U2VuZGVyc1tpXS5yZXBsYWNlVHJhY2sobnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldHZhbDtcbiAgfVxuXG4gIF9hZGRWaWRlb0lucHV0U3RyZWFtKHN0cmVhbTogTWVkaWFTdHJlYW0pIHtcbiAgICBjb25zdCBydGNDb25uZWN0aW9uID0gdGhpcy5fcnRjQ29ubmVjdGlvbjtcbiAgICBjb25zdCB0aGF0ID0gdGhpcztcbiAgICB2YXIgcmV0dmFsID0gZmFsc2U7XG5cbiAgICBpZiAoc3RyZWFtKSB7XG4gICAgICAvLyBXZSBrZWVwIHRyYWNrIG9mIHRoZSBzZW5kZXJzIHRoYXQgd2UgaW50ZXJhY3Qgd2l0aFxuICAgICAgLy8gc2VwYXJhdGVseSBmcm9tIHRoZSBsaXN0IG9mIHNlbmRlcnMgb24gdGhlIFJUQyBjb25uZWN0aW9uLFxuICAgICAgLy8gYmVjYXVzZSB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSdyZSBvbmx5IHdvcmtpbmcgd2l0aCBcbiAgICAgIC8vIHNlbmRlcnMgdGhhdCBtYXRjaCBvdXIgb3duIHBhcmFtZXRlcnMuXG4gICAgICBjb25zdCBjdXJyZW50U2VuZGVycyA9IHRoaXMuX3JhdmlWaWRlb1NlbmRlcnM7XG4gICAgICBcbiAgICAgIC8vIExpc3Qgb2YgbmV3IHRyYWNrcyBpbiB0aGUgcGFzc2VkIHN0cmVhbVxuICAgICAgY29uc3QgbmV3VmlkZW9UcmFja3MgPSBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKTtcbiAgICAgIGNvbnN0IG51bU5ld1RyYWNrcyA9IG5ld1ZpZGVvVHJhY2tzLmxlbmd0aDtcbiAgICAgIFxuICAgICAgLy8gQXQgdGhlIG1vbWVudCwgcmF2aSBjbGllbnQgc2Vzc2lvbiBvbmx5IHN1cHBvcnQgb25lIG91dGJvdW5kIHZpZGVvIHRyYWNrXG4gICAgICBpZiAobnVtTmV3VHJhY2tzID4gMCkge1xuICAgICAgICAvLyBJZiBjdXJyZW50IHZpZGVvIHNlbmRlciBleGlzdHMgYWxyZWFkeSwganVzdCByZXBsYWNlIHRyYWNrXG4gICAgICAgIGlmIChjdXJyZW50U2VuZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgUmF2aVV0aWxzLmxvZyhcIlJlcGxhY2luZyB2aWRlbyB0cmFjayAjMCBpbiBydGNDb25uZWN0aW9uXCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICAgIGN1cnJlbnRTZW5kZXJzWzBdLnJlcGxhY2VUcmFjayhuZXdWaWRlb1RyYWNrc1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZWxzZSBqdXN0IGFkZCB0aGUgbmV3IHRyYWNrIHRvIHRoZSBQZWVyQ29ubmVjdGlvbi5cbiAgICAgICAgICBSYXZpVXRpbHMubG9nKFwiQWRkaW5nIHZpZGVvIHRyYWNrICMwIHRvIHJ0Y0Nvbm5lY3Rpb25cIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgICAgY3VycmVudFNlbmRlcnMucHVzaChydGNDb25uZWN0aW9uLmFkZFRyYWNrKG5ld1ZpZGVvVHJhY2tzWzBdKSk7XG4gICAgICAgICAgLy8gV2UgZXhwZWN0IHRoZSAnbmVnb3RpYXRpb25uZWVkZWQnIGV2ZW50IHRvIGZpcmVcbiAgICAgICAgfVxuICAgICAgICByZXR2YWwgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIkFzc2lnbmVkIHZpZGVvIHN0cmVhbSBkb2Vzbid0IGNvbnRhaW4gdmlkb2UgdHJhY2tcIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICB9ICAgICAgICAgICAgIFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aGUgc3RyZWFtIGFzc2lnbmVkIGlzIG51bGwgbWVhbmluZyB3ZSB3YW50IHRvIGtpbGwgYW55IGlucHV0IHZpZGVvIHN0cmVhbVxuICAgICAgY29uc3QgY3VycmVudFNlbmRlcnMgPSB0aGlzLl9yYXZpVmlkZW9TZW5kZXJzO1xuXG4gICAgICAvLyBzaW1wbHkgc2V0IGFsbCB0aGUgZXhpc3Rpbmcgc2VuZGVycyB0byBudWxsIHRyYWNrLlxuICAgICAgbGV0IGk9MDtcbiAgICAgIGZvciAoaTsgaSA8IGN1cnJlbnRTZW5kZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIFJhdmlVdGlscy5sb2coXCJTZXR0aW5nIHZpZGVvIHNlbmRlciAjXCIgKyBpICsgXCIgdG8gbnVsbFwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgY3VycmVudFNlbmRlcnNbaV0ucmVwbGFjZVRyYWNrKG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0dmFsO1xuICB9XG4gIFxuICAvKipcbiAgICogT3BlbiBhIHNlc3Npb24uIFRoaXMgaW1wbGVtZW50YXRpb24gZG9lcyB0aGlzIGJ5IGFkZGluZyBhIGhhbmRsZXIgdG8gdGhlIHNpZ25hbGluZ0Nvbm5lY3Rpb25cbiAgICogdGhhdCB3aWxsIGxpc3RlbiBmb3IgXCJyZWFkeSB0byBuZWdvdGlhdGUgY29ubmVjdGlvblwiIG1lc3NhZ2VzIHNvIHRoYXQgdGhlIFxuICAgKiBfc2V0dXBDb25uZWN0aW9uIG1ldGhvZCBjYW4gdGhlbiBuZWdvdGlhdGUgdGhlIGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgb3duaW5nIFJhdmlTZXNzaW9uLiBcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX29wZW4ocGFyYW1zOiBhbnkpIHtcbiAgICBSYXZpVXRpbHMubG9nKFwiQXR0ZW1wdGluZyB0byBvcGVuIGNvbm5lY3Rpb24uLi5cIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgaWYgKHRoaXMuX3J0Y0Nvbm5lY3Rpb24uY29ubmVjdGlvblN0YXRlID09ICdjb25uZWN0aW5nJyB8fCB0aGlzLl9ydGNDb25uZWN0aW9uLmNvbm5lY3Rpb25TdGF0ZSA9PSAnY29ubmVjdGVkJykge1xuICAgICAgUmF2aVV0aWxzLmxvZyhcIldlIGFscmVhZHkgaGF2ZSBhIGNvbm5lY3Rpb24gaW4gcHJvZ3Jlc3MuIFdpbGwgbm90IGF0dGVtcHQgYSBuZXcgb25lLlwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgIC8vIFRyaWdnZXIgc3RhdGUgY2hhbmdlIGhhbmRsZXIgb24gdGhlIG93bmluZyBzZXNzaW9uIHRvIGZpbmFsaXplIGFueSBcbiAgICAgIC8vIHJlc2lkdWFsIFByb21pc2VzXG4gICAgICB0aGlzLl9yYXZpU2Vzc2lvbi5faGFuZGxlU3RhdGVDaGFuZ2Uoe1wic3RhdGVcIjp0aGlzLl9ydGNDb25uZWN0aW9uLmNvbm5lY3Rpb25TdGF0ZX0sIHRoaXMuX3J0Y0Nvbm5lY3Rpb24uY29ubmVjdGlvblN0YXRlKTsgXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NpZ25hbGluZ0Nvbm5lY3Rpb24pIHtcbiAgICAgIC8vIEFkZCBhIGhhbmRsZXIgZm9yIHN0YXRlIGNoYW5nZSBldmVudHMgb250byB0aGUgcHJvdmlkZWRcbiAgICAgIC8vIHNpZ25hbGluZyBjb25uZWN0aW9uLiBUaGlzIHNob3VsZCBsaXN0ZW4gZm9yIHRoZSBhcHByb3ByaWF0ZSBcbiAgICAgIC8vIFwicmVhZHkgdG8gbmVnb3RpYXRlIGNvbm5lY3Rpb25cIiBtZXNzYWdlIGZyb20gdGhlIHNpZ25hbGluZyBjb25uZWN0aW9uLlxuICAgICAgdGhpcy5fc2lnbmFsaW5nQ29ubmVjdGlvbi5hZGRNZXNzYWdlSGFuZGxlcih0aGlzLl9uZWdvdGlhdG9yKTtcblxuICAgICAgLy8gU2VuZCB0aGUgbWFnaWMgc3RyaW5nIGZvciBvcGVuaW5nIGEgY29ubmVjdGlvbi5cbiAgICAgIC8vIHdpdGggcGFyYW1zIGV2ZW50dWFsbHlcbiAgICAgIGxldCBtZXNzYWdlOiBhbnkgPSB7fTtcbiAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICBtZXNzYWdlID0gcGFyYW1zO1xuICAgICAgICAgIG1lc3NhZ2VbXCJzZXNzaW9uSURcIl0gPSB0aGlzLl9yYXZpU2Vzc2lvbi5nZXRVVUlEKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLl9yYXZpU2Vzc2lvbi5nZXRVVUlEKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NpZ25hbGluZ0Nvbm5lY3Rpb24uc2VuZChKU09OLnN0cmluZ2lmeSh7J3JlcXVlc3QnOiBtZXNzYWdlfSkpO1xuICAgIH1cbiAgfVxuICBcbiAgXG4gIC8qKlxuICAgKiBDbG9zZSBhIHNlc3Npb24uXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgb3duaW5nIFJhdmlTZXNzaW9uLiBcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX2Nsb3NlKCkge1xuICAgIGlmICh0aGlzLl9ydGNDb25uZWN0aW9uKSB7XG4gICAgICB0aGlzLl9zdGF0c1dhdGNoZXIuc3RvcCgpO1xuXG4gICAgICBSYXZpVXRpbHMubG9nKFwiY2xvc2luZ1wiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgIHRoaXMuX3J0Y0Nvbm5lY3Rpb24uY2xvc2UoKTsgICAgXG4gICAgICB0aGlzLl9ydGNDb25uZWN0aW9uID0gbnVsbDtcblxuICAgICAgdmFyIGV2ZW50ID0ge1wic3RhdGVcIjpSYXZpU2Vzc2lvblN0YXRlcy5DTE9TRUR9O1xuICAgICAgdGhpcy5fcmF2aVNlc3Npb24uX2hhbmRsZVN0YXRlQ2hhbmdlKGV2ZW50LCBSYXZpU2Vzc2lvblN0YXRlcy5DTE9TRUQpOyBcbiAgICAgIFxuICAgICAgLy8gUmVtb3ZlIG91ciBzZXNzaW9uLW5lZ290aWF0aW5nIG1lc3NhZ2UgaGFuZGxlclxuICAgICAgdGhpcy5fc2lnbmFsaW5nQ29ubmVjdGlvbi5yZW1vdmVNZXNzYWdlSGFuZGxlcih0aGlzLl9uZWdvdGlhdG9yKTtcblxuICAgICAgLy8gUmVpbml0aWFsaXplIHRoZSBSVEMgY29ubmVjdGlvbiBzbyBpdCdzIHJlYWR5IGZvciBhbm90aGVyIHNlc3Npb24gaWYgbmVlZGVkLlxuICAgICAgdGhpcy5faW5pdFJ0Y0Nvbm5lY3Rpb24oKTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHNlbmQgbG9jYWwgSUNFIGNhbmRpZGF0ZSBwcm9wb3NhbHMgdG8gdGhlIHNlcnZlci5cbiAgICogXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZG9PbmljZWNhbmRpZGF0ZShldmVudDogYW55KSB7IFxuICAgIGlmIChldmVudC5jYW5kaWRhdGUgJiYgZXZlbnQuY2FuZGlkYXRlICE9IFwiXCIpIHtcbiAgICAgIFJhdmlVdGlscy5sb2coXCJTZW5kaW5nIGxvY2FsIElDRSBjYW5kaWRhdGU6IFwiICsgSlNPTi5zdHJpbmdpZnkoZXZlbnQuY2FuZGlkYXRlKSwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICB0aGlzLl9zaWduYWxpbmdDb25uZWN0aW9uLnNlbmQoSlNPTi5zdHJpbmdpZnkoeydpY2UnOiBldmVudC5jYW5kaWRhdGUsICd1dWlkJzogdGhpcy5fcmF2aVNlc3Npb24uZ2V0VVVJRCgpfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBSYXZpVXRpbHMubG9nKFwiRW5kIG9mIGxvY2FsIElDRSBjYW5kaWRhdGVzXCIsIFwiUmF2aVNlc3Npb25cIik7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogSGFuZGxlIHJlbmVnb3RpYXRpb24gd2hlbiBuZWVkZWQuXG4gICAqIFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RvT25uZWdvdGlhdGlvbm5lZWRlZChldmVudDogYW55KSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcIm5lZWQgcmVuZWdvdGlhdGlvbiBwbGVhc2VcIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgY29uc3QgbXNnID0ge1xuICAgICAgcmVuZWdvdGlhdGU6IFwicGxlYXNlXCIsXG4gICAgICB1dWlkOiB0aGlzLl9yYXZpU2Vzc2lvbi5nZXRVVUlEKClcbiAgICB9O1xuICAgIGNvbnN0IGRlc2MgPSBKU09OLnN0cmluZ2lmeShtc2cpO1xuICAgXG4gICAgLy8gbmVnb3RpYXRpb24gbmVlZGVkIGJ1dCBvbmx5IGlmIHdlIGFyZSBub3QgYWxyZWFkeSBjdXJyZW50bHkgbmVnb3RpYXRpbmdcbiAgICBpZiAodGhpcy5fc2lnbmFsaW5nQ29ubmVjdGlvbiAmJiB0aGlzLl9ydGNDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlID09PSBcInN0YWJsZVwiKSB7XG4gICAgICB0aGlzLl9zaWduYWxpbmdDb25uZWN0aW9uLnNlbmQoZGVzYyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBzaWduYWxpbmcgc3RhdGUgY2hhbmdlLlxuICAgKiBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kb09uc2lnbmFsaW5nc3RhdGVjaGFuZ2VkKGV2ZW50OiBhbnkpIHtcbiAgICAvLyBzaW1wbGUgbG9nZ2luZyBmb3Igbm93XG4gICAgUmF2aVV0aWxzLmxvZyhcIlNpZ25hbGluZ1N0YXRlIGNoYW5nZWQ6IFwiICsgdGhpcy5fcnRjQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9mb3JjZUJpdHJhdGVVcChzZHA6IHN0cmluZykge1xuICAgIC8vIE5lZWQgdG8gZm9ybWF0IHRoZSBTRFAgZGlmZmVyZW50bHkgaWYgdGhlIGlucHV0IGlzIHN0ZXJlbywgc28gXG4gICAgLy8gcmVhY2ggdXAgaW50byBvdXIgb3duZXIncyBzdHJlYW0gY29udHJvbGxlciB0byBmaW5kIG91dC5cbiAgICBjb25zdCBsb2NhbEF1ZGlvSXNTdGVyZW8gPSB0aGlzLl9yYXZpU2Vzc2lvbi5fc3RyZWFtQ29udHJvbGxlci5pc1N0ZXJlb0lucHV0KCk7XG4gICAgLy8gVXNlIDEyOGticHMgZm9yIHN0ZXJlbyB1cHN0cmVhbSBhdWRpbywgNjRrYnBzIGZvciBtb25vXG4gICAgY29uc3QgYml0cmF0ZSA9IGxvY2FsQXVkaW9Jc1N0ZXJlbyA/IDEyODAwMCA6IDY0MDAwO1xuXG4gICAgLy8gU0RQIG11bmdpbmc6IHVzZSAxMjhrYnBzIGZvciBzdGVyZW8gdXBzdHJlYW0gYXVkaW8sIDY0a2JwcyBmb3IgbW9ub1xuICAgIHJldHVybiBzZHAucmVwbGFjZSgvYT1mbXRwOjExMSAvZywgJ2E9Zm10cDoxMTEgbWF4YXZlcmFnZWJpdHJhdGU9JytiaXRyYXRlKyc7Jyk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2ZvcmNlU3RlcmVvRG93bihzZHA6IHN0cmluZykge1xuICAgIC8vIG11bmdlIHRoZSBTRFAgYW5zd2VyOiByZXF1ZXN0IDEyOGticHMgc3RlcmVvIGZvciBkb3duc3RyZWFtIGF1ZGlvXG4gICAgcmV0dXJuIHNkcC5yZXBsYWNlKC9hPWZtdHA6MTExIC9nLCAnYT1mbXRwOjExMSBtYXhhdmVyYWdlYml0cmF0ZT0xMjgwMDA7c3Byb3Atc3RlcmVvPTE7c3RlcmVvPTE7Jyk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdGVucyB0byBhbGwgbWVzc2FnZXMgb24gdGhlIHNpZ25hbGluZyBjb25uZWN0aW9uIChzZWUgdGhlIF9vcGVuKCkgbWV0aG9kKSwgYW5kXG4gICAqIHdhdGNoZXMgZm9yIHRoZSBhcHByb3ByaWF0ZSBTRFAtcmVsYXRlZCBldmVudHMgc28gdGhhdCBpdCBjYW4gbmVnb3RpYXRlIHRoZSBjb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldHVwQ29ubmVjdGlvbihldmVudDogYW55KSB7XG4gICAgbGV0IGZ1bGxNZXNzYWdlOmFueSA9IFwiXCI7XG4gICAgbGV0IHNpZ25hbDphbnkgPSBcIlwiO1xuXG4gICAgXG4gICAgLy8gTG9jYWwgY29waWVzIG9mIHVzZWZ1bCB2YXJpYWJsZXMgdG8gYXZvaWQgaGF2aW5nIHRvIGJpbmRcbiAgICBjb25zdCByYXZpU2Vzc2lvbiA9IHRoaXMuX3JhdmlTZXNzaW9uO1xuICAgIGNvbnN0IHJ0Y0Nvbm5lY3Rpb24gPSB0aGlzLl9ydGNDb25uZWN0aW9uO1xuICAgIGNvbnN0IHNpZ25hbGluZ0Nvbm5lY3Rpb24gPSB0aGlzLl9zaWduYWxpbmdDb25uZWN0aW9uO1xuICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xuICAgIFxuICAgIC8vIEp1c3QgaW4gY2FzZSwgbWFrZSBzdXJlIHdlIGhhdmUgZXZlcnl0aGluZyB3ZSBuZWVkXG4gICAgaWYgKCFyYXZpU2Vzc2lvbiB8fCAhcnRjQ29ubmVjdGlvbiB8fCAhc2lnbmFsaW5nQ29ubmVjdGlvbikge1xuICAgICAgUmF2aVV0aWxzLmVycihcIk1pc3Npbmcgb25lIG9mIHJhdmlTZXNzaW9uLCBydGNDb25uZWN0aW9uLCBvciBzaWduYWxpbmdDb25uZWN0aW9uISBDYW4ndCBzZXQgdXAgY29ubmVjdGlvbi5cIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgbWVzc2FnZSwgYW5kIHRoYXQgaXQncyBmb3IgdGhpcyBwYXJ0aWN1bGFyIFJBVkkgc2Vzc2lvblxuICAgIGlmIChldmVudCAmJiBldmVudC5kYXRhKSB7XG4gICAgICBSYXZpVXRpbHMubG9nKCdNZXNzYWdlIGZyb20gc2VydmVyOiAnICsgZXZlbnQuZGF0YSwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICBmdWxsTWVzc2FnZSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJhdmlVdGlscy5sb2coJ05vIG1lc3NhZ2UgcmVjZWl2ZWQgYnkgb25NZXNzYWdlIGhhbmRsZXInLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgIHJldHVybjsgLy8gTm8gbWVzc2FnZVxuICAgIH1cbiAgICBzaWduYWwgPSBmdWxsTWVzc2FnZVtyYXZpU2Vzc2lvbi5nZXRVVUlEKCldO1xuICAgIGlmICghc2lnbmFsKSByZXR1cm47IC8vIFRoaXMgbWVzc2FnZSBpcyBub3QgZm9yIG1lXG5cbiAgICAvLyBXZSBoYXZlIGEgc2lnbmFsOyBjaGVjayBmaXJzdCB0byBzZWUgaWYgaXQncyBhbiBTRFBcbiAgICBpZiAoc2lnbmFsLnNkcCkge1xuICAgICAgUmF2aVV0aWxzLmxvZyhcIkdvdCBzZHAgb2YgdHlwZTpcIiArIHNpZ25hbC50eXBlLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICBcbiAgICAgIC8vIEZvcmNlIG91ciBkZXNpcmVkIGJpdHJhdGUgYnkgbXVuZ2luZyB0aGUgU0RQLCBhbmQgY3JlYXRlIGEgc2Vzc2lvbiBkZXNjcmlwdGlvbiBmb3IgaXRcbiAgICAgIHNpZ25hbC5zZHAgPSB0aGF0Ll9mb3JjZUJpdHJhdGVVcChzaWduYWwuc2RwKTsgXG4gICAgICBjb25zdCBkZXNjID0gbmV3IGNyb3NzUGxhdGZvcm1SVENTZXNzaW9uRGVzY3JpcHRpb24oc2lnbmFsKTtcblxuICAgICAgLy8gU2V0IHRoZSBkZXNjcmlwdGlvbiBvbiB0aGUgUlRDIGNvbm5lY3Rpb24sIGFuZCBzZW5kIGFuZCBoYW5kbGUgdGhlIHZhcmlvdXMgU0RQc1xuICAgICAgcnRjQ29ubmVjdGlvbi5zZXRSZW1vdGVEZXNjcmlwdGlvbihkZXNjKVxuICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhbiBhbnN3ZXJcbiAgICAgICByZXR1cm4gcnRjQ29ubmVjdGlvbi5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgIH0pXG4gICAgICAudGhlbihmdW5jdGlvbihhbnN3ZXI6IGFueSkge1xuICAgICAgICAvLyBGb3JjZSBzdGVyZW8gb24gdGhlIGRvd25zdHJlYW0gc3RyZWFtIGJ5IG11bmdpbmcgdGhlIFNEUFxuICAgICAgICBhbnN3ZXIuc2RwID0gdGhhdC5fZm9yY2VTdGVyZW9Eb3duKGFuc3dlci5zZHApOyBcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIkFuc3dlcjpcIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgIFJhdmlVdGlscy5sb2coYW5zd2VyLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgLy8gc2V0IGxvY2FsIGRlc2NyaXB0aW9uXG4gICAgICAgIHJldHVybiBydGNDb25uZWN0aW9uLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgIH0pXG4gICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgbXNnID0ge1xuICAgICAgICAgIHR5cGU6IFwiYW5zd2VyXCIsXG4gICAgICAgICAgc2RwOiBydGNDb25uZWN0aW9uLmxvY2FsRGVzY3JpcHRpb24sXG4gICAgICAgICAgdXVpZDogcmF2aVNlc3Npb24uZ2V0VVVJRCgpXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGRlc2MgPSBKU09OLnN0cmluZ2lmeShtc2cpO1xuICAgICAgICBSYXZpVXRpbHMubG9nKFwiU2VuZGluZyBhbnN3ZXIgdG8gc2VydmVyXCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICAvLyBTZW5kIHRoZSBmaW5hbCByZXN1bHQgYmFjayB0byB0aGUgc2VydmVyXG4gICAgICAgIHNpZ25hbGluZ0Nvbm5lY3Rpb24uc2VuZChkZXNjKTtcbiAgICAgIH0pO1xuXG4gICAgfSBlbHNlIGlmIChzaWduYWwuaWNlKSB7XG4gICAgICBSYXZpVXRpbHMubG9nKFwiUmVjZWl2ZWQgcmVtb3RlIElDRSBjYW5kaWRhdGU6IFwiICsgSlNPTi5zdHJpbmdpZnkoc2lnbmFsLmljZSksIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgcnRjQ29ubmVjdGlvbi5hZGRJY2VDYW5kaWRhdGUoc2lnbmFsLmljZSlcbiAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICBSYXZpVXRpbHMubG9nKFwiQWRkZWQgcmVtb3RlIGNhbmRpZGF0ZVwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZnVuY3Rpb24oZTogYW55KSB7XG4gICAgICAgIFJhdmlVdGlscy5lcnIoXCJFcnJvciBhdHRlbXB0aW5nIHRvIGFkZCByZW1vdGUgSUNFIGNhbmRpZGF0ZTogXCIgKyBlLm1lc3NhZ2UsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNvbWUgb3RoZXIgaGFuZGxlcidzIHByb2JsZW1cbiAgICAgIFJhdmlVdGlscy5sb2coXCJVbmtub3duIG1lc3NhZ2UgXCIgKyBKU09OLnN0cmluZ2lmeShzaWduYWwpLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBBZGQgYSBoYW5kbGVyIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGxpc3RlbiBmb3IgbmV3IHN0YXRzIGdlbmVyYXRlZC5cbiAgICogVGhlc2UgYXJlIHN0b3JlZCBpbiBhIFNldCBvZiBGdW5jdGlvbnM7IHRoZXJlZm9yZSwgYSBnaXZlbiBmdW5jdGlvblxuICAgKiBjYW4gb25seSBleGlzdCBvbmNlIGluIHRoaXMgU2V0LlxuICAgKiBcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSYXZpU2Vzc2lvbn5zdGF0c09ic2VydmVyQ2FsbGJhY2t9IGhhbmRsZXIgQSBjYWxsYmFjayBoYW5kbGVyIHRoYXQgc2hvdWxkIGhhbmRsZSBhIHN0YXRlIGNoYW5nZSBldmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGFkZCBzdWNjZWVkZWRcbiAgICovXG4gIF9hZGRTdGF0c09ic2VydmVyKG9ic2VydmVyOiBGdW5jdGlvbikge1xuICAgIHJldHVybiB0aGlzLl9zdGF0c1dhdGNoZXIuYWRkT2JzZXJ2ZXIob2JzZXJ2ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGhhbmRsZXIgc28gdGhhdCBpdCBzdG9wcyBsaXN0ZW5pbmcgZm9yIHN0YXRzIHVwZGF0ZXMuXG4gICAqIFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1JhdmlTZXNzaW9ufnN0YXRzT2JzZXJ2ZXJDYWxsYmFja30gaGFuZGxlciBBIGNhbGxiYWNrIGhhbmRsZXIgdGhhdCBzaG91bGQgaGFuZGxlIGEgc3RhdGUgY2hhbmdlIGV2ZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgcmVtb3ZhbCB3YXMgc3VjY2Vzc2Z1bCAoaS5lLiBkaWQgbm90IHRocm93IGFuIGVycm9yIC0tIG5vdGUgdGhhdCB0aGlzIGRvZXNcbiAgICogTk9UIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIHdhcyBpbiB0aGUgc2V0IGluIHRoZSBmaXJzdCBwbGFjZSlcbiAgICovXG4gIF9yZW1vdmVTdGF0c09ic2VydmVyKG9ic2VydmVyOiBGdW5jdGlvbikge1xuICAgIHJldHVybiB0aGlzLl9zdGF0c1dhdGNoZXIucmVtb3ZlT2JzZXJ2ZXIob2JzZXJ2ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9zZSB0aGUgZ2V0U3RhdHMgY2FsbCBvbiB0aGUgcnRjUGVlckNvbm5lY3Rpb25cbiAgICogdXNlZCBieSB0aGUgc3RhdHNXYXRjaGVyXG4gICAqL1xuICBhc3luYyBfZ2V0U3RhdHMoc2VsZWN0b3I6IGFueSA9IG51bGwpIHtcbiAgICBpZiAodGhpcy5fcnRjQ29ubmVjdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J0Y0Nvbm5lY3Rpb24uZ2V0U3RhdHMoc2VsZWN0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG59XG4iLCJjb25zdCB7IFJhdmlVdGlscyB9ID0gcmVxdWlyZSgnLi9SYXZpVXRpbHMnKTtcblxuLyoqXG4gKiBFbnVtIGZvciByZXByZXNlbnRpbmcgZGlmZmVyZW50IHBvc3NpYmxlIHN0YXRlc1xuICogdGhhdCBhIFJBVkkgc2lnbmFsaW5nQ29ubmVjdGlvbiBtaWdodCBiZSBpbi5cbiAqXG4gKiBcIlVOQVZBSUxBQkxFXCIgaXMgYSBjdXN0b20gc3RhdGUgdGhhdCBnZXRzIHNldFxuICogaWYgdGhlIHNlcnZlciBpcyBpbiBhIFwicnVubmluZywgYnV0IG5vdCBjdXJyZW50bHlcbiAqIGFjY2VwdGluZyBpbmNvbWluZyBjb25uZWN0aW9uc1wiIHN0YXRlLiBOb3RlIGhvd2V2ZXJcbiAqIHRoYXQgdGhpcyBpcyBhIHRyYW5zaWVudCBzdGF0ZSAtLSBhIGNvbm5lY3Rpb24gdGhhdCdzXG4gKiBlbnRlcmVkIHRoaXMgc3RhdGUgd2lsbCB1c3VhbGx5IHRoZW4gcHJvY2VlZCB0byBcIkVSUk9SXCIgYW5kXG4gKiB0aGVuIHRvIFwiQ0xPU0VEXCIuIEhhbmRsZSBhcHByb3ByaWF0ZWx5IVxuICogXG4gKiBAcmVhZG9ubHlcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBlbnVtIFNpZ25hbGluZ1N0YXRlcyB7XG4gIENPTk5FQ1RJTkcgPSBcImNvbm5lY3RpbmdcIixcbiAgT1BFTiA9IFwib3BlblwiLFxuICBFUlJPUiA9IFwiZXJyb3JcIixcbiAgQ0xPU0lORyA9IFwiY2xvc2luZ1wiLFxuICBDTE9TRUQgPSBcImNsb3NlZFwiLFxuICBVTkFWQUlMQUJMRSA9IFwidW5hdmFpbGFibGVcIlxufTtcblxuLyoqIFxuICpcbiAqIEBjbGFzc1xuICogQGNsYXNzZGVzYyBTaWduYWxpbmcgY29ubmVjdGlvbiBzcGVjaWZpY2FsbHkgZm9yIGhhbmRsaW5nIFJBVkkgc2Vzc2lvbnMuXG4gKiBUaGlzIGdldHMgdXNlZCBieSB0aGUgUmF2aVNlc3Npb24gKGFuZCBpdHMgUGVlckNvbm5lY3Rpb24gaW1wbGVtZW50YXRpb24pXG4gKiB0byBzZXQgdXAgYSBSYXZpU2Vzc2lvbiBjb25uZWN0aW9uLlxuICogVGhpcyBjbGFzcyBzaG91bGQgYmUgaW5zdGFudGlhdGVkIGJ5IHRoZSBSQVZJIGNvbnN1bWVyLCBhbmQgdGhlbiB1c2VkIHRvIG9wZW4sIHdvcmsgd2l0aCwgYW5kIGNsb3NlIFxuICogUkFWSSBzZXNzaW9ucyBhcyBuZWVkZWQuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24ge1xuICBfc3RhdGVDaGFuZ2VIYW5kbGVyczogU2V0PEZ1bmN0aW9uPjtcbiAgX21lc3NhZ2VIYW5kbGVyczogU2V0PEZ1bmN0aW9uPjtcbiAgX3N0YXRlOiBTaWduYWxpbmdTdGF0ZXM7XG4gIF9zaWduYWxpbmdJbXBsZW1lbnRhdGlvbjogUmF2aVNpZ25hbGluZ1dlYlNvY2tldEltcGxlbWVudGF0aW9uO1xuICBcbiAgLyoqXG4gICAqIFwiQ2xhc3NcIiB2YXJpYWJsZXMgdG8gYmUgYXdhcmUgb2Y6XG4gICAqXG4gICAqIHRoaXMuX3N0YXRlY2hhbmdlSGFuZGxlcnMgICAvLyBBIGxpc3Qgb2YgaGFuZGxlcnMgdG8gY2FsbCB3aGVuIHRoZSBjb25uZWN0aW9uIHN0YXRlIGNoYW5nZXNcbiAgICogdGhpcy5fbWVzc2FnZUhhbmRsZXJzICAgICAgIC8vIEEgbGlzdCBvZiBoYW5kbGVycyB0byBjYWxsIHdoZW4gYSBtZXNzYWdlIGlzIHJlY2VpdmVkXG4gICAqXG4gICAqIHRoaXMuX3NpZ25hbGluZ0ltcGxlbWVudGF0aW9uICAgLy8gVGhlIGltcGxlbWVudGF0aW9uIG9mIHNpZ25hbGluZyB0byB1c2VcbiAgICpcbiAgICogdGhpcy5fc3RhdGUgICAgICAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoaXMgY29ubmVjdGlvblxuICAgKi9cbiAgXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb25cbiAgICogRGVmYXVsdHMgdGhlIGhhbmRsZXJzXG4gICAqIGFuZCBpbml0aWFsaXplcyB0aGUgc3RhdGUgdG8gU2lnbmFsaW5nU3RhdGVzLkNMT1NFRC5cbiAgICpcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBSYXZpVXRpbHMubG9nKFwiQ29uc3RydWN0b3JcIiwgXCJSYXZpU2lnbmFsaW5nQ29ubmVjdGlvblwiKTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIHRoZSBsaXN0IG9mIGhhbmRsZXJzXG4gICAgdGhpcy5fc3RhdGVDaGFuZ2VIYW5kbGVycyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLl9tZXNzYWdlSGFuZGxlcnMgPSBuZXcgU2V0KCk7XG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcbiAgICB0aGlzLl9zdGF0ZSA9IFNpZ25hbGluZ1N0YXRlcy5DTE9TRUQ7XG4gICAgXG4gICAgLy8gSWYgd2Ugd2FudGVkIHRvIHVzZSBhIGRpZmZlcmVudCBzaWduYWxpbmcgaW1wbGVtZW50YXRpb24sXG4gICAgLy8gd2Ugd291bGQgbmV3KCkgaXQgaGVyZS4gKFRPRE86IE1ha2UgdGhpcyBjb25maWd1cmFibGUgaW4gc29tZVxuICAgIC8vIGludGVyZXN0aW5nIHdheS4gRm9yIG5vdywgaXQncyBlbm91Z2gganVzdCB0byBtYWtlIGl0IGVhc2lseSBcbiAgICAvLyBzd2FwcGFibGUgaW4gdGhlIGNvZGUgaGVyZS4pXG4gICAgdGhpcy5fc2lnbmFsaW5nSW1wbGVtZW50YXRpb24gPSBuZXcgUmF2aVNpZ25hbGluZ1dlYlNvY2tldEltcGxlbWVudGF0aW9uKHRoaXMpO1xuICAgIFxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc2lnbmFsaW5nIGNvbm5lY3Rpb25cbiAgICogXG4gICAqIEByZXR1cm5zIHtTaWduYWxpbmdTdGF0ZXN9XG4gICAqL1xuICBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmb3IgbGlzdGVuaW5nIHRvIHN0YXRlIGNoYW5nZXNcbiAgICogQGNhbGxiYWNrIFJhdmlTaWduYWxpbmdDb25uZWN0aW9ufnN0YXRlQ2hhbmdlQ2FsbGJhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IEFuIG9iamVjdCB0aGF0IHdpbGwgY29udGFpbiBpbmZvcm1hdGlvblxuICAgKiBhYm91dCB0aGUgc3RhdGUgY2hhbmdlLiBUaGlzIGluY2x1ZGVzIHRoZSBcImV2ZW50LnN0YXRlXCIga2V5LFxuICAgKiB3aGljaCB3aWxsIGhhdmUgdGhlIGFwcHJvcHJpYXRlIHZhbHVlIGZyb20gdGhlIFJhdmlTZXNzaW9uU3RhdGVzIGVudW0uXG4gICAqL1xuICAvKipcbiAgICogQWRkIGEgaGFuZGxlciB0byB0aGUgc2V0IG9mIHN0YXRlIGNoYW5nZSBoYW5kbGVycy5cbiAgICogQWxsIGhhbmRsZXJzIGluIHRoaXMgc2V0IHdpbGwgYmUgdHJpZ2dlcmVkIHdpdGggYSBjb3B5IG9mIHRoZSBldmVudFxuICAgKiBhbnkgdGltZSB0aGUgc3RhdGUgb2YgdGhlIHNpZ25hbGluZyBjb25uZWN0aW9uIGNoYW5nZXMuXG4gICAqIFRoZXNlIGFyZSBzdG9yZWQgaW4gYSBTZXQgb2YgRnVuY3Rpb25zOyB0aGVyZWZvcmUsIGEgZ2l2ZW4gZnVuY3Rpb25cbiAgICogY2FuIG9ubHkgZXhpc3Qgb25jZSBpbiB0aGlzIFNldC5cbiAgICpcbiAgICogQHBhcmFtIHtSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbn5zdGF0ZUNoYW5nZUNhbGxiYWNrfSBoYW5kbGVyIEEgY2FsbGJhY2sgaGFuZGxlciB0aGF0IHNob3VsZCBoYW5kbGUgYSBzdGF0ZSBjaGFuZ2UgZXZlbnRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBhZGQgc3VjY2VlZGVkXG4gICAqL1xuICBhZGRTdGF0ZUNoYW5nZUhhbmRsZXIoY2hhbmdlSGFuZGxlcjogRnVuY3Rpb24pIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5fc3RhdGVDaGFuZ2VIYW5kbGVycy5hZGQoY2hhbmdlSGFuZGxlcik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIFJhdmlVdGlscy5lcnIoXCJFcnJvciBhZGRpbmcgYSBzdGF0ZSBjaGFuZ2UgaGFuZGxlcjogXCIgK1xuICAgICAgICBlcnIubWVzc2FnZSwgXCJSYXZpU2lnbmFsaW5nQ29ubmVjdGlvblwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGhhbmRsZXIgZnJvbSB0aGUgbGlzdCBvZiBzdGF0ZSBjaGFuZ2UgaGFuZGxlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb25+c3RhdGVDaGFuZ2VDYWxsYmFja30gaGFuZGxlciBBIGNhbGxiYWNrIGhhbmRsZXIgdGhhdCBoYXMgYmVlbiBoYW5kbGluZyBhIHN0YXRlIGNoYW5nZSBldmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIHJlbW92YWwgd2FzIHN1Y2Nlc3NmdWwgKGkuZS4gZGlkIG5vdCB0aHJvdyBhbiBlcnJvciAtLSBub3RlIHRoYXQgdGhpcyBkb2VzXG4gICAqIE5PVCBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciB3YXMgaW4gdGhlIHNldCBpbiB0aGUgZmlyc3QgcGxhY2UpXG4gICAqL1xuICByZW1vdmVTdGF0ZUNoYW5nZUhhbmRsZXIoY2hhbmdlSGFuZGxlcjogRnVuY3Rpb24pIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5fc3RhdGVDaGFuZ2VIYW5kbGVycy5kZWxldGUoY2hhbmdlSGFuZGxlcik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIFJhdmlVdGlscy5lcnIoXCJFcnJvciByZW1vdmluZyBhIHN0YXRlIGNoYW5nZSBoYW5kbGVyOiBcIiArXG4gICAgICAgIGVyci5tZXNzYWdlLCBcIlJhdmlTaWduYWxpbmdDb25uZWN0aW9uXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgZm9yIGxpc3RlbmluZyBmb3IgbWVzc2FnZXNcbiAgICogQGNhbGxiYWNrIFJhdmlTaWduYWxpbmdDb25uZWN0aW9ufm1lc3NhZ2VDYWxsYmFja1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBBIG1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyXG4gICAqL1xuICAvKipcbiAgICogQWRkIGEgaGFuZGxlciB0byB0aGUgbGlzdCBvZiBtZXNzYWdlIHJlY2VpdmVkIGhhbmRsZXJzLlxuICAgKiBBbGwgaGFuZGxlcnMgaW4gdGhpcyBsaXN0IHdpbGwgYmUgdHJpZ2dlcmVkIHdpdGggYSBjb3B5IG9mIHRoZSBcbiAgICogaW5jb21pbmcgbWVzc2FnZSBhbnkgdGltZSBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWQuXG4gICAqIFRoZXNlIGFyZSBzdG9yZWQgaW4gYSBTZXQgb2YgRnVuY3Rpb25zOyB0aGVyZWZvcmUsIGEgZ2l2ZW4gZnVuY3Rpb25cbiAgICogY2FuIG9ubHkgZXhpc3Qgb25jZSBpbiB0aGlzIFNldC5cbiAgICpcbiAgICogQHBhcmFtIHtSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbn5tZXNzYWdlQ2FsbGJhY2t9IGhhbmRsZXIgQSBjYWxsYmFjayBoYW5kbGVyIHRoYXQgc2hvdWxkIGhhbmRsZSBhIG1lc3NhZ2UgcmVjZWl2ZWQgZXZlbnRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBhZGQgc3VjY2VlZGVkXG4gICAqL1xuICBhZGRNZXNzYWdlSGFuZGxlcihtZXNzYWdlSGFuZGxlcjogRnVuY3Rpb24pIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5fbWVzc2FnZUhhbmRsZXJzLmFkZChtZXNzYWdlSGFuZGxlcik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIFJhdmlVdGlscy5lcnIoXCJFcnJvciBhZGRpbmcgYSBtZXNzYWdlIGhhbmRsZXI6IFwiICtcbiAgICAgICAgZXJyLm1lc3NhZ2UsIFwiUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb25cIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBoYW5kbGVyIGZyb20gdGhlIGxpc3Qgb2YgbWVzc2FnZSByZWNlaXZlZCBoYW5kbGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbn5tZXNzYWdlQ2FsbGJhY2t9IGhhbmRsZXIgQSBjYWxsYmFjayBoYW5kbGVyIHRoYXQgaGFzIGJlZW4gaGFuZGxpbmcgYSBtZXNzYWdlIHJlY2VpdmVkIGV2ZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgcmVtb3ZhbCB3YXMgc3VjY2Vzc2Z1bCAoaS5lLiBkaWQgbm90IHRocm93IGFuIGVycm9yIC0tIG5vdGUgdGhhdCB0aGlzIGRvZXNcbiAgICogTk9UIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIHdhcyBpbiB0aGUgc2V0IGluIHRoZSBmaXJzdCBwbGFjZSlcbiAgICovXG4gIHJlbW92ZU1lc3NhZ2VIYW5kbGVyKG1lc3NhZ2VIYW5kbGVyOiBGdW5jdGlvbikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlcnMuZGVsZXRlKG1lc3NhZ2VIYW5kbGVyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgUmF2aVV0aWxzLmVycihcIkVycm9yIHJlbW92aW5nIGEgc3RhdGUgY2hhbmdlIGhhbmRsZXI6IFwiICtcbiAgICAgICAgZXJyLm1lc3NhZ2UsIFwiUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb25cIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVuIGEgc2lnbmFsaW5nIGNvbm5lY3Rpb24gdG8gYSBwYXJ0aWN1bGFyIFVSTC4gUmV0dXJucyBhIFByb21pc2VcbiAgICogdGhhdCB3aWxsIHJlc29sdmUgd2l0aCB0aGUgc3RhdGUgb25jZSB0aGUgUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24gaXMgY29ubmVjdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gVVJMIFRoZSBVUkwgb2YgdGhlIHNpZ25hbGluZyBzZXJ2ZXIncyBlbmRwb2ludCAoZS5nLiAnd3NzOi8vZm9vLmJhci5iYXo6ODg4OScpXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgb3BlbihVUkw6IHN0cmluZykge1xuICAgIHZhciBzaWduYWxpbmdDb25uZWN0aW9uID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBSYXZpVXRpbHMubG9nKFwiT3BlbmluZyBzaWduYWxpbmcgY29ubmVjdGlvbiB0byBcIiArIFVSTCwgXCJSYXZpU2lnbmFsaW5nQ29udHJvbGxlclwiKTtcbiAgICAgIC8vIEFkZCBhIHN0YXRlIGNoYW5nZSBoYW5kbGVyIHRoYXQgd2lsbCByZXNvbHZlIHRoZVxuICAgICAgLy8gcHJvbWlzZSB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIG9wZW5cbiAgICAgIGNvbnN0IHN0YXRlSGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gXCJcIjtcbiAgICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50LnN0YXRlKSBzdGF0ZSA9IGV2ZW50LnN0YXRlO1xuXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gU2lnbmFsaW5nU3RhdGVzLkNPTk5FQ1RJTkcpIHtcbiAgICAgICAgICBSYXZpVXRpbHMubG9nKFwiQ29ubmVjdGluZy4uLlwiLCBcIlJhdmlTaWduYWxpbmdDb250cm9sbGVyXCIpXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IFNpZ25hbGluZ1N0YXRlcy5PUEVOKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIHRoaXMgYXMgYSBzdGF0ZSBjaGFuZ2UgaGFuZGxlclxuICAgICAgICAgIHNpZ25hbGluZ0Nvbm5lY3Rpb24ucmVtb3ZlU3RhdGVDaGFuZ2VIYW5kbGVyKHN0YXRlSGFuZGxlcik7XG4gICAgICAgICAgLy8gYW5kIHJlc29sdmUgdGhlIFByb21pc2VcbiAgICAgICAgICByZXNvbHZlKHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZW1vdmUgdGhpcyBhcyBhIHN0YXRlIGNoYW5nZSBoYW5kbGVyXG4gICAgICAgICAgc2lnbmFsaW5nQ29ubmVjdGlvbi5yZW1vdmVTdGF0ZUNoYW5nZUhhbmRsZXIoc3RhdGVIYW5kbGVyKTtcbiAgICAgICAgICAvLyBhbmQgcmVqZWN0IHRoZSBQcm9taXNlXG4gICAgICAgICAgcmVqZWN0KGV2ZW50LmVycm9yIHx8IG5ldyBFcnJvcihldmVudC5tZXNzYWdlIHx8IHN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNpZ25hbGluZ0Nvbm5lY3Rpb24uYWRkU3RhdGVDaGFuZ2VIYW5kbGVyKHN0YXRlSGFuZGxlcik7XG4gICAgICAvLyBBbmQgdGhlbiBhbGVydCBhYm91dCB0aGUgXCJvcGVuaW5nXCIgcHJvY2Vzc1xuICAgICAgdmFyIGV2ZW50ID0ge1wic3RhdGVcIjpTaWduYWxpbmdTdGF0ZXMuQ09OTkVDVElOR307XG4gICAgICB0aGlzLl9oYW5kbGVTdGF0ZUNoYW5nZShldmVudCwgU2lnbmFsaW5nU3RhdGVzLkNPTk5FQ1RJTkcpOyBcbiAgICAgIC8vIEFuZCBjYWxsIHRoZSBpbXBsZW1lbnRhdGlvbidzIG9wZW4gbWV0aG9kXG4gICAgICB0aGlzLl9zaWduYWxpbmdJbXBsZW1lbnRhdGlvbi5fb3BlbihVUkwpO1xuICAgIH0pO1xuICB9XG4gIFxuICAvKipcbiAgICogU2VuZCBhIG1lc3NhZ2UgdG8gdGhlIHNpZ25hbGluZyBzZXJ2ZXJcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKi9cbiAgc2VuZChtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9zaWduYWxpbmdJbXBsZW1lbnRhdGlvbi5fc2VuZChtZXNzYWdlKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIENsb3NlIHRoZSBzaWduYWxpbmcgY29ubmVjdGlvbi4gUmV0dXJucyBhIFByb21pc2VcbiAgICogdGhhdCB3aWxsIHJlc29sdmUgd2l0aCB0aGUgY2xvc2VkIHN0YXRlIG9uY2UgdGhlIFJhdmlTaWduYWxpbmdDb25uZWN0aW9uIGlzIGNsb3NlZC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICB2YXIgc2lnbmFsaW5nQ29ubmVjdGlvbiA9IHRoaXM7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgUmF2aVV0aWxzLmxvZyhcIkNsb3Npbmcgc2lnbmFsaW5nIGNvbm5lY3Rpb25cIik7XG4gICAgICAvLyBBZGQgYSBzdGF0ZSBjaGFuZ2UgaGFuZGxlciB0aGF0IHdpbGwgcmVzb2x2ZSB0aGVcbiAgICAgIC8vIHByb21pc2Ugd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBjbG9zZWRcbiAgICAgIGNvbnN0IHN0YXRlSGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gXCJcIjtcbiAgICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50LnN0YXRlKSBzdGF0ZSA9IGV2ZW50LnN0YXRlO1xuXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gU2lnbmFsaW5nU3RhdGVzLkNMT1NJTkcpIHtcbiAgICAgICAgICBSYXZpVXRpbHMubG9nKFwiQ2xvc2luZy4uLlwiLCBcIlJhdmlTaWduYWxpbmdDb25uZWN0aW9uXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBTaWduYWxpbmdTdGF0ZXMuQ0xPU0VEKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIHRoaXMgYXMgYSBzdGF0ZSBjaGFuZ2UgaGFuZGxlclxuICAgICAgICAgIHNpZ25hbGluZ0Nvbm5lY3Rpb24ucmVtb3ZlU3RhdGVDaGFuZ2VIYW5kbGVyKHN0YXRlSGFuZGxlcik7XG4gICAgICAgICAgLy8gYW5kIHJlc29sdmUgdGhlIFByb21pc2VcbiAgICAgICAgICByZXNvbHZlKHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZW1vdmUgdGhpcyBhcyBhIHN0YXRlIGNoYW5nZSBoYW5kbGVyXG4gICAgICAgICAgc2lnbmFsaW5nQ29ubmVjdGlvbi5yZW1vdmVTdGF0ZUNoYW5nZUhhbmRsZXIoc3RhdGVIYW5kbGVyKTtcbiAgICAgICAgICAvLyBhbmQgcmVqZWN0IHRoZSBQcm9taXNlXG4gICAgICAgICAgcmVqZWN0KEVycm9yKHN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNpZ25hbGluZ0Nvbm5lY3Rpb24uYWRkU3RhdGVDaGFuZ2VIYW5kbGVyKHN0YXRlSGFuZGxlcik7XG4gICAgICAvLyBBbmQgdGhlbiBzdGFydCB0aGUgXCJjbG9zaW5nXCIgcHJvY2Vzc1xuICAgICAgdmFyIGV2ZW50ID0ge1wic3RhdGVcIjpTaWduYWxpbmdTdGF0ZXMuQ0xPU0lOR307XG4gICAgICB0aGlzLl9oYW5kbGVTdGF0ZUNoYW5nZShldmVudCwgU2lnbmFsaW5nU3RhdGVzLkNMT1NJTkcpOyBcbiAgICAgIC8vIEFuZCBjYWxsIHRoZSBpbXBsZW1lbnRhdGlvbidzIGNsb3NlIG1ldGhvZFxuICAgICAgdGhpcy5fc2lnbmFsaW5nSW1wbGVtZW50YXRpb24uX2Nsb3NlKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogR2VuZXJpYyBoYW5kbGVycyAqL1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2hhbmRsZVN0YXRlQ2hhbmdlKGV2ZW50OiBhbnksIHN0YXRlOiBhbnkpIHtcbiAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgIGV2ZW50W1wic3RhdGVcIl0gPSBzdGF0ZTtcbiAgICBSYXZpVXRpbHMubG9nKFwiX2hhbmRsZVN0YXRlQ2hhbmdlOiBcIiArIFJhdmlVdGlscy5zYWZlbHlQcmludGFibGUoZXZlbnQpLCBcIlJhdmlTaWduYWxpbmdDb25uZWN0aW9uXCIpO1xuICAgIHRoaXMuX3N0YXRlQ2hhbmdlSGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICBoYW5kbGVyKGV2ZW50KTsgXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2hhbmRsZU1lc3NhZ2UobWVzc2FnZTogYW55KSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcIl9kb09ubWVzc2FnZTogXCIgKyBSYXZpVXRpbHMuc2FmZWx5UHJpbnRhYmxlKG1lc3NhZ2UpLCBcIlJhdmlTaWduYWxpbmdDb25uZWN0aW9uXCIpO1xuICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgZm9yIHdoZW4gdGhlIHNlcnZlciBzaWRlIGlzIGluIGFuIFwidW5hdmFpbGFibGVcIiBzdGF0ZSAtLSBpdCB3aWxsXG4gICAgLy8gc2VuZCBiYWNrIGEgc3BlY2lhbCBKU09OIHBhY2tldCBtYXJraW5nIGl0c2VsZiBhcyBcInNlcnZpY2UtdW5hdmFpbGFibGVcIi4gSGFuZGxlIHRoaXMgc2l0dWF0aW9uXG4gICAgLy8gZXhwbGljaXRseSBhcyBhIGN1c3RvbSBzdGF0ZS4gKFRoaXMgaXMga2luZCBvZiBhIGxvdCBvZiBjb2RlIGZvciBhIHJhcmUgb2NjdXJyZW5jZSwgYnV0IHdlXG4gICAgLy8gZG9uJ3Qgc2VuZCBhIHRvbiBvZiBtZXNzYWdlcyBvdmVyIHRoZSBzaWduYWxpbmcgY29ubmVjdGlvbiBhbmQgc28gSSBmZWVsIHJlYXNvbmFibHkgb2theSBhYm91dFxuICAgIC8vIGRvaW5nIHRoaXMgY2hlY2sgb24gZXZlcnkgbWVzc2FnZS4gLU1DSCkpXG4gICAgaWYgKG1lc3NhZ2UuZGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2VEYXRhID0gSlNPTi5wYXJzZShtZXNzYWdlLmRhdGEpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2VEYXRhLmVycm9yICYmIG1lc3NhZ2VEYXRhLmVycm9yID09IFwic2VydmljZS11bmF2YWlsYWJsZVwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlU3RhdGVDaGFuZ2Uoe30sIFNpZ25hbGluZ1N0YXRlcy5VTkFWQUlMQUJMRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBjYW4ndCBwYXJzZSB0aGUgbWVzc2FnZSBhcyBKU09OLCBpdCdzIGRlZmluaXRlbHlcbiAgICAgICAgICAgIC8vIG5vdCB0aGUgXCJ1bmF2YWlsYWJsZVwiIG1lc3NhZ2UgYW5kIHByb2JhYmx5IG1lYW50IGZvciBzb21lb25lIGVsc2UsXG4gICAgICAgICAgICAvLyBzbyBuby1vcCBoZXJlIGFuZCBqdXN0IGxldCB0aGUgcmVzdCBvZiB0aGUgY29kZSBkZWFsIHdpdGggaXQuXG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbWVzc2FnZUhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgaGFuZGxlcihtZXNzYWdlKTsgXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgXG59IC8vIEVuZCBvZiBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbi8qXG5UT0RPOiBBZGQgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBhIFJhdmlTaWduYWxpbmcgXCJjb25uZWN0aW9uIGltcGxlbWVudGF0aW9uXCJcbmNsYXNzIHNob3VsZCBsb29rIGxpa2UuXG5cbkNvbnN0cnVjdG9yOiB0YWtlcyBhIFJhdmlTaWduYWxpbmdDb25uZWN0aW9uIHNvIHRoYXQgaXQgY2FuIHVzZSBpdHMgaGFuZGxlcnMuIFRoZSBjbGFzc1xuaXMgZXhwZWN0ZWQgdG8gYXNzaWduIHRoZSBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbidzIF9oYW5kbGVTdGF0ZUNoYW5nZShldmVudCwgc3RhdGUpIGFuZCBfaGFuZGxlTWVzc2FnZShtZXNzYWdlKVxuaGFuZGxlcnMgdG8gYXBwcm9wcmlhdGUgZXZlbnRzIChhbmQvb3IgdGhyb3cgdGhvc2UgZXZlbnRzIGl0c2VsZikuXG5cblJlcXVpcmVkIG1ldGhvZHM6IF9vcGVuKFVSTCksIF9zZW5kKG1lc3NhZ2UpLCBhbmQgX2Nsb3NlKClcblxuKi9cblxuLyoqXG4gKiBVc2UgdGhlIGNvcnJlY3QgY2xhc3NlcyBkZXBlbmRpbmcgb24gd2hldGhlciB3ZSdyZSBiZWluZyBcbiAqIGNhbGxlZCBmcm9tIG5vZGUgb3IgdGhlIGJyb3dzZXIuXG4gKi9cbmxldCBjcm9zc1BsYXRmb3JtV2ViU29ja2V0OmFueSA9IG51bGw7XG5pZiAodHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIG5vZGUgY29udGV4dFxuICBjcm9zc1BsYXRmb3JtV2ViU29ja2V0ID0gcmVxdWlyZSgnd3MnKTtcbn0gZWxzZSB7XG4gIC8vIGJyb3dzZXIgY29udGV4dFxuICBjcm9zc1BsYXRmb3JtV2ViU29ja2V0ID0gV2ViU29ja2V0O1xufVxuXG4vKiogXG4gKiBBIFdlYlNvY2tldCBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIFJhdmlTaWduYWxpbmcgY2xhc3NcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFJhdmlTaWduYWxpbmdXZWJTb2NrZXRJbXBsZW1lbnRhdGlvbiB7XG4gIF9yYXZpU2lnbmFsaW5nQ29ubmVjdGlvbjogUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb247XG4gIF93ZWJTb2NrZXQ6IGFueTtcbiAgXG4gIC8qKlxuICAgKiBcIkNsYXNzXCIgdmFyaWFibGVzIHRvIGJlIGF3YXJlIG9mOlxuICAgKiB0aGlzLl93ZWJTb2NrZXQgICAgICAvLyBUaGUgYWN0dWFsIGNvbm5lY3RlZCB3ZWIgc29ja2V0XG4gICAqIHRoaXMuX3JhdmlTaWduYWxpbmdDb25uZWN0aW9uIC8vIHRoZSBcInBhcmVudFwiIHNpZ25hbGluZyBjb25uZWN0aW9uXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgUmF2aVNpZ25hbGluZ1dlYlNvY2tldEltcGxlbWVudGF0aW9uXG4gICAqIEBwYXJhbSB7UmF2aVNlc3Npb259IHJhdmlTZXNzaW9uIFRoZSBvd25lciBvZiB0aGlzIFJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJhdmlTaWduYWxpbmdDb25uZWN0aW9uOiBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbikge1xuICAgIFJhdmlVdGlscy5sb2coXCJjb25zdHJ1Y3RvclwiLCBcIlJhdmlTaWduYWxpbmdXZWJTb2NrZXRJbXBsZW1lbnRhdGlvblwiKTtcbiAgICB0aGlzLl9yYXZpU2lnbmFsaW5nQ29ubmVjdGlvbiA9IHJhdmlTaWduYWxpbmdDb25uZWN0aW9uO1xuICB9XG4gIFxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vcGVuKHNvY2tldEFkZHJlc3M6IHN0cmluZykge1xuICAgIHRoaXMuX3dlYlNvY2tldCA9IG5ldyBjcm9zc1BsYXRmb3JtV2ViU29ja2V0KHNvY2tldEFkZHJlc3MpO1xuXG4gICAgLy8gVGhlIFdlYlNvY2tldCdzIG9wZW4sIGVycm9yLCBhbmQgY2xvc2UgZXZlbnRzIHdpbGwganVzdFxuICAgIC8vIGNhbGwgYmFjayB1cCB0byB0aGUgbWFpbiBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbidzIFxuICAgIC8vIHN0YXRlQ2hhbmdlSGFuZGxlcnMuXG4gICAgLy8gKFdlIGNhbid0IHNldCB0aGVzZSB1bnRpbCB3ZSBhdHRlbXB0IHRvIG9wZW4gdGhlXG4gICAgLy8gV2ViU29ja2V0LCBiZWNhdXNlIHRoZXJlJ3Mgbm8gb3RoZXIgV2ViU29ja2V0IGNvbnN0cnVjdG9yLilcbiAgICB2YXIgc2lnbmFsaW5nQ29ubmVjdGlvbiA9IHRoaXMuX3JhdmlTaWduYWxpbmdDb25uZWN0aW9uO1xuICAgIHRoaXMuX3dlYlNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgZnVuY3Rpb24oZXZlbnQ6IGFueSkgeyBzaWduYWxpbmdDb25uZWN0aW9uLl9oYW5kbGVTdGF0ZUNoYW5nZShldmVudCwgU2lnbmFsaW5nU3RhdGVzLk9QRU4pOyB9KTtcbiAgICB0aGlzLl93ZWJTb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbihldmVudDogYW55KSB7IHNpZ25hbGluZ0Nvbm5lY3Rpb24uX2hhbmRsZVN0YXRlQ2hhbmdlKGV2ZW50LCBTaWduYWxpbmdTdGF0ZXMuRVJST1IpOyB9KTtcbiAgICB0aGlzLl93ZWJTb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBmdW5jdGlvbihldmVudDogYW55KSB7IHNpZ25hbGluZ0Nvbm5lY3Rpb24uX2hhbmRsZVN0YXRlQ2hhbmdlKGV2ZW50LCBTaWduYWxpbmdTdGF0ZXMuQ0xPU0VEKTsgfSk7XG5cbiAgICAvLyBBbnkgYWRkaXRpb25hbCBtZXNzYWdpbmcgaGFuZGxpbmcgZ2V0cyBkb25lIGJ5IHRoZSBtYWluXG4gICAgLy8gUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24ncyBtZXNzYWdlSGFuZGxlcnNcbiAgICB0aGlzLl93ZWJTb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHsgc2lnbmFsaW5nQ29ubmVjdGlvbi5faGFuZGxlTWVzc2FnZShldmVudCk7IH0pO1xuICB9XG4gIFxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZW5kKG1lc3NhZ2U6IGFueSkge1xuICAgIGlmICh0aGlzLl93ZWJTb2NrZXQgJiYgdGhpcy5fd2ViU29ja2V0LnJlYWR5U3RhdGUgPT09IGNyb3NzUGxhdGZvcm1XZWJTb2NrZXQuT1BFTikge1xuICAgICAgICBSYXZpVXRpbHMubG9nKFwiU2VuZGluZyBtZXNzYWdlIHRvIHNlcnZlcjogXCIgKyBtZXNzYWdlLCBcIlJhdmlTaWduYWxpbmdXZWJTb2NrZXRJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgdGhpcy5fd2ViU29ja2V0LnNlbmQobWVzc2FnZSk7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jbG9zZSgpIHtcbiAgICBpZiAodGhpcy5fd2ViU29ja2V0KSB7XG4gICAgICB0aGlzLl93ZWJTb2NrZXQuY2xvc2UoKTtcbiAgICAgIHRoaXMuX3dlYlNvY2tldCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLlNpZ25hbGluZ1N0YXRlcyA9IFNpZ25hbGluZ1N0YXRlcztcbiIsImltcG9ydCB7IFJhdmlDb21tYW5kQ29udHJvbGxlciB9IGZyb20gXCIuL1JhdmlDb21tYW5kQ29udHJvbGxlclwiO1xuXG5jb25zdCB7IFJhdmlVdGlscyB9ID0gcmVxdWlyZSgnLi9SYXZpVXRpbHMnKTtcblxuLyoqIFxuICogQGNsYXNzXG4gKiBAY2xhc3NkZXNjIEhhbmRsZXMgaW50ZXJhY3Rpbmcgd2l0aCBtZWRpYSBzdHJlYW1zIGZvciBSQVZJIHNlc3Npb25zLlxuICogVGhpcyBjbGFzcyBpcyBwcm92aWRlZCBieSBhIHtAbGluayBSYXZpU2Vzc2lvbn0gYW5kIHNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LlxuICpcbiAqIEV4YW1wbGUgdXNhZ2UgKHNldHRpbmcgYW4gYXVkaW8gb3V0cHV0IGNvbnRhaW5lcik6IFxuICogXG4gKiBgYGBcbiAqIHZhciBzdHJlYW1Db250cm9sbGVyID0gcmF2aVNlc3Npb24uZ2V0U3RyZWFtQ29udHJvbGxlcigpO1xuICogc3RyZWFtQ29udHJvbGxlci5zZXRBdWRpb0NvbnRhaW5lcihkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVtb3RlQXVkaW8nKSk7XG4gKmBgYFxuICogICBcbiAqL1xuZXhwb3J0IGNsYXNzIFJhdmlTdHJlYW1Db250cm9sbGVyIHtcbiAgX2NvbW1hbmRDb250cm9sbGVyOiBSYXZpQ29tbWFuZENvbnRyb2xsZXI7XG4gIF9hdWRpb1N0cmVhbTogTWVkaWFTdHJlYW07XG4gIF92aWRlb1N0cmVhbTogTWVkaWFTdHJlYW07XG4gIF9vblZpZGVvU3RyZWFtU3RhdGVDaGFuZ2VkOiBGdW5jdGlvbjtcbiAgX29uSW5wdXRBdWRpb0NoYW5nZWQ6IEZ1bmN0aW9uO1xuICBfb25JbnB1dFZpZGVvQ2hhbmdlZDogRnVuY3Rpb247XG4gIF92aWRlb0NvbnRhaW5lcjogSFRNTFZpZGVvRWxlbWVudDtcbiAgX2F1ZGlvQ29udGFpbmVyOiBIVE1MQXVkaW9FbGVtZW50O1xuICBfaW5wdXRBdWRpb1N0cmVhbTogTWVkaWFTdHJlYW07XG4gIF9pc1N0ZXJlbzogYm9vbGVhbjtcbiAgX2lucHV0VmlkZW9TdHJlYW06IE1lZGlhU3RyZWFtO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgUkFWSSBzdHJlYW0gY29udHJvbGxlci4gXG4gICAqIE5lZWRzIGFjY2VzcyB0byBhIFJhdmlDb21tYW5kQ29udHJvbGxlciBzbyBpdCBjYW4gc2VuZCB2aWRlby1yZWxhdGVkIGNvbW1hbmRzLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJhdmlDb21tYW5kQ29udHJvbGxlcjogUmF2aUNvbW1hbmRDb250cm9sbGVyKSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcImNvbnN0cnVjdG9yXCIsIFwiUmF2aVN0cmVhbUNvbnRyb2xsZXJcIik7XG4gICAgdGhpcy5fY29tbWFuZENvbnRyb2xsZXIgPSByYXZpQ29tbWFuZENvbnRyb2xsZXI7XG4gICAgXG4gICAgLy8gVGhlIGF1ZGlvIHN0cmVhbSBhbmQgdmlkZW8gc3RyZWFtIGdldCBzZXQgYnkgdGhlIFJhdmlTZXNzaW9uIHdoZW4gdGhlXG4gICAgLy8gYXBwcm9wcmlhdGUgZXZlbnRzIGFyZSByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXJcbiAgICB0aGlzLl9hdWRpb1N0cmVhbSA9IG51bGw7XG4gICAgdGhpcy5fdmlkZW9TdHJlYW0gPSBudWxsO1xuICAgIFxuICAgIC8vIERlZmF1bHQgZm9yIHRoZSB2aWRlbyBzdHJlYW0gc3RhdGUgY2hhbmdlIGhhbmRsZXJcbiAgICB0aGlzLl9vblZpZGVvU3RyZWFtU3RhdGVDaGFuZ2VkID0gZnVuY3Rpb24gKHN0YXRlOiBhbnkpIHsgUmF2aVV0aWxzLmxvZyhcIm9udmlkZW9zdHJlYW1zdGF0ZWNoYW5nZWQgXCIgKyBzdGF0ZSwgXCJSYXZpU3RyZWFtQ29udHJvbGxlclwiKTt9XG4gICAgLy8gRGVmYXVsdCBmb3IgdGhlIGlucHV0IGF1ZGlvIHN0cmVhbSBjaGFuZ2UgaGFuZGxlclxuICAgIHRoaXMuX29uSW5wdXRBdWRpb0NoYW5nZWQgPSBudWxsO1xuICAgIHRoaXMuX29uSW5wdXRWaWRlb0NoYW5nZWQgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSBzdHJlYW0gY29udHJvbGxlciBpcyBhd2FyZSBvZiBhIHZpZGVvIHN0cmVhbSBjb21pbmcgZnJvbSB0aGUgUkFWSSBzZXJ2ZXIsIFxuICAgKiByZXR1cm4gaXQuIFJldHVybnMgbnVsbCBpZiB0aGVyZSBpcyBubyB2aWRlbyBzdHJlYW0gYXZhaWxhYmxlLlxuICAgKiBAcmV0dXJucyB7TWVkaWFTdHJlYW19XG4gICAqL1xuICBnZXRWaWRlb1N0cmVhbSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlkZW9TdHJlYW07XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBTZXQgYSB2aWRlbyBzdHJlYW0gZm9yIHRoaXMgc3RyZWFtIGNvbnRyb2xsZXIuIElmIHRoZXJlIGlzIGFsc28gYSB2aWRlbyBjb250YWluZXJcbiAgICogc2V0LCB0aGlzIHdpbGwgYXR0YWNoIHRoZSBzdHJlYW0gdG8gdGhhdCB2aWRlbyBjb250YWluZXIgYXMgd2VsbC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRWaWRlb1N0cmVhbSh2aWRlb1N0cmVhbTogTWVkaWFTdHJlYW0pIHtcbiAgICB0aGlzLl92aWRlb1N0cmVhbSA9IHZpZGVvU3RyZWFtO1xuICAgIGlmICh0aGlzLl92aWRlb0NvbnRhaW5lcikge1xuICAgICAgdGhpcy5fdmlkZW9Db250YWluZXIuc3JjT2JqZWN0ID0gdGhpcy5fdmlkZW9TdHJlYW07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZvciBsaXN0ZW5pbmcgdG8gdmlkZW8gc3RyZWFtIHN0YXRlIGNoYW5nZXNcbiAgICogQGNhbGxiYWNrIFJhdmlTdHJlYW1Db250cm9sbGVyfnZpZGVvU3RhdGVDaGFuZ2VDYWxsYmFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgQW4gb2JqZWN0IHRoYXQgd2lsbCBjb250YWluIGluZm9ybWF0aW9uXG4gICAqIGFib3V0IHRoZSBzdGF0ZSBjaGFuZ2UuIFxuICAgKiBUT0RPOiBMaXN0IHRoZSBwb3NzaWJsZSBzdGF0ZXMuIFxuICAgKi9cbiAgLyoqXG4gICAqIFNldCB0aGUgRE9NIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBkaXNwbGF5IGluY29taW5nIFJBVkkgdmlkZW9cbiAgICogQSBjYWxsYmFjayBoYW5kbGVyIGNhbiBhbHNvIGJlIHNwZWNpZmllZCB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSB2aWRlbyBzdHJlYW0gY2hhbmdlIHN0YXRlXG4gICAqIFRoaXMgY2FsbCBtdXN0IGhhcHBlbiBiZWZvcmUgc3RhcnRpbmcgYSBzZXNzaW9uIGFuZCB0aGUgdmlkZW8gZWxlbWVudCBpcyBpbW11dGFibGVcbiAgICogQHBhcmFtIHtIVE1MVmlkZW9FbGVtZW50fSB2aWRlb0VsZW1lbnQgUmVmZXJlbmNlIHRvIHRoZSBKYXZhU2NyaXB0IERPTSBlbGVtZW50IGluIHdoaWNoIHRvIGRpc3BsYXkgdmlkZW8uIFxuICAgKiBJdCBpcyBleHBlY3RlZCB0aGF0IHRoaXMgZWxlbWVudCBpcyBhIFwidmlkZW9cIiBlbGVtZW50LiBXaGVuIGEgdmlkZW8gdHJhY2sgaXMgb2J0YWluZWRcbiAgICogZnJvbSB0aGUgUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uLCB0aGlzIGVsZW1lbnQncyBzcmNPYmplY3Qgd2lsbCBiZSBzZXQgYWNjb3JkaW5nbHkuXG4gICAqIEBwYXJhbSB7UmF2aVN0cmVhbUNvbnRyb2xsZXJ+dmlkZW9TdGF0ZUNoYW5nZUNhbGxiYWNrfSBvbnZpZGVvc3RyZWFtc3RhdGVjaGFuZ2VkIE9wdGlvbmFsIGNhbGxiYWNrIHRvIGNhdGNoIGNoYW5nZXMgb2YgdGhlIHZpZGVvIHN0cmVhbSBjaGFuZ2Ugc3RhdGVzLlxuICAgKi9cbiAgc2V0VmlkZW9Db250YWluZXIodmlkZW9FbGVtZW50OiBIVE1MVmlkZW9FbGVtZW50LCBvbnZpZGVvc3RyZWFtc3RhdGVjaGFuZ2VkOiBGdW5jdGlvbikge1xuICAgIHRoaXMuX3ZpZGVvQ29udGFpbmVyID0gdmlkZW9FbGVtZW50O1xuICAgIC8vIElmIHRoZXJlJ3MgYWxyZWFkeSBiZWVuIGEgdmlkZW8gc3RyZWFtIGFzc2lnbmVkLCBhdHRhY2ggaXRcbiAgICBpZiAodGhpcy5fdmlkZW9TdHJlYW0pIHtcbiAgICAgIHRoaXMuX3ZpZGVvQ29udGFpbmVyLnNyY09iamVjdCA9IHRoaXMuX3ZpZGVvU3RyZWFtO1xuICAgIH1cbiAgICB0aGlzLnNldFZpZGVvU3RhdGVDaGFuZ2VIYW5kbGVyKG9udmlkZW9zdHJlYW1zdGF0ZWNoYW5nZWQpO1xuICB9XG4gIFxuICAvKipcbiAgICogQXNzaWduIGEgY2FsbGJhY2sgaGFuZGxlciBmb3Igd2hlbiB0aGUgdmlkZW8gc3RyZWFtIHN0YXRlIGNoYW5nZXNcbiAgICogQHBhcmFtIHtSYXZpU3RyZWFtQ29udHJvbGxlcn52aWRlb1N0YXRlQ2hhbmdlQ2FsbGJhY2t9IG9udmlkZW9zdHJlYW1zdGF0ZWNoYW5nZWQgQ2FsbGJhY2sgdG8gY2F0Y2ggY2hhbmdlcyBvZiB0aGUgdmlkZW8gc3RyZWFtIGNoYW5nZSBzdGF0ZXMuXG4gICAqL1xuICBzZXRWaWRlb1N0YXRlQ2hhbmdlSGFuZGxlcihvbnZpZGVvc3RyZWFtc3RhdGVjaGFuZ2VkOiBGdW5jdGlvbikge1xuICAgIGlmIChvbnZpZGVvc3RyZWFtc3RhdGVjaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9vblZpZGVvU3RyZWFtU3RhdGVDaGFuZ2VkID0gb252aWRlb3N0cmVhbXN0YXRlY2hhbmdlZDtcbiAgICB9IFxuICB9XG5cbiAgLyoqXG4gICAqIFRlbGwgdGhlIFJBVkkgc2VydmVyIHRvIGluY2x1ZGUgdGhlIHZpZGVvIFwiZGFzaGJvYXJkXCIgYXMgcGFydCBvZiB0aGUgdmlkZW8gc3RyZWFtLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgVHJ1ZSBvciBmYWxzZSwgdG8gc2hvdyBvciBub3Qgc2hvdyB0aGUgZGFzaGJvYXJkLlxuICAgKi9cbiAgc2hvd1ZpZGVvRGFzaGJvYXJkKGVuYWJsZWQ6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9jb21tYW5kQ29udHJvbGxlci5xdWV1ZUNvbW1hbmQoXCJ2aWRlby5zaG93RGFzaGJvYXJkXCIsIHtcImVuYWJsZWRcIjogZW5hYmxlZH0sIG51bGwpO1xuICB9XG4gIC8qKlxuICAgKiBUZWxsIHRoZSBSQVZJIHNlcnZlciB0byBpbmNsdWRlIGEgXCJyZW1vdGUgY3Vyc29yXCIgYXMgcGFydCBvZiB0aGUgdmlkZW8gc3RyZWFtLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgVHJ1ZSBvciBmYWxzZSwgdG8gc2hvdyBvciBub3Qgc2hvdyB0aGUgcmVtb3RlIGN1cnNvci5cbiAgICovXG4gIHNob3dWaWRlb0N1cnNvcihlbmFibGVkOiBib29sZWFuKSB7XG4gICAgdGhpcy5fY29tbWFuZENvbnRyb2xsZXIucXVldWVDb21tYW5kKFwidmlkZW8uc2hvd0N1cnNvclwiLCB7XCJlbmFibGVkXCI6IGVuYWJsZWR9LCBudWxsKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIElmIHRoZSBzdHJlYW0gY29udHJvbGxlciBpcyBhd2FyZSBvZiBhbiBhdWRpbyBzdHJlYW0gY29taW5nIGZyb20gdGhlIFJBVkkgc2VydmVyLCBcbiAgICogcmV0dXJuIGl0LiBSZXR1cm5zIG51bGwgaWYgdGhlcmUgaXMgbm8gYXVkaW8gc3RyZWFtIGF2YWlsYWJsZS5cbiAgICogQHJldHVybnMge01lZGlhU3RyZWFtfVxuICAgKi9cbiAgZ2V0QXVkaW9TdHJlYW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1ZGlvU3RyZWFtO1xuICB9XG4gIFxuICAvKipcbiAgICogU2V0IGFuIGF1ZGlvIHN0cmVhbSBmb3IgdGhpcyBzdHJlYW0gY29udHJvbGxlci4gSWYgdGhlcmUgaXMgYWxzbyBhbiBhdWRpbyBjb250YWluZXJcbiAgICogc2V0LCB0aGlzIHdpbGwgYXR0YWNoIHRoZSBzdHJlYW0gdG8gdGhhdCBhdWRpbyBjb250YWluZXIgYXMgd2VsbC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRBdWRpb1N0cmVhbShhdWRpb1N0cmVhbTogTWVkaWFTdHJlYW0pIHtcbiAgICB0aGlzLl9hdWRpb1N0cmVhbSA9IGF1ZGlvU3RyZWFtO1xuICAgIGlmICh0aGlzLl9hdWRpb0NvbnRhaW5lcikge1xuICAgICAgdGhpcy5fYXVkaW9Db250YWluZXIuc3JjT2JqZWN0ID0gdGhpcy5fYXVkaW9TdHJlYW07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgRE9NIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBwbGF5IGluY29taW5nIFJBVkkgYXVkaW9cbiAgICogQHBhcmFtIHtFbGVtZW50fSBhdWRpb0VsZW1lbnQgUmVmZXJlbmNlIHRvIHRoZSBKYXZhU2NyaXB0IERPTSBlbGVtZW50IGluIHdoaWNoIHRvIHBsYXkgYXVkaW9cbiAgICogc2VudCBmcm9tIHRoZSByZW1vdGUgUkFWSSBzZXJ2ZXIuIFxuICAgKiBJdCBpcyBleHBlY3RlZCB0aGF0IHRoaXMgZWxlbWVudCBpcyBhbiBcImF1ZGlvXCIgZWxlbWVudC4gV2hlbiBhbiBhdWRpbyB0cmFjayBpcyBvYnRhaW5lZFxuICAgKiBmcm9tIHRoZSBSYXZpV2ViUlRDSW1wbGVtZW50YXRpb24sIHRoaXMgZWxlbWVudCdzIHNyY09iamVjdCB3aWxsIGJlIHNldCBhY2NvcmRpbmdseS5cbiAgICovXG4gIHNldEF1ZGlvQ29udGFpbmVyKGF1ZGlvRWxlbWVudDogSFRNTEF1ZGlvRWxlbWVudCkge1xuICAgIHRoaXMuX2F1ZGlvQ29udGFpbmVyID0gYXVkaW9FbGVtZW50O1xuICAgIC8vIElmIHRoZXJlJ3MgYWxyZWFkeSBiZWVuIGFuIGF1ZGlvIHN0cmVhbSBhc3NpZ25lZCwgYXR0YWNoIGl0XG4gICAgaWYgKHRoaXMuX2F1ZGlvU3RyZWFtKSB7XG4gICAgICB0aGlzLl9hdWRpb0NvbnRhaW5lci5zcmNPYmplY3QgPSB0aGlzLl9hdWRpb1N0cmVhbTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzdHJlYW0gdGhhdCBzaG91bGQgYmUgdXNlZCB0byBzZW5kIFJBVkkgYXVkaW8uXG4gICAqIFxuICAgKiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiBgYGBcbiAgICogICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7IGF1ZGlvOiB0cnVlLCB2aWRlbzogZmFsc2UgfSlcbiAgICogICAgIC50aGVuKGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgKiAgICAgc3RyZWFtQ29udHJvbGxlci5zZXRJbnB1dEF1ZGlvKHN0cmVhbSk7XG4gICAqICAgfSlcbiAgICogIFxuICAgKmBgYFxuICAgKiBJZiB0aGVyZSBpcyBhIGNhbGxiYWNrIGFzc2lnbmVkIHZpYSBzZXRJbnB1dEF1ZGlvQ2hhbmdlSGFuZGxlcigpLFxuICAgKiBpdCB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuIHRoaXMgc3RyZWFtIGlzIHNldC5cbiAgICogXG4gICAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IHN0cmVhbSBUaGUgYXVkaW8gc3RyZWFtIGJlaW5nIHVzZWQgdG8gY2FwdHVyZSBsb2NhbCBtZWRpYS5cbiAgICogR2VuZXJhbGx5IHRoaXMgd2lsbCBiZSByZXR1cm5lZCBmcm9tIGdldFVzZXJNZWRpYSgpICBcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBpc1N0ZXJlbyAtIENhbiBiZSB0cnVlIHRvIGluZGljYXRlIHRoYXQgdGhlIHN0cmVhbSBpcyBzdGVyZW8uXG4gICAqIFRoZSBkZWZhdWx0IGlzIGZhbHNlLlxuICAgKi9cbiAgc2V0SW5wdXRBdWRpbyhzdHJlYW06IE1lZGlhU3RyZWFtLCBpc1N0ZXJlbyA9IGZhbHNlKSB7XG4gICAgdGhpcy5faW5wdXRBdWRpb1N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9pc1N0ZXJlbyA9IGlzU3RlcmVvO1xuICAgIGlmICh0aGlzLl9vbklucHV0QXVkaW9DaGFuZ2VkKSB0aGlzLl9vbklucHV0QXVkaW9DaGFuZ2VkKHN0cmVhbSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgdGhhdCB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSBpbnB1dCBhdWRpbyBzdHJlYW0gaXMgY2hhbmdlZFxuICAgKiB2aWEgc2V0SW5wdXRBdWRpbygpIFxuICAgKiBAY2FsbGJhY2sgUmF2aVN0cmVhbUNvbnRyb2xsZXJ+aW5wdXRBdWRpb0NoYW5nZUNhbGxiYWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdHJlYW0gVGhlIG5ldyBzdHJlYW1cbiAgICovXG4gIC8qKlxuICAgKiBBc3NpZ24gYSBjYWxsYmFjayBoYW5kbGVyIGZvciB3aGVuIHRoZSBpbnB1dCBhdWRpbyBzdHJlYW0gZ2V0cyBjaGFuZ2VkXG4gICAqIEBwYXJhbSB7UmF2aVN0cmVhbUNvbnRyb2xsZXJ+aW5wdXRBdWRpb0NoYW5nZUNhbGxiYWNrfSBvbmlucHV0YXVkaW9jaGFuZ2VkIENhbGxiYWNrIHRoYXQgd2lsbCBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgaW5wdXQgYXVkaW8gY2hhbmdlc1xuICAgKi9cbiAgc2V0SW5wdXRBdWRpb0NoYW5nZUhhbmRsZXIob25pbnB1dGF1ZGlvY2hhbmdlZDogRnVuY3Rpb24pIHtcbiAgICBpZiAob25pbnB1dGF1ZGlvY2hhbmdlZCkge1xuICAgICAgdGhpcy5fb25JbnB1dEF1ZGlvQ2hhbmdlZCA9IG9uaW5wdXRhdWRpb2NoYW5nZWQ7XG4gICAgfSBcbiAgfVxuICBcblxuICBzZXRJbnB1dFZpZGVvKHN0cmVhbTogTWVkaWFTdHJlYW0pIHtcbiAgICB0aGlzLl9pbnB1dFZpZGVvU3RyZWFtID0gc3RyZWFtO1xuICAgIGlmICh0aGlzLl9vbklucHV0VmlkZW9DaGFuZ2VkKSB0aGlzLl9vbklucHV0VmlkZW9DaGFuZ2VkKHN0cmVhbSk7XG4gIH1cblxuICBzZXRJbnB1dFZpZGVvQ2hhbmdlSGFuZGxlcihvbmlucHV0dmlkZW9jaGFuZ2VkOiBGdW5jdGlvbikge1xuICAgIGlmIChvbmlucHV0dmlkZW9jaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9vbklucHV0VmlkZW9DaGFuZ2VkID0gb25pbnB1dHZpZGVvY2hhbmdlZDtcbiAgICB9IFxuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoZSBpbmNvbWluZyBhdWRpbyBzdHJlYW0gc3VwcG9ydHMgc3RlcmVvIGlucHV0LFxuICAgKiBhcyBzcGVjaWZpZWQgYnkgc2V0SW5wdXRBdWRpby5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhpcyBpbnB1dCBhdWRpbyB0cmFjayBzdXBwb3J0cyBzdGVyZW8gaW5wdXRcbiAgICovXG4gIGlzU3RlcmVvSW5wdXQoKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQgc3RhdGUgb2YgcGxheSBpcyB0aGF0IHRoZXJlIGlzIHRvbyBtdWNoIGNvbmZ1c2lvbiBpbiB0cnlpbmcgdG9cbiAgICAvLyBjb21wdXRlIHRoaXMgZnJvbSB0aGUgc3RyZWFtIHRyYWNrczpcbiAgICAvLyBUaGUgYnJvd3NlcidzIGdldFVzZXJNZWRpYSBmYWxzZWx5IHJlcG9ydHMgYSBjaGFubmVsQ291bnQgb2YgMiwgc28gd2Ugd291bGRcbiAgICAvLyBmYWxzZWx5IHJlcG9ydCBzdGVyZW8uXG4gICAgLy8gVGhlIE5vZGVKUyB3cnRjIHBhY2thZ2UgaGFzIGEgTWVkaWFTdHJlYW0gdGhhdCBkb2Vzbid0IHN1cHBvcnQgZ2V0U2V0dGluZ3NcbiAgICAvLyBhdCBhbGwsIHNvIHdlIHdvdWxkIGZhbHNlbHkgcmVwb3J0IG1vbm8uXG4gICAgcmV0dXJuIHRoaXMuX2lzU3RlcmVvO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuZCB0aGUgY29udmVyc2F0aW9uIGJ5IHN0b3BwaW5nIGFueSBpbmNvbWluZyB2aWRlb1xuICAgKiBhbmQgcmVtb3RlIGF1ZGlvIHN0cmVhbXMgYW5kIFxuICAgKiByZXNldCB0aGUgc291cmNlIG9iamVjdHMgb2YgdGhlaXIgY29udGFpbmVycy5cbiAgICogTm90ZSB0aGF0IHRoaXMgZG9lcyBOT1Qgc3RvcCBhbnkgbG9jYWwgYXVkaW8gc3RyZWFtcyB0aGF0XG4gICAqIG1pZ2h0IGJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcGVlckNvbm5lY3Rpb24gLS0gaXQgbGVhdmVzXG4gICAqIGhhbmRsaW5nIG9mIHRoYXQgbG9jYWwgYXVkaW8gc3RyZWFtIHRvIHRoZSBpbXBsZW1lbnRpbmcgY2xpZW50LlxuICAgKiBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zdG9wKCkge1xuICAgIFJhdmlVdGlscy5sb2coXCJzdG9wcGluZyBzdHJlYW1zXCIsIFwiUmF2aVN0cmVhbUNvbnRyb2xsZXJcIik7XG5cbiAgICBpZiAodGhpcy5fdmlkZW9Db250YWluZXIgJiYgdGhpcy5fdmlkZW9Db250YWluZXIuc3JjT2JqZWN0KSB7XG4gICAgICBsZXQgc3JjT2JqZWN0ID0gPE1lZGlhU3RyZWFtPiB0aGlzLl92aWRlb0NvbnRhaW5lci5zcmNPYmplY3Q7XG4gICAgICBsZXQgdHJhY2tzID0gc3JjT2JqZWN0LmdldFRyYWNrcygpO1xuICAgICAgdHJhY2tzLmZvckVhY2godHJhY2sgPT4gdHJhY2suc3RvcCgpKTtcbiAgICAgIHRoaXMuX3ZpZGVvQ29udGFpbmVyLnNyY09iamVjdCA9IG51bGw7XG4gICAgICB0aGlzLl9vblZpZGVvU3RyZWFtU3RhdGVDaGFuZ2VkKFwib3ZlclwiKVxuICAgIH1cbiAgICBpZiAodGhpcy5fYXVkaW9TdHJlYW0pIHtcbiAgICAgIHRoaXMuX2F1ZGlvU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4gdHJhY2suc3RvcCgpKTtcbiAgICAgIHRoaXMuX2F1ZGlvU3RyZWFtID0gbnVsbDtcbiAgICB9XG4gICAgXG4gIH1cblxufVxuIiwidmFyIERFQlVHID0gdHJ1ZTtcblxuLyoqIFxuICpcbiAqIEBjbGFzc1xuICogQGNsYXNzZGVzYyBDb2xsZWN0aW9uIG9mIHN0YXRpYyB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIFJhdmlVdGlscyB7XG5cblxuICAvKipcbiAgICogU2ltcGxlIFVVSUQgaW1wbGVtZW50YXRpb24uXG4gICAqIFRha2VuIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTA1MDc0LzUxNTU4NFxuICAgKiBTdHJpY3RseSBzcGVha2luZywgaXQncyBub3QgYSByZWFsIFVVSUQsIGJ1dCBpdCBnaXZlcyB1cyB3aGF0IHdlIG5lZWRcbiAgICogZm9yIFJBVkkgaGFuZGxpbmcuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlVVVJRCgpOiBzdHJpbmcge1xuICAgIGZ1bmN0aW9uIHM0KCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICBcbiAgICByZXR1cm4gczQoKSArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICsgczQoKSArICctJyArIHM0KCkgKyAnLScgKyBzNCgpICsgczQoKSArIHM0KCk7XG4gIH1cbiAgXG4gIFxuICAvKipcbiAgICogV3JhcHMgY29uc29sZS5sb2cgc3VjaCB0aGF0IHdlIHdpbGwgb25seSBvdXRwdXQgYSBtZXNzYWdlIHRvXG4gICAqIGNvbnNvbGUubG9nIGlmIHRoZSBjb25zdGFudCBERUJVRyAoY3VycmVudGx5LCB0aGlzIGlzIHNpbXBseSBkZWZpbmVkXG4gICAqIGFzIGEgZ2xvYmFsIHZhcmlhYmxlIGluaGVyaXRlZCBieSB0aGUgcmF2aS5qcyBmaWxlLCB3aGljaCBpcyBhIGxpdHRsZVxuICAgKiBhd2Z1bCkgaXMgc2V0IHRvIGB0cnVlYC4gKERlZmF1bHRzIHRvIHRydWUuKVxuICAgKiBUaGlzIG1ldGhvZCBkaXNwYXRjaGVzIGEgXCJsb2dnZXJcIiBldmVudCBvbiB0aGUgZG9jdW1lbnQgaW4gY2FzZVxuICAgKiB5b3Ugd2FudCB0byBkbyBzb21ldGhpbmcgZWxzZSB3aXRoIHRoZSBtZXNzYWdlLiBJdCB3aWxsIGFsd2F5c1xuICAgKiBkaXNwYXRjaCB0aGlzIGV2ZW50IHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBvciBub3QgaXQncyBpbiBERUJVRyBtb2RlLFxuICAgKiBiZWNhdXNlIHByZXN1bWFibHkgaWYgeW91J3JlIGxpc3RlbmluZyBmb3IgdGhlIGV2ZW50IGl0J3MgYmVjYXVzZSB5b3VcbiAgICogd2FudCB0byBnZXQgbWVzc2FnZXMuXG4gICAqL1xuICBzdGF0aWMgbG9nKG1lc3NhZ2U6IHN0cmluZywgY2xhc3NuYW1lOiBzdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIGNsYXNzbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIG1lc3NhZ2UgPSBjbGFzc25hbWUgKyBcIjogXCIgKyBtZXNzYWdlO1xuICAgIGlmIChERUJVRykge1xuICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnbG9nZ2VyJywge2RldGFpbDogbWVzc2FnZX0pKTtcbiAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkFkZGl0aW9uYWxseSwgYW4gZXJyb3Igd2FzIGVuY291bnRlcmVkIHRyeWluZyB0byBsb2cgdGhhdC5cIilcbiAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV3JhcHMgY29uc29sZS5sb2cgc3VjaCB0aGF0IHdlIHdpbGwgQUxXQVlTIG91dHB1dCBhIG1lc3NhZ2UsIGFuZFxuICAgKiB0aGF0IG1lc3NhZ2Ugd2lsbCBiZSBpbiByZWQuXG4gICAqIFRoaXMgbWV0aG9kIGRpc3BhdGNoZXMgYW4gXCJlcnJsb2dnZXJcIiBldmVudCBvbiB0aGUgZG9jdW1lbnQgaW4gY2FzZVxuICAgKiB5b3Ugd2FudCB0byBkbyBzb21ldGhpbmcgZWxzZSB3aXRoIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgc3RhdGljIGVycihtZXNzYWdlOiBzdHJpbmcsIGNsYXNzbmFtZTogc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBjbGFzc25hbWUgIT09ICd1bmRlZmluZWQnKSBtZXNzYWdlID0gY2xhc3NuYW1lICsgXCI6IFwiICsgbWVzc2FnZTtcbiAgICBjb25zb2xlLmxvZygnJWMgJXMnLCAnY29sb3I6ICNGQjBBMUMnLCBtZXNzYWdlKTtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2VycmxvZ2dlcicsIHtkZXRhaWw6IG1lc3NhZ2V9KSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIC8vIFJldHVybiBKU09OLnN0cmluZ2lmeShpdGVtKSBpZiBwb3NzaWJsZSwgZWxzZSBpdGVtXG4gICAqL1xuICBzdGF0aWMgc2FmZWx5UHJpbnRhYmxlKGl0ZW06IGFueSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaXRlbSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogRmlndXJlcyBvdXQgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgYSBET00gZWxlbWVudC5cbiAgICovXG4gIHN0YXRpYyBnZXRFbGVtZW50Q1NTU2l6ZShlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBpZiAoIWdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgdmFyIHcgPSBwYXJzZUludChjcy5nZXRQcm9wZXJ0eVZhbHVlKFwid2lkdGhcIiksIDEwKTtcbiAgICB2YXIgaCA9IHBhcnNlSW50KGNzLmdldFByb3BlcnR5VmFsdWUoXCJoZWlnaHRcIiksIDEwKTtcbiAgICByZXR1cm4ge3dpZHRoOiB3LCBoZWlnaHQ6IGh9XG4gIH1cbiAgXG4gIFxuICAvKipcbiAgICogVG9nZ2xlIHRoZSBcImRlYnVnXCIgbW9kZS4gSW4gZGVidWcgbW9kZSwgbW9zdCBldmVyeXRoaW5nIGdldHNcbiAgICogcHJpbnRlZCB0byB0aGUgSlMgY29uc29sZS4gKFNlZSBhbHNvIFJhdmlVdGlscy5qcylcbiAgICogY29ubmVjdHMgdG8gdGhlIHNwZWNpZmllZCBXZWJTb2NrZXQgYWRkcmVzcy5cbiAgICogQHBhcmFtIHtib29sZWFufSBkZWJ1ZyBXaGV0aGVyIG9yIG5vdCB0byBwdXQgdGhlIGxvZ2dlciBpbnRvIGRlYnVnIG1vZGUuXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIHN0YXRpYyBzZXREZWJ1ZyhkZWJ1ZzogYm9vbGVhbikge1xuICAgIERFQlVHID0gZGVidWc7XG4gIH1cblxufVxuIiwiLyoqXHJcbiAqIFRoaXMgdXRpbGl0eSBNb2R1bGUgY29udGFpbnMgY29kZSByZWxhdGVkIHRvIGxvZ2dpbmcgZnJvbSB3aXRoaW4gQVBJIGZ1bmN0aW9ucy5cclxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFVzZWQgZm9yIGRldGVybWluaW5nIHdoYXQgZGF0YSB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBDbGllbnQgQVBJIHNob3VsZCBwcmludCB0byB0aGUgY29uc29sZS4gXHJcbiAqL1xyXG5leHBvcnQgZW51bSBIaUZpTG9nTGV2ZWwge1xyXG4gICAgTm9uZSA9IFwiTm9uZVwiLFxyXG4gICAgRXJyb3IgPSBcIkVycm9yXCIsXHJcbiAgICBXYXJuID0gXCJXYXJuXCIsXHJcbiAgICBEZWJ1ZyA9IFwiRGVidWdcIixcclxufVxyXG5cclxuLyoqXHJcbiAqIEEgd3JhcHBlciBmb3IgQVBJLWludGVybmFsIGBjb25zb2xlLiooKWAgY2FsbHMsIGdhdGVkIGJ5IHRoZSB1c2VyJ3MgY3VycmVudCBsb2cgbGV2ZWwuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSGlGaUxvZ2dlciB7XHJcbiAgICBzdGF0aWMgbG9nTGV2ZWw6IEhpRmlMb2dMZXZlbCA9IEhpRmlMb2dMZXZlbC5FcnJvcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBsb2dMZXZlbCBUaGUgaW5pdGlhbCBMb2cgTGV2ZWwgZm9yIG91ciBMb2dnZXIuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvZ0xldmVsPzogSGlGaUxvZ0xldmVsKSB7XHJcbiAgICAgICAgbG9nTGV2ZWwgPSBsb2dMZXZlbCA/IGxvZ0xldmVsIDogSGlGaUxvZ0xldmVsLkRlYnVnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIG5ldyBIaUZpIExvZyBMZXZlbC5cclxuICAgICAqIEBwYXJhbSBuZXdMb2dMZXZlbCBUaGUgbmV3IExvZyBMZXZlbCBmb3Igb3VyIExvZ2dlci5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHNldEhpRmlMb2dMZXZlbChuZXdMb2dMZXZlbDogSGlGaUxvZ0xldmVsKTogdm9pZCB7XHJcbiAgICAgICAgSGlGaUxvZ2dlci5sb2dMZXZlbCA9IG5ld0xvZ0xldmVsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgdGhlIExvZ2dlcidzIGxvZyBsZXZlbCBpcyBgRGVidWdgLCB3aWxsIHByaW50IGEgZGVidWcgbG9nIHRvIHRoZSBsb2dzLlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gbG9nLlxyXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtZXNzYWdlIHdhcyBvdXRwdXQgdG8gdGhlIGNvbnNvbGU7IGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgbG9nKG1lc3NhZ2U6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmIChIaUZpTG9nZ2VyLmxvZ0xldmVsID09PSBIaUZpTG9nTGV2ZWwuRGVidWcpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEb2VzIHRoZSBzYW1lIHRoaW5nIGFzIHtAbGluayBsb2d9LlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2VcclxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbWVzc2FnZSB3YXMgb3V0cHV0IHRvIHRoZSBjb25zb2xlOyBgZmFsc2VgIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGRlYnVnKG1lc3NhZ2U6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvZyhtZXNzYWdlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSBMb2dnZXIncyBsb2cgbGV2ZWwgaXMgYERlYnVnYCBvciBgV2FybmAsIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGxvZyB0byB0aGUgbG9ncy5cclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGxvZy5cclxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbWVzc2FnZSB3YXMgb3V0cHV0IHRvIHRoZSBjb25zb2xlOyBgZmFsc2VgIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHdhcm4obWVzc2FnZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgaWYgKEhpRmlMb2dnZXIubG9nTGV2ZWwgPT09IEhpRmlMb2dMZXZlbC5EZWJ1ZyB8fCBIaUZpTG9nZ2VyLmxvZ0xldmVsID09PSBIaUZpTG9nTGV2ZWwuV2Fybikge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0aGUgTG9nZ2VyJ3MgbG9nIGxldmVsIGlzIGBEZWJ1Z2Agb3IgYFdhcm5gIG9yIGBFcnJvcmAsIHdpbGwgcHJpbnQgYW4gZXJyb3IgbG9nIHRvIHRoZSBsb2dzLlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gbG9nLlxyXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtZXNzYWdlIHdhcyBvdXRwdXQgdG8gdGhlIGNvbnNvbGU7IGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZXJyb3IobWVzc2FnZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgaWYgKEhpRmlMb2dnZXIubG9nTGV2ZWwgPT09IEhpRmlMb2dMZXZlbC5EZWJ1ZyB8fCBIaUZpTG9nZ2VyLmxvZ0xldmVsID09PSBIaUZpTG9nTGV2ZWwuV2FybiB8fCBIaUZpTG9nZ2VyLmxvZ0xldmVsID09PSBIaUZpTG9nTGV2ZWwuRXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCIvKipcclxuICogVGhpcyBNb2R1bGUgY29udGFpbnMgYSBudW1iZXIgb2YgdXNlZnVsIHV0aWxpdHkgZnVuY3Rpb25zIHRoYXQgQVBJIHVzZXJzIGNhbiB1c2UgaW4gdGhlaXIgYXBwbGljYXRpb25zIGlmIHRoZXkgd2lzaC5cclxuICogU29tZSBvZiB0aGVtIGFyZSBhbHNvIHVzZWQgaW50ZXJuYWxseSBpbiBBUEkgY29kZS5cclxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgSGlGaUxvZ2dlciB9IGZyb20gXCIuL0hpRmlMb2dnZXJcIjtcclxuXHJcbmxldCBub3c6YW55O1xyXG5pZiAodHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAvLyBub2RlIGNvbnRleHRcclxuICAgIHRyeSB7XHJcbiAgICAgICAgbm93ID0gcmVxdWlyZSgncGVyZl9ob29rcycpLnBlcmZvcm1hbmNlLm5vdzsgLy8gVXNlZCB3aXRoIGBwcmVjaXNlSW50ZXJ2YWwoKWAuXHJcbiAgICB9IGNhdGNoIHt9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgSlMgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhlIHR3byBwYXNzZWQgb2JqZWN0cy5cclxuICogXHJcbiAqIFRoaXMgZnVuY3Rpb24gd2FzIGFkYXB0ZWQgZnJvbSBbdGhpcyB2ZXJ5IGhlbHBmdWwgZG9jdW1lbnQgb24gR29NYWtlVGhpbmdzXXtAbGluayBodHRwczovL2dvbWFrZXRoaW5ncy5jb20vZ2V0dGluZy10aGUtZGlmZmVyZW5jZXMtYmV0d2Vlbi10d28tb2JqZWN0cy13aXRoLXZhbmlsbGEtanMvfS5cclxuICogVGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cclxuICogXHJcbiAqIEBwYXJhbSBvYmoxIFxyXG4gKiBAcGFyYW0gb2JqMiBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByZWN1cnNpdmVseURpZmZPYmplY3RzKG9iajE6IGFueSwgb2JqMjogYW55KTogYW55IHtcclxuICAgIC8vIE1ha2Ugc3VyZSBhbiBvYmplY3QgdG8gY29tcGFyZSBpcyBwcm92aWRlZFxyXG4gICAgaWYgKCFvYmoyIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmoyKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcclxuICAgICAgICByZXR1cm4gb2JqMTtcclxuICAgIH1cclxuXHJcbiAgICAvL1xyXG4gICAgLy8gVmFyaWFibGVzXHJcbiAgICAvL1xyXG4gICAgbGV0IGRpZmZzOiBhbnkgPSB7fTtcclxuICAgIGxldCBrZXk7XHJcbiAgICBcclxuICAgIGxldCBkb0FycmF5c01hdGNoID0gKGFycjE6IEFycmF5PGFueT4sIGFycjI6IEFycmF5PGFueT4pID0+IHtcclxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgYXJyYXlzIGFyZSB0aGUgc2FtZSBsZW5ndGhcclxuICAgICAgICBpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIGFsbCBpdGVtcyBleGlzdCBhbmQgYXJlIGluIHRoZSBzYW1lIG9yZGVyXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChhcnIxW2ldICE9PSBhcnIyW2ldKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE90aGVyd2lzZSwgcmV0dXJuIHRydWVcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gQ29tcGFyZSB0d28gaXRlbXMgYW5kIHB1c2ggbm9uLW1hdGNoZXMgdG8gb2JqZWN0XHJcbiAgICBsZXQgY29tcGFyZSA9IChpdGVtMTogYW55LCBpdGVtMjogYW55LCBrZXk6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIC8vIEdldCB0aGUgb2JqZWN0IHR5cGVcclxuICAgICAgICBsZXQgdHlwZTEgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlbTEpO1xyXG4gICAgICAgIGxldCB0eXBlMiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVtMik7XHJcblxyXG4gICAgICAgIC8vIElmIHR5cGUyIGlzIHVuZGVmaW5lZCBpdCBoYXMgYmVlbiByZW1vdmVkXHJcbiAgICAgICAgaWYgKHR5cGUyID09PSAnW29iamVjdCBVbmRlZmluZWRdJykge1xyXG4gICAgICAgICAgICBkaWZmc1trZXldID0gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgaXRlbXMgYXJlIGRpZmZlcmVudCB0eXBlc1xyXG4gICAgICAgIGlmICh0eXBlMSAhPT0gdHlwZTIpIHtcclxuICAgICAgICAgICAgZGlmZnNba2V5XSA9IGl0ZW0yO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiBhbiBvYmplY3QsIGNvbXBhcmUgcmVjdXJzaXZlbHlcclxuICAgICAgICBpZiAodHlwZTEgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XHJcbiAgICAgICAgICAgIGxldCBvYmpEaWZmID0gcmVjdXJzaXZlbHlEaWZmT2JqZWN0cyhpdGVtMSwgaXRlbTIpO1xyXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMob2JqRGlmZikubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgZGlmZnNba2V5XSA9IG9iakRpZmY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgYW4gYXJyYXksIGNvbXBhcmVcclxuICAgICAgICBpZiAodHlwZTEgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcclxuICAgICAgICAgICAgaWYgKCFkb0FycmF5c01hdGNoKGl0ZW0xLCBpdGVtMikpIHtcclxuICAgICAgICAgICAgICAgIGRpZmZzW2tleV0gPSBpdGVtMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFbHNlIGlmIGl0J3MgYSBmdW5jdGlvbiwgY29udmVydCB0byBhIHN0cmluZyBhbmQgY29tcGFyZVxyXG4gICAgICAgIC8vIE90aGVyd2lzZSwganVzdCBjb21wYXJlXHJcbiAgICAgICAgaWYgKHR5cGUxID09PSAnW29iamVjdCBGdW5jdGlvbl0nKSB7XHJcbiAgICAgICAgICAgIGlmIChpdGVtMS50b1N0cmluZygpICE9PSBpdGVtMi50b1N0cmluZygpKSB7XHJcbiAgICAgICAgICAgICAgICBkaWZmc1trZXldID0gaXRlbTI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoaXRlbTEgIT09IGl0ZW0yKSB7XHJcbiAgICAgICAgICAgICAgICBkaWZmc1trZXldID0gaXRlbTI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIExvb3AgdGhyb3VnaCB0aGUgZmlyc3Qgb2JqZWN0XHJcbiAgICBmb3IgKGtleSBpbiBvYmoxKSB7XHJcbiAgICAgICAgaWYgKG9iajEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICBjb21wYXJlKG9iajFba2V5XSwgb2JqMltrZXldLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBMb29wIHRocm91Z2ggdGhlIHNlY29uZCBvYmplY3QgYW5kIGZpbmQgbWlzc2luZyBpdGVtc1xyXG4gICAgZm9yIChrZXkgaW4gb2JqMikge1xyXG4gICAgICAgIGlmIChvYmoyLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgaWYgKCFvYmoxW2tleV0gJiYgb2JqMVtrZXldICE9PSBvYmoyW2tleV0pIHtcclxuICAgICAgICAgICAgICAgIGRpZmZzW2tleV0gPSBvYmoyW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmV0dXJuIHRoZSBvYmplY3Qgb2YgZGlmZmVyZW5jZXNcclxuICAgIHJldHVybiBkaWZmcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcmV0dXJucyBUaGUgXCJiZXN0XCIgYXVkaW8gY29uc3RyYWludHMgc3VwcG9ydGVkIGJ5IHRoZSBjbGllbnQuIEluIHRoaXMgY2FzZSwgXCJiZXN0XCIgaXMgZGVmaW5lZCBhcyBcInRoZSBjb25zdHJhaW50cyB0aGF0IHdpbGwgcHJvZHVjZSB0aGUgaGlnaGVzdC1xdWFsaXR5IGF1ZGlvLlwiXHJcbiAqIFRoYXQgbWVhbnMgZGlzYWJsaW5nIEVjaG8gQ2FuY2VsbGF0aW9uLCBkaXNhYmxpbmcgTm9pc2UgU3VwcHJlc3Npb24sIGFuZCBkaXNhYmxpbmcgQXV0b21hdGljIEdhaW4gQ29udHJvbC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRCZXN0QXVkaW9Db25zdHJhaW50cygpOiBhbnkge1xyXG4gICAgbGV0IGF1ZGlvQ29uc3RyYWludHM6IGFueSA9IHt9O1xyXG5cclxuICAgIGlmICh0eXBlb2YgKG5hdmlnYXRvcikgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgKG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMpICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMoKS5lY2hvQ2FuY2VsbGF0aW9uKSB7XHJcbiAgICAgICAgYXVkaW9Db25zdHJhaW50cy5lY2hvQ2FuY2VsbGF0aW9uID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiAobmF2aWdhdG9yKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgKG5hdmlnYXRvci5tZWRpYURldmljZXMpICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRTdXBwb3J0ZWRDb25zdHJhaW50cykgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRTdXBwb3J0ZWRDb25zdHJhaW50cygpLm5vaXNlU3VwcHJlc3Npb24pIHtcclxuICAgICAgICBhdWRpb0NvbnN0cmFpbnRzLm5vaXNlU3VwcHJlc3Npb24gPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIChuYXZpZ2F0b3IpICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcykgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKCkuYXV0b0dhaW5Db250cm9sKSB7XHJcbiAgICAgICAgYXVkaW9Db25zdHJhaW50cy5hdXRvR2FpbkNvbnRyb2wgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYXVkaW9Db25zdHJhaW50cztcclxufVxyXG5cclxuLyoqXHJcbiAqIGBwcmVjaXNlSW50ZXJ2YWwoKWAgaXMgYSB2ZXJzaW9uIG9mIGBzZXRJbnRlcnZhbCgpYCBmb3IgTm9kZUpTIHRoYXQgZG9lcyBub3Qgc3BpbiBDUFVzIG5vciBkcmlmdC5cclxuICogVGhlIHJldHVybmVkIHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGEgYGNsZWFyKClgIG1ldGhvZHMgdGhhdCBzdG9wcyB0aGUgaW50ZXJ2YWwuXHJcbiAqIEluIHRoZSBicm93c2VyIGNvbnRleHQsIGBwcmVjaXNlSW50ZXJ2YWwoKWAgaXMgc2ltcGx5IGEgd3JhcHBlciBmb3IgYHNldEludGVydmFsKClgLlxyXG4gKiBcclxuICogV2UgZG8gdGhyZWUgdGhpbmdzOlxyXG4gKiAxLiBLZWVwIGEgcnVubmluZyBjb3VudGVyIG9mIHdoZW4gdGhlIG5leHQgY2FsbCBzaG91bGQgYmUsIHRvIGF2b2lkIGRyaWZ0LlxyXG4gKiAyLiBDb21wdXRlIHRoZSB0aW1lIHRvIHRoZSBuZXh0IGNhbGwgYW5kIGdpdmUgdGhhdCB0byBgc2V0VGltZW91dCgpYC5cclxuICogMy4gT3VyIGF2ZXJhZ2UgZXJyb3Igd2l0aCB0aGUgYWJvdmUgaXMgYWJvdXQgMW1zIChzbyBoYWxmIHRoZSBpbnRlcnZhbHMgYXJlIG9mZiBieSBtb3JlKS5cclxuICogU28gaW4gIzIsIHNob290IGZvciAyIG1zIGxlc3MgdGhhbiB0aGF0LCBhbmQgc3BpbiB3aXRoIHNldEltbWVkaWF0ZSAoYWxsb3dpbmcgb3RoZXIgc3R1ZmYgdG8gcnVuKSB1bnRpbCB3ZSd2ZSByZWFjaGVkIHRoZSBleHBlY3RlZCB0aW1lLlxyXG4gKiBcclxuICogRm9yIGEgMTBtcyBpbnRlcnZhbCwgd2UgbWVhc3VyZWQgYW4gKiphdmVyYWdlKiogZXJyb3IgcGVyIGludGVydmFsIG9mOlxyXG4gKiAtIGAxLjY3IG1zYCBmb3IgYHNldEludGVydmFsKClgIChzbyBTT01FVEhJTkcgaXMgdGlja2luZyBhdCA2MCBIeikuXHJcbiAqIC0gYH4xIG1zYCBmb3IgdGhpcyBjb2RlIFdJVEhPVVQgIzMsIHVzaW5nIGBEYXRlLmdldFRpbWUoKWBcclxuICogLSBgfjEgbXNgIGZvciB0aGlzIGNvZGUgV0lUSE9VVCAjMywgdXNpbmcgYHBlcmZfaG9va3MucGVyZm9ybWFuY2Uubm93KClgXHJcbiAqIC0gYDAuODYgbXNgIGZvciB0aGlzIGNvZGUgdXNpbmcgYERhdGUuZ2V0VGltZSgpYFxyXG4gKiAtIGAwLjAzIG1zYCBmb3IgdGhpcyBjb2RlIHVzaW5nIGBwZXJmX2hvb2tzLnBlcmZvcm1hbmNlLm5vdygpYFxyXG4gKiBcclxuICogXHJcbiAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHByZWNpc2UgaW50ZXJ2YWwgZXhwaXJlcy5cclxuICogQHBhcmFtIGludGVydmFsTVMgLSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJldHdlZW4gZWFjaCBpbnRlcnZhbC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwcmVjaXNlSW50ZXJ2YWwoY2FsbGJhY2s6IEZ1bmN0aW9uLCBpbnRlcnZhbE1TOiBudW1iZXIpOiBhbnkge1xyXG4gICAgaWYgKCFub3cpIHtcclxuICAgICAgICBIaUZpTG9nZ2VyLndhcm4oYFxcYHByZWNpc2VJbnRlcnZhbCgpXFxgIGlzIGEgd3JhcHBlciBmb3IgXFxgc2V0SW50ZXJ2YWwoKVxcYCBpbiB0aGUgYnJvd3NlciBjb250ZXh0IWApO1xyXG4gICAgICAgIHJldHVybiBzZXRJbnRlcnZhbChjYWxsYmFjaywgaW50ZXJ2YWxNUyk7ICAgIFxyXG4gICAgfVxyXG5cclxuICAgIGxldCBuZXh0VGljayA9IG5vdygpO1xyXG4gICAgbGV0IGNsZWFyOmFueSA9IGNsZWFyVGltZW91dDtcclxuICAgIGxldCB3cmFwcGVyID0gKCkgPT4ge1xyXG4gICAgICAgIGxldCB0aGlzVGljayA9IG5vdygpO1xyXG4gICAgICAgIGlmICh0aGlzVGljayA8IG5leHRUaWNrKSB7XHJcbiAgICAgICAgICAgIGNsZWFyID0gY2xlYXJJbW1lZGlhdGU7XHJcbiAgICAgICAgICAgIHJldHVybiB0aW1lb3V0ID0gc2V0SW1tZWRpYXRlKHdyYXBwZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuZXh0VGljayArPSBpbnRlcnZhbE1TO1xyXG4gICAgICAgIGNsZWFyID0gY2xlYXJUaW1lb3V0O1xyXG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHdyYXBwZXIsIG5leHRUaWNrIC0gdGhpc1RpY2sgLSAyKTtcclxuICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgfTtcclxuICAgIGxldCB0aW1lb3V0OmFueSA9IHNldFRpbWVvdXQod3JhcHBlcik7XHJcbiAgICByZXR1cm4geyBjbGVhcjogKCkgPT4gY2xlYXIodGltZW91dCkgfTtcclxufVxyXG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuTWVkaWFTdHJlYW0gPSB3aW5kb3cuTWVkaWFTdHJlYW07XG5leHBvcnRzLk1lZGlhU3RyZWFtVHJhY2sgPSB3aW5kb3cuTWVkaWFTdHJlYW1UcmFjaztcbmV4cG9ydHMuUlRDRGF0YUNoYW5uZWwgPSB3aW5kb3cuUlRDRGF0YUNoYW5uZWw7XG5leHBvcnRzLlJUQ0RhdGFDaGFubmVsRXZlbnQgPSB3aW5kb3cuUlRDRGF0YUNoYW5uZWxFdmVudDtcbmV4cG9ydHMuUlRDRHRsc1RyYW5zcG9ydCA9IHdpbmRvdy5SVENEdGxzVHJhbnNwb3J0O1xuZXhwb3J0cy5SVENJY2VDYW5kaWRhdGUgPSB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlO1xuZXhwb3J0cy5SVENJY2VUcmFuc3BvcnQgPSB3aW5kb3cuUlRDSWNlVHJhbnNwb3J0O1xuZXhwb3J0cy5SVENQZWVyQ29ubmVjdGlvbiA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbjtcbmV4cG9ydHMuUlRDUGVlckNvbm5lY3Rpb25JY2VFdmVudCA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbkljZUV2ZW50O1xuZXhwb3J0cy5SVENSdHBSZWNlaXZlciA9IHdpbmRvdy5SVENSdHBSZWNlaXZlcjtcbmV4cG9ydHMuUlRDUnRwU2VuZGVyID0gd2luZG93LlJUQ1J0cFNlbmRlcjtcbmV4cG9ydHMuUlRDUnRwVHJhbnNjZWl2ZXIgPSB3aW5kb3cuUlRDUnRwVHJhbnNjZWl2ZXI7XG5leHBvcnRzLlJUQ1NjdHBUcmFuc3BvcnQgPSB3aW5kb3cuUlRDU2N0cFRyYW5zcG9ydDtcbmV4cG9ydHMuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uID0gd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbjtcbmV4cG9ydHMuZ2V0VXNlck1lZGlhID0gd2luZG93LmdldFVzZXJNZWRpYTtcbmV4cG9ydHMubWVkaWFEZXZpY2VzID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcztcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAnd3MgZG9lcyBub3Qgd29yayBpbiB0aGUgYnJvd3Nlci4gQnJvd3NlciBjbGllbnRzIG11c3QgdXNlIHRoZSBuYXRpdmUgJyArXG4gICAgICAnV2ViU29ja2V0IG9iamVjdCdcbiAgKTtcbn07XG4iLCIvKiAoaWdub3JlZCkgKi8iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHRpZihfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdKSB7XG5cdFx0cmV0dXJuIF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0uZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIG1vZHVsZSBleHBvcnRzIG11c3QgYmUgcmV0dXJuZWQgZnJvbSBydW50aW1lIHNvIGVudHJ5IGlubGluaW5nIGlzIGRpc2FibGVkXG4vLyBzdGFydHVwXG4vLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbnJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvaW5kZXgudHNcIik7XG4iXSwic291cmNlUm9vdCI6IiJ9