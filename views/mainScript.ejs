<% if (isSpeaker) { %>
<script>
    const IS_SPEAKER = true;
</script>
<%} else { %>
<script>
    const IS_SPEAKER = false;
</script>
<% } %>

<script>
    let connectDisconnectButton = document.querySelector('.connectDisconnectButton');
    connectDisconnectButton.addEventListener("click", connectToHiFi);
    connectDisconnectButton.disabled = false;
    let toggleInputMuteButton = document.querySelector('.toggleInputMuteButton');
    toggleInputMuteButton.addEventListener("click", toggleInputMute);
    let outputAudioEl = document.querySelector(`.outputAudioEl`);
    let toggleOutputMuteButton = document.querySelector('.toggleOutputMuteButton');
    toggleOutputMuteButton.addEventListener("click", toggleOutputMute);

    function clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
    }

    function linearScale(factor, minInput, maxInput, minOutput, maxOutput) {
        factor = clamp(factor, minInput, maxInput);

        return minOutput + (maxOutput - minOutput) *
            (factor - minInput) / (maxInput - minInput);
    }

    function getRandomFloat(min, max) {
        return Math.random() * (max - min) + min;
    }

    function hexColorFromString(string) {
        let hash = 0;
        for (let i = 0; i < string.length; i++) {
            hash = string.charCodeAt(i) + ((hash << 5) - hash); // eslint-disable-line
        }

        let color = (hash & 0x00FFFFFF)
            .toString(16)
            .toUpperCase();

        return "#" + "000000".substring(0, 6 - color.length) + color;
    }

    const CONNECTION_TIMESTAMP = connectionTimestamp;
    const VIRTUAL_SPACE_DIMENSIONS_M = {
        "x": 10.0,
        "y": 10.0
    };

    function updateMyPositionAndOrientation(targetPosition, targetOrientation) {
        if (!hifiCommunicator) {
            return;
        }

        let myUserData = allUserData.find((element) => { return element.providedUserID === myProvidedUserID; });
        if (!myUserData) {
            console.error(`Couldn't find \`myUserData\` inside \`allUserData\`!`);
            return;
        }

        if (!myUserData.position) {
            myUserData.position = {};
        }

        if (!myUserData.orientationEuler) {
            myUserData.orientationEuler = {};
        }

        if (targetPosition) {
            Object.assign(myUserData.position, targetPosition);
        }

        if (targetOrientation) {
            Object.assign(myUserData.orientationEuler, targetOrientation);
        }

        console.log(hifiCommunicator.updateUserDataAndTransmit({
            position: myUserData.position,
            orientationEuler: myUserData.orientationEuler,
        }));

        window.requestAnimationFrame(updateCanvas);
    }

    const CLOSE_ENOUGH_M = 0.005;
    const AUDIENCE_RADIUS_M = 2.0;
    const SPEAKER_RADIUS_M = 0.5;
    function positionSelfInCrowd() {
        console.log(`${allUserData.length} users present, including ourselves.\n${speakerCount} speakers.\n${audienceCount} audience members.`);

        let foundOpenSpot = false;
        let currentCircleDivisions = 1;
        let positionsChecked = [];
        let circleRadius = IS_SPEAKER ? SPEAKER_RADIUS_M : AUDIENCE_RADIUS_M;
        while (!foundOpenSpot) {
            for (let theta = 0; theta < 2 * Math.PI; theta += ((2 * Math.PI) / currentCircleDivisions)) {
                let currentPotentialPosition = {
                    "x": (circleRadius) * Math.cos(theta),
                    "y": (circleRadius) * Math.sin(theta)
                };

                currentPotentialPosition.x = Math.round((currentPotentialPosition.x + Number.EPSILON) * 100) / 100;
                currentPotentialPosition.y = Math.round((currentPotentialPosition.y + Number.EPSILON) * 100) / 100;

                if (positionsChecked.find((position) => { return currentPotentialPosition.x === position.x && currentPotentialPosition.y === position.y; })) {
                    continue;
                }
                
                let occupied = allUserData.find((element) => { return element.position && Math.abs(element.position.x - currentPotentialPosition.x) < CLOSE_ENOUGH_M && Math.abs(element.position.y - currentPotentialPosition.y) < CLOSE_ENOUGH_M; });

                if (!occupied) {
                    let orientationYawRadians = Math.atan2(-currentPotentialPosition.x, -currentPotentialPosition.y);
                    let orientationYawDegrees = orientationYawRadians * 180 / Math.PI;
                    if (orientationYawDegrees < 0) {
                        orientationYawDegrees += 360;
                    }
                    let computedOrientation = new HighFidelityAudio.OrientationEuler3D({ "pitchDegrees": 0, "yawDegrees": orientationYawDegrees, "rollDegrees": 0 });
                    updateMyPositionAndOrientation(currentPotentialPosition, computedOrientation);
                    console.log(`Found an open spot at ${JSON.stringify(currentPotentialPosition)} with orientation ${JSON.stringify(computedOrientation)}.`);
                    foundOpenSpot = true;
                    break;
                } else {
                    positionsChecked.push(currentPotentialPosition);
                }
            }

            currentCircleDivisions *= 2;
        }
    }

    function onNewHiFiUserDataReceived(receivedHiFiAudioAPIDataArray) {
        let mustUpdateCanvas = false;
        let gotNewHiFiUser = false;
        let bootedFromSeat = false;

        let myUserData = allUserData.find((element) => { return element.providedUserID === myProvidedUserID; });
        if (!myUserData) {
            console.error(`Couldn't find \`myUserData\` inside \`allUserData\`!`);
        }

        for (let i = 0; i < receivedHiFiAudioAPIDataArray.length; i++) {
            let currentDataFromServer = receivedHiFiAudioAPIDataArray[i];
            let currentProvidedUserID = currentDataFromServer.providedUserID;
            let currentLocalUserData = allUserData.find((element) => { return element.providedUserID === currentProvidedUserID; })
            let isMine = currentProvidedUserID === myProvidedUserID;

            if (currentLocalUserData) {
                if (currentDataFromServer.position) {
                    if (!currentLocalUserData.position) {
                        currentLocalUserData.position = new HighFidelityAudio.Point3D();
                    }

                    if (typeof (currentDataFromServer.position.x) === "number") {
                        currentLocalUserData.position.x = currentDataFromServer.position.x;
                        mustUpdateCanvas = true;
                    }
                    if (typeof (currentDataFromServer.position.y) === "number") {
                        currentLocalUserData.position.y = currentDataFromServer.position.y;
                        mustUpdateCanvas = true;
                    }
                    if (typeof (currentDataFromServer.position.z) === "number") {
                        currentLocalUserData.position.z = currentDataFromServer.position.z;
                        mustUpdateCanvas = true;
                    }
                }

                if (currentDataFromServer.orientationEuler) {
                    if (!currentLocalUserData.orientationEuler) {
                        currentLocalUserData.orientationEuler = new HighFidelityAudio.OrientationEuler3D();
                    }

                    if (typeof (currentDataFromServer.orientationEuler.pitchDegrees) === "number") {
                        currentLocalUserData.orientationEuler.pitchDegrees = currentDataFromServer.orientationEuler.pitchDegrees;

                        mustUpdateCanvas = true;
                    }
                    if (typeof (currentDataFromServer.orientationEuler.yawDegrees) === "number") {
                        if (isMine && currentLocalUserData.orientationEuler.yawDegrees !== currentDataFromServer.orientationEuler.yawDegrees) {
                            // TODO: What is going on here!?
                            // https://highfidelity.atlassian.net/browse/HIFI-316
                            console.warn(`We sent our \`yawDegrees\` as ${currentLocalUserData.orientationEuler.yawDegrees}°, but the server is telling us our \`yawDegrees\` is ${currentDataFromServer.orientationEuler.yawDegrees}°!\nIgnoring server data...`);
                        } else {
                            currentLocalUserData.orientationEuler.yawDegrees = currentDataFromServer.orientationEuler.yawDegrees;
                        }
                        mustUpdateCanvas = true;
                    }
                    if (typeof (currentDataFromServer.orientationEuler.rollDegrees) === "number") {
                        currentLocalUserData.orientationEuler.rollDegrees = currentDataFromServer.orientationEuler.rollDegrees;
                        mustUpdateCanvas = true;
                    }
                }

            } else {
                console.log(`New HiFi User! Provided ID: ${currentProvidedUserID}`);
                gotNewHiFiUser = true;
                let isSpeaker = currentProvidedUserID.indexOf("speaker-") === 0
                allUserData.push(new SpeakerSpaceUserData({
                    providedUserID: currentProvidedUserID,
                    position: currentDataFromServer.position,
                    orientationEuler: currentDataFromServer.orientationEuler,
                    isSpeaker: isSpeaker
                }));
                if (isSpeaker) {
                    speakerCount++;
                } else {
                    audienceCount++;
                }
                mustUpdateCanvas = true;
            }
        }

        let usersSittingInMySeat = allUserData.filter((userData) => { return userData.providedUserID !== myProvidedUserID && Math.abs(myUserData.position.x - userData.position.x) < CLOSE_ENOUGH_M && Math.abs(myUserData.position.y - userData.position.y) < CLOSE_ENOUGH_M; })
        if (usersSittingInMySeat.length > 0 || (gotNewHiFiUser && !receivedInitialOtherUserDataFromHiFi)) {
            if (usersSittingInMySeat.length > 0) {
                console.warn(`Someone else was sitting in our seat! Let's recompute our position.`);
            }
            if (gotNewHiFiUser && !receivedInitialOtherUserDataFromHiFi)) {
                receivedInitialOtherUserDataFromHiFi = true;
            }
            positionSelfInCrowd();
        }

        if (mustUpdateCanvas) {
            window.requestAnimationFrame(updateCanvas);
        }
    }

    class SpeakerSpaceUserData {
        constructor(data) {
            this.providedUserID = data.providedUserID;
            this.position = data.position;
            this.orientationEuler = data.orientationEuler;
            this.isSpeaker = data.isSpeaker;
        }
    }

    let hifiCommunicator;
    let spaceName = '<%- spaceName %>';
    let myProvidedUserID;
    let allUserData = [];
    let speakerCount = 0;
    let audienceCount = 0;
    let receivedInitialOtherUserDataFromHiFi = false;
    async function connectToHiFi() {
        // Disable the Connect button after the user clicks it so we don't double-connect.
        connectDisconnectButton.disabled = true;
        connectDisconnectButton.innerHTML = `Connecting...`;
        toggleInputMuteButton.classList.add("toggleInputMuteButton--disabled");

        // Get the audio media stream associated with the user's default audio input device.
        let audioMediaStream;
        try {
            audioMediaStream = await navigator.mediaDevices.getUserMedia({ audio: HighFidelityAudio.getBestAudioConstraints(), video: false });
        } catch (e) {
            return;
        }

        // Set up the initial data for our user.
        // They'll be standing at the origin, facing "forward".
        let initialHiFiAudioAPIData = new HighFidelityAudio.HiFiAudioAPIData({
            position: new HighFidelityAudio.Point3D({ "x": 0, "y": 0, "z": 0 }),
            orientationEuler: new HighFidelityAudio.OrientationEuler3D({ "pitchDegrees": 0, "yawDegrees": 0, "rollDegrees": 0 })
        });

        HighFidelityAudio.HiFiLogger.setHiFiLogLevel(HighFidelityAudio.HiFiLogLevel.Debug);

        // Set up our `HiFiCommunicator` object, supplying our media stream and initial user data.
        hifiCommunicator = new HighFidelityAudio.HiFiCommunicator({
            initialHiFiAudioAPIData: initialHiFiAudioAPIData,
            transmitRateLimitTimeoutMS: 10,
        });
        await hifiCommunicator.setInputAudioMediaStream(audioMediaStream);

        allUserData = [];
        receivedInitialOtherUserDataFromHiFi = false;
        speakerCount = 0;
        audienceCount = 0;

        // Connect to the HiFi Audio API server!
        try {
            let response = await hifiCommunicator.connectToHiFiAudioAPIServer('<%- hiFiJWT %>');
            myProvidedUserID = response.audionetInitResponse.user_id;
            allUserData.push(new SpeakerSpaceUserData({
                "providedUserID": myProvidedUserID,
                "isSpeaker": IS_SPEAKER
            }));
            if (IS_SPEAKER) {
                speakerCount++;
                positionSelfInCrowd();
            } else {
                setInputMute(true);
                audienceCount++;
            }
            console.log(`My Provided User ID: ${myProvidedUserID}`);
        } catch (e) {
            console.error(`Error connecting to High Fidelity:\n${JSON.stringify(e)}`);
            connectDisconnectButton.disabled = false;
            toggleInputMuteButton.classList.add("toggleInputMuteButton--disabled");
            connectDisconnectButton.innerHTML = `Connection error. Retry?`;
            return;
        }

        updateCanvasDimensions();

        // Show the user that we're connected by changing the text on the button.
        connectDisconnectButton.removeEventListener("click", connectToHiFi);
        connectDisconnectButton.addEventListener("click", disconnectFromHiFi);
        connectDisconnectButton.innerHTML = `Disconnect`;
        connectDisconnectButton.disabled = false;
        toggleInputMuteButton.classList.remove("toggleInputMuteButton--disabled");

        // Set the `srcObject` on our `audio` DOM element to the final, mixed audio stream from the High Fidelity Audio API Server.
        outputAudioEl.srcObject = hifiCommunicator.getOutputAudioMediaStream();
        // We explicitly call `play()` here because certain browsers won't play the newly-set stream automatically.
        outputAudioEl.play();

        // Set up a new User Data Subscription to get User Data updates from the server.
        let newUserDataSubscription = new HighFidelityAudio.UserDataSubscription({
            // Setting `providedUserID` to `null` (or omitting it) means we will get data updates from **all** connected Users, including ourselves.
            "providedUserID": null,
            // There are other components we could subscribe to here, but we're only subscribing to Volume data updates.
            "components": [
                HighFidelityAudio.AvailableUserDataSubscriptionComponents.Position,
                HighFidelityAudio.AvailableUserDataSubscriptionComponents.OrientationEuler,
                HighFidelityAudio.AvailableUserDataSubscriptionComponents.VolumeDecibels
            ],
            // See above for the definition of `onNewHiFiUserDataReceived`.
            "callback": onNewHiFiUserDataReceived
        });
        // Actually add the newly-constructed Data Subscription to the list of our Data Subscriptions on our `HiFiCommunicator`.
        hifiCommunicator.addUserDataSubscription(newUserDataSubscription);
    }

    let isMuted = false;
    async function setInputMute(newMuteStatus) {
        if (!hifiCommunicator) {
            return;
        }
        
        if (isMuted === newMuteStatus) {
            return;
        }

        if (await hifiCommunicator.setInputAudioMuted(newMuteStatus)) {
            isMuted = newMuteStatus;

            if (isMuted) {
                toggleInputMuteButton.classList.add("toggleInputMuteButton--muted");
            } else {
                toggleInputMuteButton.classList.remove("toggleInputMuteButton--muted");
            }
        }
    }

    async function toggleInputMute() {
        await setInputMute(!isMuted)
    }

    function toggleOutputMute() {
        outputAudioEl.muted = !outputAudioEl.muted;
        console.log(`Set output mute status to \`${outputAudioEl.muted}\``);

        if (outputAudioEl.muted) {
            toggleOutputMuteButton.classList.add("toggleOutputMuteButton--muted");
        } else {
            toggleOutputMuteButton.classList.remove("toggleOutputMuteButton--muted");
        }
    }

    function disconnectFromHiFi() {
        console.log(`Disconnecting from High Fidelity Audio API Servers...`);

        connectDisconnectButton.removeEventListener("click", disconnectFromHiFi);
        connectDisconnectButton.addEventListener("click", connectToHiFi);
        connectDisconnectButton.disabled = false;
        connectDisconnectButton.innerHTML = `Connect`;

        toggleInputMuteButton.classList.add("toggleInputMuteButton--disabled");
        isMuted = false;

        if (hifiCommunicator) {
            hifiCommunicator.disconnectFromHiFiAudioAPIServer();
        }
        hifiCommunicator = null;
        allUserData = [];
        
        window.requestAnimationFrame(updateCanvas);
    }

    window.onresize = () => {
        updateCanvasDimensions();
        window.requestAnimationFrame(updateCanvas);
    };
    window.onbeforeunload = disconnectFromHiFi;
</script>